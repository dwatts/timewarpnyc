import {
  b
} from "./chunk-PVUG2RDQ.js";
import {
  t as t3
} from "./chunk-SO7CVIZK.js";
import {
  $,
  H,
  K,
  P,
  U,
  bt,
  dt,
  ht
} from "./chunk-ICEO3WMK.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import {
  Cn,
  Rn,
  en
} from "./chunk-2NXAWKLI.js";
import {
  f,
  m,
  p as p2,
  s as s4,
  v
} from "./chunk-BAMKEIAF.js";
import {
  l2 as l
} from "./chunk-FXYPEAR7.js";
import {
  Z,
  o2 as o,
  r,
  t
} from "./chunk-T35GN7EL.js";
import {
  M,
  x,
  y
} from "./chunk-7U6V6KY2.js";
import {
  A,
  E,
  Q,
  S2 as S,
  p,
  s as s3
} from "./chunk-NFY4EX6G.js";
import {
  s as s2
} from "./chunk-F3KGLZDZ.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import {
  R
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/layers/graphics/data/projectionSupport.js
var l2 = [0, 0];
function h(s6, t6) {
  if (!t6)
    return null;
  if ("x" in t6) {
    const e3 = { x: 0, y: 0 };
    return [e3.x, e3.y] = s6(t6.x, t6.y, l2), null != t6.z && (e3.z = t6.z), null != t6.m && (e3.m = t6.m), e3;
  }
  if ("xmin" in t6) {
    const e3 = { xmin: 0, ymin: 0, xmax: 0, ymax: 0 };
    return [e3.xmin, e3.ymin] = s6(t6.xmin, t6.ymin, l2), [e3.xmax, e3.ymax] = s6(t6.xmax, t6.ymax, l2), t6.hasZ && (e3.zmin = t6.zmin, e3.zmax = t6.zmax, e3.hasZ = true), t6.hasM && (e3.mmin = t6.mmin, e3.mmax = t6.mmax, e3.hasM = true), e3;
  }
  return "rings" in t6 ? { rings: c(t6.rings, s6), hasM: t6.hasM, hasZ: t6.hasZ } : "paths" in t6 ? { paths: c(t6.paths, s6), hasM: t6.hasM, hasZ: t6.hasZ } : "points" in t6 ? { points: p3(t6.points, s6), hasM: t6.hasM, hasZ: t6.hasZ } : null;
}
function c(s6, t6) {
  const e3 = [];
  for (const n3 of s6)
    e3.push(p3(n3, t6));
  return e3;
}
function p3(s6, t6) {
  const e3 = [];
  for (const n3 of s6) {
    const s7 = t6(n3[0], n3[1], [0, 0]);
    e3.push(s7), n3.length > 2 && s7.push(n3[2]), n3.length > 3 && s7.push(n3[3]);
  }
  return e3;
}
async function f2(e3, n3) {
  if (!e3 || !n3)
    return;
  const r3 = Array.isArray(e3) ? e3.map((s6) => null != s6.geometry ? s6.geometry.spatialReference : null).filter(R) : [e3];
  await Rn(r3.map((s6) => ({ source: s6, dest: n3 })));
}
var x2 = h.bind(null, M);
var y2 = h.bind(null, y);
function g(s6, t6, a, m2) {
  if (!s6)
    return s6;
  if (a || (a = t6, t6 = s6.spatialReference), !s3(t6) || !s3(a) || S(t6, a))
    return s6;
  if (x(t6, a)) {
    const t7 = A(a) ? x2(s6) : y2(s6);
    return t7.spatialReference = a, t7;
  }
  return en(t3, [s6], t6, a, null, m2)[0];
}
var _ = class {
  constructor() {
    this._jobs = [], this._timer = null, this._process = this._process.bind(this);
  }
  async push(s6, t6, e3) {
    if (!s6 || !s6.length || !t6 || !e3 || S(t6, e3))
      return s6;
    const n3 = { geometries: s6, inSpatialReference: t6, outSpatialReference: e3, resolve: null };
    return this._jobs.push(n3), new Promise((s7) => {
      n3.resolve = s7, null === this._timer && (this._timer = setTimeout(this._process, 10));
    });
  }
  _process() {
    this._timer = null;
    const s6 = this._jobs.shift();
    if (!s6)
      return;
    const { geometries: t6, inSpatialReference: r3, outSpatialReference: i2, resolve: a } = s6;
    x(r3, i2) ? A(i2) ? a(t6.map(x2)) : a(t6.map(y2)) : a(en(t3, t6, r3, i2, null, null)), this._jobs.length > 0 && (this._timer = setTimeout(this._process, 10));
  }
};
var j = new _();
function M2(s6, t6, e3) {
  return j.push(s6, t6, e3);
}

// node_modules/@arcgis/core/layers/graphics/data/utils.js
var U2 = new s2({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
var M3 = Object.freeze({});
var O = new t2();
var F = new t2();
var N = new t2();
var _2 = { esriGeometryPoint: P, esriGeometryPolyline: $, esriGeometryPolygon: H, esriGeometryMultipoint: U };
function G(e3, t6, i2, r3 = e3.hasZ, n3 = e3.hasM) {
  if (null == t6)
    return null;
  const o3 = e3.hasZ && r3, s6 = e3.hasM && n3;
  if (i2) {
    const l4 = ht(N, t6, e3.hasZ, e3.hasM, "esriGeometryPoint", i2, r3, n3);
    return P(l4, o3, s6);
  }
  return P(t6, o3, s6);
}
function P2(e3, t6, i2, r3, n3, o3, s6 = t6, l4 = i2) {
  var _a, _b, _c;
  const a = t6 && s6, m2 = i2 && l4, u2 = null != r3 ? "coords" in r3 ? r3 : r3.geometry : null;
  if (null == u2)
    return null;
  if (n3) {
    let r4 = dt(F, u2, t6, i2, e3, n3, s6, l4);
    return o3 && (r4 = ht(N, r4, a, m2, e3, o3)), ((_a = _2[e3]) == null ? void 0 : _a.call(_2, r4, a, m2)) ?? null;
  }
  if (o3) {
    const r4 = ht(N, u2, t6, i2, e3, o3, s6, l4);
    return ((_b = _2[e3]) == null ? void 0 : _b.call(_2, r4, a, m2)) ?? null;
  }
  return bt(O, u2, t6, i2, s6, l4), ((_c = _2[e3]) == null ? void 0 : _c.call(_2, O, a, m2)) ?? null;
}
async function v2(e3, t6, i2) {
  const { outFields: r3, orderByFields: n3, groupByFieldsForStatistics: o3, outStatistics: s6 } = e3;
  if (r3)
    for (let l4 = 0; l4 < r3.length; l4++)
      r3[l4] = r3[l4].trim();
  if (n3)
    for (let l4 = 0; l4 < n3.length; l4++)
      n3[l4] = n3[l4].trim();
  if (o3)
    for (let l4 = 0; l4 < o3.length; l4++)
      o3[l4] = o3[l4].trim();
  if (s6)
    for (let l4 = 0; l4 < s6.length; l4++)
      s6[l4].onStatisticField && (s6[l4].onStatisticField = s6[l4].onStatisticField.trim());
  return e3.geometry && !e3.outSR && (e3.outSR = e3.geometry.spatialReference), z(e3, t6, i2);
}
async function z(e3, t6, i2) {
  var _a;
  if (!e3)
    return null;
  let { where: o3 } = e3;
  if (e3.where = o3 = o3 && o3.trim(), (!o3 || /^1 *= *1$/.test(o3) || t6 && t6 === o3) && (e3.where = null), !e3.geometry)
    return e3;
  let s6 = await A2(e3);
  if (e3.distance = 0, e3.units = null, "esriSpatialRelEnvelopeIntersects" === e3.spatialRel) {
    const { spatialReference: t7 } = e3.geometry;
    s6 = l(s6), s6.spatialReference = t7;
  }
  if (s6) {
    await f2(s6.spatialReference, i2), s6 = b2(s6, i2);
    const t7 = (await b(p2(s6)))[0];
    if (null == t7)
      throw M3;
    const r3 = "quantizationParameters" in e3 && ((_a = e3.quantizationParameters) == null ? void 0 : _a.tolerance) || "maxAllowableOffset" in e3 && e3.maxAllowableOffset || 0, o4 = r3 && J(s6, i2) ? { densificationStep: 8 * r3 } : void 0, l4 = t7.toJSON(), m2 = await g(l4, l4.spatialReference, i2, o4);
    if (!m2)
      throw M3;
    m2.spatialReference = i2, e3.geometry = m2;
  }
  return e3;
}
function J(e3, t6) {
  if (!e3)
    return false;
  const r3 = e3.spatialReference;
  return (m(e3) || f(e3) || s4(e3)) && !S(r3, t6) && !Cn(r3, t6);
}
function b2(e3, t6) {
  const i2 = e3.spatialReference;
  return J(e3, t6) && m(e3) ? { spatialReference: i2, rings: [[[e3.xmin, e3.ymin], [e3.xmin, e3.ymax], [e3.xmax, e3.ymax], [e3.xmax, e3.ymin], [e3.xmin, e3.ymin]]] } : e3;
}
async function A2(e3) {
  const { distance: i2, units: r3 } = e3, n3 = e3.geometry;
  if (null == i2 || "vertexAttributes" in n3)
    return n3;
  const o3 = n3.spatialReference, s6 = r3 ? U2.fromJSON(r3) : Q(o3), l4 = o3 && (E(o3) || A(o3)) ? n3 : await f2(o3, p).then(() => g(n3, p));
  return (await B())(l4.spatialReference, l4, i2, s6);
}
async function B() {
  return (await import("./geometryEngineJSON-XYKVXVEY.js")).geodesicBuffer;
}
function Z2(e3) {
  return e3 && q in e3 ? JSON.parse(JSON.stringify(e3, E2)) : e3;
}
var q = "_geVersion";
var E2 = (e3, t6) => e3 !== q ? t6 : void 0;

// node_modules/@arcgis/core/geometry/support/intersects.js
function s5(s6) {
  return "mesh" === s6 ? o : Z(s6);
}

// node_modules/@arcgis/core/layers/graphics/contains.js
function n(n3, t6) {
  return n3 ? t6 ? 4 : 3 : t6 ? 3 : 2;
}
function t4(n3, t6, r3, e3) {
  return o2(n3, t6, r3, e3.coords[0], e3.coords[1]);
}
function r2(t6, r3, e3, c3, u2, f4) {
  const s6 = n(u2, f4), { coords: i2, lengths: l4 } = c3;
  if (!l4)
    return false;
  for (let n3 = 0, d = 0; n3 < l4.length; n3++, d += s6)
    if (!o2(t6, r3, e3, i2[d], i2[d + 1]))
      return false;
  return true;
}
function o2(t6, r3, o3, c3, u2) {
  if (!t6)
    return false;
  const f4 = n(r3, o3), { coords: s6, lengths: i2 } = t6;
  let l4 = false, d = 0;
  for (const n3 of i2)
    l4 = e(l4, s6, f4, d, n3, c3, u2), d += n3 * f4;
  return l4;
}
function e(n3, t6, r3, o3, e3, c3, u2) {
  let f4 = n3, s6 = o3;
  for (let i2 = o3, l4 = o3 + e3 * r3; i2 < l4; i2 += r3) {
    s6 = i2 + r3, s6 === l4 && (s6 = o3);
    const n4 = t6[i2], e4 = t6[i2 + 1], d = t6[s6], g3 = t6[s6 + 1];
    (e4 < u2 && g3 >= u2 || g3 < u2 && e4 >= u2) && n4 + (u2 - e4) / (g3 - e4) * (d - n4) < c3 && (f4 = !f4);
  }
  return f4;
}

// node_modules/@arcgis/core/layers/graphics/data/spatialQuerySupport.js
var c2 = "feature-store:unsupported-query";
var R2 = { esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "intersects", esriSpatialRelIndexIntersects: null, esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: null };
var S2 = { spatialRelationship: { esriSpatialRelIntersects: true, esriSpatialRelContains: true, esriSpatialRelWithin: true, esriSpatialRelCrosses: true, esriSpatialRelDisjoint: true, esriSpatialRelTouches: true, esriSpatialRelOverlaps: true, esriSpatialRelEnvelopeIntersects: true, esriSpatialRelIndexIntersects: false, esriSpatialRelRelation: false }, queryGeometry: { esriGeometryPoint: true, esriGeometryMultipoint: true, esriGeometryPolyline: true, esriGeometryPolygon: true, esriGeometryEnvelope: true }, layerGeometry: { esriGeometryPoint: true, esriGeometryMultipoint: true, esriGeometryPolyline: true, esriGeometryPolygon: true, esriGeometryEnvelope: false } };
function G3(e3) {
  return null != e3 && true === S2.spatialRelationship[e3];
}
function g2(e3) {
  return null != e3 && true === S2.queryGeometry[v(e3)];
}
function j2(e3) {
  return null != e3 && true === S2.layerGeometry[e3];
}
function h3() {
  return import("./geometryEngineJSON-XYKVXVEY.js");
}
function v3(e3, n3, l4, y4, c3) {
  if (f(n3) && "esriGeometryPoint" === l4 && ("esriSpatialRelIntersects" === e3 || "esriSpatialRelContains" === e3)) {
    const e4 = K(new t2(), n3, false, false);
    return Promise.resolve((r3) => t4(e4, false, false, r3));
  }
  if (f(n3) && "esriGeometryMultipoint" === l4) {
    const r3 = K(new t2(), n3, false, false);
    if ("esriSpatialRelContains" === e3)
      return Promise.resolve((e4) => r2(r3, false, false, e4, y4, c3));
  }
  if (m(n3) && "esriGeometryPoint" === l4 && ("esriSpatialRelIntersects" === e3 || "esriSpatialRelContains" === e3))
    return Promise.resolve((e4) => t(n3, P2(l4, y4, c3, e4)));
  if (m(n3) && "esriGeometryMultipoint" === l4 && "esriSpatialRelContains" === e3)
    return Promise.resolve((e4) => r(n3, P2(l4, y4, c3, e4)));
  if (m(n3) && "esriSpatialRelIntersects" === e3) {
    const e4 = s5(l4);
    return Promise.resolve((r3) => e4(n3, P2(l4, y4, c3, r3)));
  }
  return h3().then((r3) => {
    const t6 = r3[R2[e3]].bind(null, n3.spatialReference, n3);
    return (e4) => t6(P2(l4, y4, c3, e4));
  });
}
async function P3(r3, t6, i2) {
  const { spatialRel: s6, geometry: o3 } = r3;
  if (o3) {
    if (!G3(s6))
      throw new s(c2, "Unsupported query spatial relationship", { query: r3 });
    if (s3(o3.spatialReference) && s3(i2)) {
      if (!g2(o3))
        throw new s(c2, "Unsupported query geometry type", { query: r3 });
      if (!j2(t6))
        throw new s(c2, "Unsupported layer geometry type", { query: r3 });
      if (r3.outSR)
        return f2(r3.geometry && r3.geometry.spatialReference, r3.outSR);
    }
  }
}
function I(e3) {
  if (m(e3))
    return true;
  if (f(e3)) {
    for (const r3 of e3.rings) {
      if (5 !== r3.length)
        return false;
      if (r3[0][0] !== r3[1][0] || r3[0][0] !== r3[4][0] || r3[2][0] !== r3[3][0] || r3[0][1] !== r3[3][1] || r3[0][1] !== r3[4][1] || r3[1][1] !== r3[2][1])
        return false;
    }
    return true;
  }
  return false;
}

// node_modules/@arcgis/core/layers/graphics/data/timeSupport.js
async function t5(t6, n3) {
  if (!t6)
    return null;
  const e3 = n3.featureAdapter, { startTimeField: u2, endTimeField: l4 } = t6;
  let r3 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY;
  if (u2 && l4)
    await n3.forEach((t7) => {
      const n4 = e3.getAttribute(t7, u2), a = e3.getAttribute(t7, l4);
      null == n4 || isNaN(n4) || (r3 = Math.min(r3, n4)), null == a || isNaN(a) || (i2 = Math.max(i2, a));
    });
  else {
    const t7 = u2 || l4;
    await n3.forEach((n4) => {
      const u3 = e3.getAttribute(n4, t7);
      null == u3 || isNaN(u3) || (r3 = Math.min(r3, u3), i2 = Math.max(i2, u3));
    });
  }
  return { start: r3, end: i2 };
}
function n2(t6, n3, r3) {
  if (!n3 || !t6)
    return null;
  const { startTimeField: i2, endTimeField: a } = t6;
  if (!i2 && !a)
    return null;
  const { start: o3, end: s6 } = n3;
  return null === o3 && null === s6 ? null : void 0 === o3 && void 0 === s6 ? l3() : i2 && a ? e2(r3, i2, a, o3, s6) : u(r3, i2 || a, o3, s6);
}
function e2(t6, n3, e3, u2, l4) {
  return null != u2 && null != l4 ? (r3) => {
    const i2 = t6.getAttribute(r3, n3), a = t6.getAttribute(r3, e3);
    return (null == i2 || i2 <= l4) && (null == a || a >= u2);
  } : null != u2 ? (n4) => {
    const l5 = t6.getAttribute(n4, e3);
    return null == l5 || l5 >= u2;
  } : null != l4 ? (e4) => {
    const u3 = t6.getAttribute(e4, n3);
    return null == u3 || u3 <= l4;
  } : void 0;
}
function u(t6, n3, e3, u2) {
  return null != e3 && null != u2 && e3 === u2 ? (u3) => t6.getAttribute(u3, n3) === e3 : null != e3 && null != u2 ? (l4) => {
    const r3 = t6.getAttribute(l4, n3);
    return r3 >= e3 && r3 <= u2;
  } : null != e3 ? (u3) => t6.getAttribute(u3, n3) >= e3 : null != u2 ? (e4) => t6.getAttribute(e4, n3) <= u2 : void 0;
}
function l3() {
  return () => false;
}

export {
  f2 as f,
  g,
  M2 as M,
  M3 as M2,
  G,
  P2 as P,
  v2 as v,
  z,
  Z2 as Z,
  v3 as v2,
  P3 as P2,
  I,
  t5 as t,
  n2 as n
};
//# sourceMappingURL=chunk-O2Q4W74O.js.map
