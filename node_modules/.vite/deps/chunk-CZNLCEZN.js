import {
  h2 as h,
  h3 as h2
} from "./chunk-FXYPEAR7.js";
import {
  M
} from "./chunk-T35GN7EL.js";
import {
  f,
  p,
  x2 as x
} from "./chunk-7U6V6KY2.js";
import {
  r
} from "./chunk-NFY4EX6G.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a
} from "./chunk-IYZKKFJM.js";

// node_modules/@arcgis/core/geometry/Multipoint.js
var h3;
function l(t) {
  return (s, e2) => null == s ? e2 : null == e2 ? s : t(s, e2);
}
function c(t) {
  return t && ("esri.geometry.SpatialReference" === t.declaredClass || null != t.wkid);
}
var m = h3 = class extends p {
  constructor(...t) {
    super(...t), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t, s) {
    if (!t && !s)
      return {};
    const e2 = {};
    Array.isArray(t) ? (e2.points = t, e2.spatialReference = s) : c(t) ? e2.spatialReference = t : (t.points && (e2.points = t.points), t.spatialReference && (e2.spatialReference = t.spatialReference), t.hasZ && (e2.hasZ = t.hasZ), t.hasM && (e2.hasM = t.hasM));
    const i = e2.points && e2.points[0];
    return i && (void 0 === e2.hasZ && void 0 === e2.hasM ? (e2.hasZ = i.length > 2, e2.hasM = false) : void 0 === e2.hasZ ? e2.hasZ = i.length > 3 : void 0 === e2.hasM && (e2.hasM = i.length > 3)), e2;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t = this.points;
    if (!t.length)
      return null;
    const s = new M(), e2 = this.hasZ, i = this.hasM, r2 = e2 ? 3 : 2, n = t[0], a3 = l(Math.min), p2 = l(Math.max);
    let h4, c3, m3, u3, [f3, y2] = n, [d, g] = n;
    for (let o = 0, l2 = t.length; o < l2; o++) {
      const s2 = t[o], [n2, l3] = s2;
      if (f3 = a3(f3, n2), y2 = a3(y2, l3), d = p2(d, n2), g = p2(g, l3), e2 && s2.length > 2) {
        const t2 = s2[2];
        h4 = a3(h4, t2), m3 = p2(m3, t2);
      }
      if (i && s2.length > r2) {
        const t2 = s2[r2];
        c3 = a3(c3, t2), u3 = p2(u3, t2);
      }
    }
    return s.xmin = f3, s.ymin = y2, s.xmax = d, s.ymax = g, s.spatialReference = this.spatialReference, e2 ? (s.zmin = h4, s.zmax = m3) : (s.zmin = void 0, s.zmax = void 0), i ? (s.mmin = c3, s.mmax = u3) : (s.mmin = void 0, s.mmax = void 0), s;
  }
  writePoints(t, e2) {
    e2.points = a(this.points);
  }
  addPoint(t) {
    return h2(this, t), Array.isArray(t) ? this.points.push(t) : this.points.push(t.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t = { points: a(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t.hasZ = true), this.hasM && (t.hasM = true), new h3(t);
  }
  getPoint(t) {
    if (!this._validateInputs(t))
      return null;
    const s = this.points[t], e2 = { x: s[0], y: s[1], spatialReference: this.spatialReference };
    let i = 2;
    return this.hasZ && (e2.z = s[2], i = 3), this.hasM && (e2.m = s[i]), new x(e2);
  }
  removePoint(t) {
    if (!this._validateInputs(t))
      return null;
    const s = new x(this.points.splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s;
  }
  setPoint(t, s) {
    return this._validateInputs(t) ? (h2(this, s), Array.isArray(s) || (s = s.toArray()), this.points[t] = s, this.notifyChange("points"), this) : this;
  }
  toJSON(t) {
    return this.write({}, t);
  }
  _validateInputs(t) {
    return null != t && t >= 0 && t < this.points.length;
  }
};
e([y({ readOnly: true })], m.prototype, "cache", null), e([y()], m.prototype, "extent", null), e([y({ type: [[Number]], json: { write: { isRequired: true } } })], m.prototype, "points", void 0), e([r("points")], m.prototype, "writePoints", null), m = h3 = e([a2("esri.geometry.Multipoint")], m), m.prototype.toJSON.isDefaultToJSON = true;
var u = m;

// node_modules/@arcgis/core/geometry/Polyline.js
var c2;
function u2(t) {
  return !Array.isArray(t[0]);
}
var f2 = c2 = class extends p {
  constructor(...t) {
    super(...t), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t, e2) {
    let s, r2, i = null, a3 = null;
    return t && !Array.isArray(t) ? (i = t.paths ?? null, e2 || (t.spatialReference ? e2 = t.spatialReference : t.paths || (e2 = t)), s = t.hasZ, r2 = t.hasM) : i = t, i = i || [], e2 = e2 || f.WGS84, i.length && i[0] && null != i[0][0] && "number" == typeof i[0][0] && (i = [i]), a3 = i[0] && i[0][0], a3 && (void 0 === s && void 0 === r2 ? (s = a3.length > 2, r2 = false) : void 0 === s ? s = !r2 && a3.length > 3 : void 0 === r2 && (r2 = !s && a3.length > 3)), { paths: i, spatialReference: e2, hasZ: s, hasM: r2 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t } = this, e2 = h(this);
    if (!e2)
      return null;
    const s = new M(e2);
    return s.spatialReference = t, s;
  }
  writePaths(t, s) {
    s.paths = a(this.paths);
  }
  addPath(t) {
    if (!t)
      return;
    const e2 = this.paths, s = e2.length;
    if (u2(t)) {
      const r2 = [];
      for (let e3 = 0, s2 = t.length; e3 < s2; e3++)
        r2[e3] = t[e3].toArray();
      e2[s] = r2;
    } else
      e2[s] = t.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t = new c2();
    return t.spatialReference = this.spatialReference, t.paths = a(this.paths), t.hasZ = this.hasZ, t.hasM = this.hasM, t;
  }
  getPoint(t, e2) {
    if (!this._validateInputs(t, e2))
      return null;
    const s = this.paths[t][e2], r2 = this.hasZ, i = this.hasM;
    return r2 && !i ? new x(s[0], s[1], s[2], void 0, this.spatialReference) : i && !r2 ? new x(s[0], s[1], void 0, s[2], this.spatialReference) : r2 && i ? new x(s[0], s[1], s[2], s[3], this.spatialReference) : new x(s[0], s[1], this.spatialReference);
  }
  insertPoint(t, e2, s) {
    return this._validateInputs(t, e2, true) ? (h2(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t].splice(e2, 0, s), this.notifyChange("paths"), this) : this;
  }
  removePath(t) {
    if (!this._validateInputs(t, null))
      return null;
    const e2 = this.paths.splice(t, 1)[0], s = this.spatialReference, r2 = e2.map((t2) => new x(t2, s));
    return this.notifyChange("paths"), r2;
  }
  removePoint(t, e2) {
    if (!this._validateInputs(t, e2))
      return null;
    const s = new x(this.paths[t].splice(e2, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s;
  }
  setPoint(t, e2, s) {
    return this._validateInputs(t, e2) ? (h2(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t][e2] = s, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t, e2, s = false) {
    if (null == t || t < 0 || t >= this.paths.length)
      return false;
    if (null != e2) {
      const r2 = this.paths[t];
      if (s && (e2 < 0 || e2 > r2.length))
        return false;
      if (!s && (e2 < 0 || e2 >= r2.length))
        return false;
    }
    return true;
  }
  toJSON(t) {
    return this.write({}, t);
  }
};
e([y({ readOnly: true })], f2.prototype, "cache", null), e([y({ readOnly: true })], f2.prototype, "extent", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], f2.prototype, "paths", void 0), e([r("paths")], f2.prototype, "writePaths", null), f2 = c2 = e([a2("esri.geometry.Polyline")], f2), f2.prototype.toJSON.isDefaultToJSON = true;
var m2 = f2;

export {
  u,
  m2 as m
};
//# sourceMappingURL=chunk-CZNLCEZN.js.map
