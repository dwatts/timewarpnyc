import {
  i as i4
} from "./chunk-3IKQDWZ7.js";
import "./chunk-S2L2EMCY.js";
import {
  o as o4
} from "./chunk-3LR4MDXK.js";
import "./chunk-J3HE7QNA.js";
import "./chunk-GRB6LNZN.js";
import "./chunk-GZTLZ6RD.js";
import {
  A,
  L,
  r as r3
} from "./chunk-NLWV7Q6F.js";
import {
  t as t3
} from "./chunk-VVUQCXYW.js";
import {
  c as c4,
  i as i3,
  o as o5,
  s as s5,
  u as u2
} from "./chunk-OTNLRAEN.js";
import {
  e as e2,
  t as t2
} from "./chunk-VN2IXVGV.js";
import {
  n as n5,
  r as r4
} from "./chunk-SS3YG6J3.js";
import {
  c as c3
} from "./chunk-G32FVJ4L.js";
import {
  O
} from "./chunk-XJXVKVA7.js";
import "./chunk-HVAOWOGC.js";
import {
  Rn,
  nn,
  tn
} from "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-IR32DXLL.js";
import {
  a as a2
} from "./chunk-BS4MX2AF.js";
import {
  t
} from "./chunk-R47DHBCM.js";
import "./chunk-KGA7WAD3.js";
import {
  a as a3
} from "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-ZUBHLDU6.js";
import "./chunk-C3PCK5WU.js";
import "./chunk-HE256ZWN.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import {
  b
} from "./chunk-PZXYASUU.js";
import {
  n as n3
} from "./chunk-5EXFDBQJ.js";
import "./chunk-W3WHCGIQ.js";
import {
  l as l2
} from "./chunk-HPWZ2OON.js";
import {
  l
} from "./chunk-GWA3PLGA.js";
import {
  c as c2
} from "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import {
  R,
  c,
  i as i2,
  v
} from "./chunk-3U2FS2TT.js";
import {
  i
} from "./chunk-7JNPZC53.js";
import {
  n as n4
} from "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import {
  V
} from "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import {
  _
} from "./chunk-DH42JQZX.js";
import {
  n as n2
} from "./chunk-J2V5CZSS.js";
import {
  m as m3
} from "./chunk-7D57YBLP.js";
import {
  j as j2
} from "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import {
  V as V2,
  Y,
  Z,
  st,
  tt
} from "./chunk-OBGBLQQX.js";
import {
  j
} from "./chunk-FXYPEAR7.js";
import {
  o as o3
} from "./chunk-V3CNLYUD.js";
import {
  m as m2
} from "./chunk-TEHNQYQD.js";
import {
  S as S2,
  o as o2
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  r as r2
} from "./chunk-3CQBBMMD.js";
import {
  M,
  x as x2
} from "./chunk-T35GN7EL.js";
import {
  f,
  x2 as x
} from "./chunk-7U6V6KY2.js";
import {
  S2 as S,
  o,
  r
} from "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import {
  s as s4
} from "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import {
  u2 as u
} from "./chunk-CHTUPHTO.js";
import {
  m,
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  s2 as s3
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/core/perspectiveUtils.js
var f2 = n();
var i5 = e2();
var e3 = e2();
var p = e2();
function h(t4, r5, n8) {
  return o2(f2, r5[0], r5[1], 1), S2(f2, f2, o5(i5, n8)), 0 === f2[2] ? r3(t4, f2[0], f2[1]) : r3(t4, f2[0] / f2[2], f2[1] / f2[2]);
}
function j3(s6, n8, o6) {
  return k(e3, n8[0], n8[1], n8[2], n8[3], n8[4], n8[5], n8[6], n8[7]), k(p, o6[0], o6[1], o6[2], o6[3], o6[4], o6[5], o6[6], o6[7]), i3(s6, c4(e3, e3), p), 0 !== s6[8] && (s6[0] /= s6[8], s6[1] /= s6[8], s6[2] /= s6[8], s6[3] /= s6[8], s6[4] /= s6[8], s6[5] /= s6[8], s6[6] /= s6[8], s6[7] /= s6[8], s6[8] /= s6[8]), s6;
}
function k(o6, c7, u3, e4, p3, h2, j6, k3, v2) {
  s5(o6, c7, e4, h2, u3, p3, j6, 1, 1, 1), o2(f2, k3, v2, 1), c4(i5, o6);
  const [x3, b3, d2] = S2(f2, f2, o5(i5, i5));
  return s5(i5, x3, 0, 0, 0, b3, 0, 0, 0, d2), i3(o6, i5, o6);
}

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c5 = class extends l {
  projectOrWarn(e4, r5) {
    if (null == e4)
      return e4;
    const { geometry: t4, pending: c7 } = tn(e4, r5);
    return c7 ? null : c7 || t4 ? t4 : (s.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e4, sourceSpatialReference: e4.spatialReference, targetSpatialReference: r5 }), null);
  }
};
c5 = e([a("esri.layers.support.GeoreferenceBase")], c5);
var a4 = c5;

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var C = e2();
var T = n5();
var _2 = class extends m {
  constructor() {
    super(...arguments), this.sourcePoint = null, this.mapPoint = null;
  }
};
e([y()], _2.prototype, "sourcePoint", void 0), e([y({ type: x })], _2.prototype, "mapPoint", void 0), _2 = e([a("esri.layers.support.ControlPoint")], _2);
var O2 = class extends u(a4) {
  constructor(o6) {
    super(o6), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(o6, t4) {
    const r5 = f.fromJSON(t4.spatialReference), n8 = t2(...t4.coefficients, 1);
    return o6.map((o7) => (r3(T, o7.x, o7.y), h(T, T, n8), { sourcePoint: o7, mapPoint: new x({ x: T[0], y: T[1], spatialReference: r5 }) }));
  }
  writeControlPoints(o6, t4, n8, i7) {
    if (null != this.transform)
      null != o6 && k2(o6[0]) && (t4.controlPoints = o6.map((o7) => {
        const t5 = o7.sourcePoint;
        return { x: t5.x, y: t5.y };
      }), t4.spatialReference = o6[0].mapPoint.spatialReference.toJSON(), t4.coefficients = this.transform.slice(0, 8));
    else {
      const o7 = new s2("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration.", { layer: i7 == null ? void 0 : i7.layer, georeference: this });
      (i7 == null ? void 0 : i7.messages) ? i7.messages.push(o7) : s.getLogger(this).error(o7.name, o7.message);
    }
  }
  get coords() {
    if (null == this.controlPoints)
      return null;
    const o6 = this._updateTransform(C);
    if (null == o6 || !k2(this.controlPoints[0]))
      return null;
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    return K(o6, this.width, this.height, t4);
  }
  set coords(o6) {
    if (null == this.controlPoints || !k2(this.controlPoints[0]))
      return;
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (o6 = this.projectOrWarn(o6, t4)))
      return;
    const { width: r5, height: n8 } = this, { rings: [[e4, s6, c7, a6]] } = o6, p3 = { sourcePoint: c2(0, n8), mapPoint: new x({ x: e4[0], y: e4[1], spatialReference: t4 }) }, u3 = { sourcePoint: c2(0, 0), mapPoint: new x({ x: s6[0], y: s6[1], spatialReference: t4 }) }, m5 = { sourcePoint: c2(r5, 0), mapPoint: new x({ x: c7[0], y: c7[1], spatialReference: t4 }) }, f4 = { sourcePoint: c2(r5, n8), mapPoint: new x({ x: a6[0], y: a6[1], spatialReference: t4 }) };
    k2(p3) && k2(u3) && k2(m5) && k2(f4) && (E(C, p3, u3, m5, f4), this.controlPoints = this.controlPoints.map(({ sourcePoint: o7 }) => (r3(T, o7.x, o7.y), h(T, T, C), { sourcePoint: o7, mapPoint: new x({ x: T[0], y: T[1], spatialReference: t4 }) })));
  }
  get inverseTransform() {
    return null == this.transform ? null : u2(e2(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(o6) {
    if (null == o6 || null == this.transform || null == this.controlPoints || !k2(this.controlPoints[0]))
      return null;
    r3(T, o6.x, o6.y);
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    return h(T, T, this.transform), new x({ x: T[0], y: T[1], spatialReference: t4 });
  }
  toSource(o6) {
    if (null == o6 || null == this.inverseTransform || null == this.controlPoints || !k2(this.controlPoints[0]))
      return null;
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    return o6 = o6.normalize(), null == (o6 = tn(o6, t4).geometry) ? null : (r3(T, o6.x, o6.y), h(T, T, this.inverseTransform), c2(T[0], T[1]));
  }
  _updateTransform(o6) {
    const { controlPoints: t4, width: r5, height: n8 } = this;
    if (!(null != t4 && r5 > 0 && n8 > 0))
      return null;
    const [e4, i7, s6, l4] = t4;
    if (!k2(e4))
      return null;
    const c7 = e4.mapPoint.spatialReference, a6 = this._projectControlPoint(i7, c7), p3 = this._projectControlPoint(s6, c7), u3 = this._projectControlPoint(l4, c7);
    if (!a6.valid || !p3.valid || !u3.valid)
      return null;
    if (!k2(a6.controlPoint))
      return null;
    null == o6 && (o6 = e2());
    let m5 = null;
    return m5 = k2(p3.controlPoint) && k2(u3.controlPoint) ? E(o6, e4, a6.controlPoint, p3.controlPoint, u3.controlPoint) : k2(p3.controlPoint) ? B(o6, e4, a6.controlPoint, p3.controlPoint) : z(o6, e4, a6.controlPoint), m5.every((o7) => 0 === o7) ? null : m5;
  }
  _projectControlPoint(o6, t4) {
    if (!k2(o6))
      return { valid: true, controlPoint: o6 };
    const { sourcePoint: r5, mapPoint: n8 } = o6, { geometry: i7, pending: s6 } = tn(n8, t4);
    return s6 ? { valid: false, controlPoint: null } : s6 || i7 ? { valid: true, controlPoint: { sourcePoint: r5, mapPoint: i7 } } : (s.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: o6, sourceSpatialReference: n8.spatialReference, targetSpatialReference: t4 }), { valid: false, controlPoint: null });
  }
};
function k2(o6) {
  return null != o6 && null != o6.sourcePoint && null != o6.mapPoint;
}
e([y({ type: [_2], json: { write: { allowNull: false, isRequired: true } } })], O2.prototype, "controlPoints", void 0), e([o("controlPoints")], O2.prototype, "readControlPoints", null), e([r("controlPoints")], O2.prototype, "writeControlPoints", null), e([y()], O2.prototype, "coords", null), e([y({ json: { write: true } })], O2.prototype, "height", void 0), e([y({ readOnly: true })], O2.prototype, "inverseTransform", null), e([y({ readOnly: true })], O2.prototype, "transform", null), e([y({ json: { write: true } })], O2.prototype, "width", void 0), O2 = e([a("esri.layers.support.ControlPointsGeoreference")], O2);
var b2 = n5();
var I = n5();
var M2 = n5();
var N = n5();
var A2 = n5();
var J = n5();
var L2 = n5();
var U = n5();
var G = Math.PI / 2;
function q(o6, t4, r5) {
  r3(o6, r5.sourcePoint.x, r5.sourcePoint.y), r3(t4, r5.mapPoint.x, r5.mapPoint.y);
}
function z(o6, t4, r5) {
  return q(b2, A2, t4), q(I, J, r5), L(M2, I, b2, G), L(N, b2, I, G), L(L2, J, A2, -G), L(U, A2, J, -G), H(o6, b2, I, M2, N, A2, J, L2, U);
}
function B(o6, t4, r5, n8) {
  return q(b2, A2, t4), q(I, J, r5), q(M2, L2, n8), A(N, b2, I, 0.5), L(N, M2, N, Math.PI), A(U, A2, J, 0.5), L(U, L2, U, Math.PI), H(o6, b2, I, M2, N, A2, J, L2, U);
}
function E(o6, t4, r5, n8, e4) {
  return q(b2, A2, t4), q(I, J, r5), q(M2, L2, n8), q(N, U, e4), H(o6, b2, I, M2, N, A2, J, L2, U);
}
var W = new Array(8).fill(0);
var D = new Array(8).fill(0);
function F(o6, t4, r5, n8, e4) {
  return o6[0] = t4[0], o6[1] = t4[1], o6[2] = r5[0], o6[3] = r5[1], o6[4] = n8[0], o6[5] = n8[1], o6[6] = e4[0], o6[7] = e4[1], o6;
}
function H(o6, t4, r5, n8, e4, i7, l4, c7, a6) {
  return j3(o6, F(W, t4, r5, n8, e4), F(D, i7, l4, c7, a6));
}
function K(o6, t4, r5, n8) {
  const e4 = r4(0, r5), s6 = r4(0, 0), l4 = r4(t4, 0), c7 = r4(t4, r5);
  return h(e4, e4, o6), h(s6, s6, o6), h(l4, l4, o6), h(c7, c7, o6), new j({ rings: [[e4, s6, l4, c7, e4]], spatialReference: n8 });
}
var Q = O2;

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var n6 = class extends a4 {
  constructor(t4) {
    super(t4), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t4, topRight: e4, bottomLeft: o6, bottomRight: r5 } = this;
    if (null == t4 || null == e4 || null == o6 || null == r5)
      return null;
    const p3 = t4.spatialReference;
    return e4 = this.projectOrWarn(e4, p3), o6 = this.projectOrWarn(o6, p3), r5 = this.projectOrWarn(r5, p3), null == e4 || null == o6 || null == r5 ? null : new j({ rings: [[[o6.x, o6.y], [t4.x, t4.y], [e4.x, e4.y], [r5.x, r5.y], [o6.x, o6.y]]], spatialReference: p3 });
  }
  set coords(t4) {
    const { topLeft: e4 } = this;
    if (null == e4)
      return;
    const o6 = e4.spatialReference;
    if (null == (t4 = this.projectOrWarn(t4, o6)))
      return;
    const { rings: [[s6, p3, n8, i7]] } = t4;
    this.bottomLeft = new x({ x: s6[0], y: s6[1], spatialReference: o6 }), this.topLeft = new x({ x: p3[0], y: p3[1], spatialReference: o6 }), this.topRight = new x({ x: n8[0], y: n8[1], spatialReference: o6 }), this.bottomRight = new x({ x: i7[0], y: i7[1], spatialReference: o6 });
  }
};
e([y()], n6.prototype, "coords", null), e([y({ type: x })], n6.prototype, "bottomLeft", void 0), e([y({ type: x })], n6.prototype, "bottomRight", void 0), e([y({ type: x })], n6.prototype, "topLeft", void 0), e([y({ type: x })], n6.prototype, "topRight", void 0), n6 = e([a("esri.layers.support.CornersGeoreference")], n6);
var i6 = n6;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var c6 = class extends a4 {
  constructor(t4) {
    super(t4), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent)
      return null;
    const { xmin: t4, ymin: e4, xmax: r5, ymax: o6, spatialReference: s6 } = this.extent;
    let n8;
    if (this.rotation) {
      const { x: s7, y: i7 } = this.extent.center, a6 = p2(s7, i7, this.rotation);
      n8 = [a6(t4, e4), a6(t4, o6), a6(r5, o6), a6(r5, e4)], n8.push(n8[0]);
    } else
      n8 = [[t4, e4], [t4, o6], [r5, o6], [r5, e4], [t4, e4]];
    return new j({ rings: [n8], spatialReference: s6 });
  }
  set coords(t4) {
    if (null == t4 || null == this.extent)
      return;
    const r5 = this.extent.spatialReference;
    if (null == (t4 = this.projectOrWarn(t4, r5)) || null == t4.extent)
      return;
    const { rings: [[o6, s6, i7]], extent: { center: { x: a6, y: c7 } } } = t4, m5 = m2(Math.PI / 2 - Math.atan2(s6[1] - o6[1], s6[0] - o6[0])), l4 = p2(a6, c7, -m5), [u3, x3] = l4(o6[0], o6[1]), [h2, f4] = l4(i7[0], i7[1]);
    this.extent = new M({ xmin: u3, ymin: x3, xmax: h2, ymax: f4, spatialReference: r5 }), this.rotation = m5;
  }
};
function p2(t4, e4, r5) {
  const o6 = r2(r5), n8 = Math.cos(o6), i7 = Math.sin(o6);
  return (r6, o7) => [n8 * (r6 - t4) + i7 * (o7 - e4) + t4, n8 * (o7 - e4) - i7 * (r6 - t4) + e4];
}
e([y()], c6.prototype, "coords", null), e([y({ type: M })], c6.prototype, "extent", void 0), e([y({ type: Number })], c6.prototype, "rotation", void 0), c6 = e([a("esri.layers.support.ExtentAndRotationGeoreference")], c6);
var m4 = c6;

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var f3 = { key: "type", base: a4, typeMap: { "control-points": Q, corners: i6, "extent-and-rotation": m4 } };
var l3 = class extends i(u(_)) {
  constructor(e4) {
    super(e4), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e4) {
    return Q.fromJSON(e4);
  }
};
e([y({ types: f3, json: { write: true } })], l3.prototype, "georeference", void 0), e([o("georeference")], l3.prototype, "readGeoreference", null), e([y()], l3.prototype, "opacity", void 0), l3 = e([a("esri.layers.support.MediaElementBase")], l3);
var d = l3;

// node_modules/@arcgis/core/layers/support/ImageElement.js
var j4 = class extends d {
  constructor(e4) {
    super(e4), this.content = null, this.image = null, this.type = "image", this.image = null;
  }
  load() {
    const e4 = this.image;
    if ("string" == typeof e4) {
      const r5 = j2(e4, { responseType: "image" }).then(({ data: e5 }) => {
        this._set("content", e5);
      });
      this.addResolvingPromise(r5);
    } else if (e4 instanceof HTMLImageElement) {
      const t4 = e4.decode().then(() => {
        this._set("content", e4);
      });
      this.addResolvingPromise(t4);
    } else
      e4 ? this._set("content", e4) : this.addResolvingPromise(Promise.reject(new s2("image-element:invalid-image-type", "Invalid image type", { image: e4 })));
    return Promise.resolve(this);
  }
  readImage(e4, t4, r5) {
    return i2(t4.url, r5);
  }
  writeImage(e4, t4, r5, n8) {
    if (null == e4)
      return;
    const a6 = n8 == null ? void 0 : n8.portalItem, m5 = n8 == null ? void 0 : n8.resources;
    if (!a6 || !m5)
      return void ("string" == typeof e4 && (t4[r5] = c(e4, n8)));
    const p3 = "string" != typeof e4 || tt(e4) || Z(e4) ? null : e4;
    if (p3) {
      if (null == v(p3))
        return void (t4[r5] = p3);
      const e5 = c(p3, { ...n8, verifyItemRelativeUrls: n8 && n8.verifyItemRelativeUrls ? { writtenUrls: n8.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, R.NO);
      if (a6 && e5 && !Y(e5))
        return m5.toKeep.push({ resource: a6.resourceFromPath(e5), compress: false }), void (t4[r5] = e5);
    }
    t4[r5] = "<pending>", m5.pendingOperations.push(w(e4).then((e5) => {
      const o6 = T2(e5, a6);
      t4[r5] = o6.itemRelativeUrl, m5.toAdd.push({ resource: o6, content: e5, compress: false, finish: (e6) => {
        this.image = e6.url;
      } });
    }));
  }
};
e([y({ readOnly: true })], j4.prototype, "content", void 0), e([y({ json: { name: "url", type: String } })], j4.prototype, "image", void 0), e([o("image", ["url"])], j4.prototype, "readImage", null), e([r("image")], j4.prototype, "writeImage", null), e([y({ readOnly: true, json: { name: "mediaType" } })], j4.prototype, "type", void 0), j4 = e([a("esri.layers.support.ImageElement")], j4);
var I2 = j4;
async function w(e4) {
  if ("string" == typeof e4) {
    if (Z(e4)) {
      const { data: r5 } = await j2(e4, { responseType: "blob" });
      return r5;
    }
    if (tt(e4))
      return st(e4);
    return w((await j2(e4, { responseType: "image" })).data);
  }
  return new Promise((t4) => E2(e4).toBlob(t4));
}
function E2(e4) {
  if (e4 instanceof HTMLCanvasElement)
    return e4;
  const t4 = e4 instanceof HTMLImageElement ? e4.naturalWidth : e4.width, r5 = e4 instanceof HTMLImageElement ? e4.naturalHeight : e4.height, o6 = document.createElement("canvas"), s6 = o6.getContext("2d");
  return o6.width = t4, o6.height = r5, e4 instanceof HTMLImageElement ? s6.drawImage(e4, 0, 0, e4.width, e4.height) : e4 instanceof ImageData && s6.putImageData(e4, 0, 0), o6;
}
function T2(e4, t4) {
  const r5 = n3(), o6 = `${V2("media", r5)}.${t3(e4)}`;
  return t4.resourceFromPath(o6);
}

// node_modules/@arcgis/core/layers/support/VideoElement.js
var n7 = class extends d {
  constructor(e4) {
    super(e4), this.content = null, this.type = "video";
  }
  load() {
    const e4 = this.video;
    if ("string" == typeof e4) {
      const o6 = document.createElement("video");
      o6.src = e4, o6.crossOrigin = "anonymous", o6.autoplay = true, o6.muted = true, o6.loop = true, this.addResolvingPromise(this._loadVideo(o6).then(() => {
        this._set("content", o6);
      }));
    } else
      e4 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e4).then(() => {
        this._set("content", e4);
      })) : this.addResolvingPromise(Promise.reject(new s2("video-element:invalid-video-type", "Invalid video type", { video: e4 })));
    return Promise.resolve(this);
  }
  set video(e4) {
    "not-loaded" === this.loadStatus ? this._set("video", e4) : s.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  _loadVideo(e4) {
    return new Promise((o6, t4) => {
      e4.oncanplay = () => {
        e4.oncanplay = null, e4.play().then(o6, t4);
      }, "anonymous" !== e4.crossOrigin && (e4.crossOrigin = "anonymous", e4.src = e4.src);
    });
  }
};
e([y({ readOnly: true })], n7.prototype, "content", void 0), e([y()], n7.prototype, "video", null), n7 = e([a("esri.layers.support.VideoElement")], n7);
var a5 = n7;

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var M3 = { key: "type", defaultKeyValue: "image", base: d, typeMap: { image: I2, video: a5 } };
var I3 = V.ofType(M3);
var S3 = class extends _.LoadableMixin(m3(a3(n2.EventedAccessor))) {
  constructor(e4) {
    super(e4), this._index = new o4(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e5) => {
      for (const s6 of e5.removed) {
        const e6 = this._elementViewsMap.get(s6);
        this._elementViewsMap.delete(s6), this._index.delete(e6), this.handles.remove(e6), e6.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t4 } = this;
      for (const s6 of e5.added) {
        if (this._elementViewsMap.get(s6))
          continue;
        const e6 = new i4({ spatialReference: t4, element: s6 });
        this._elementViewsMap.set(s6, e6);
        const r5 = l2(() => e6.coords, () => this._updateIndexForElement(e6, false));
        this._updateIndexForElement(e6, true), this.handles.add(r5, e6);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e6, t5) => this._elementsIndexes.set(e6, t5)), this.emit("refresh");
    }, this.elements = new I3();
  }
  async load(e4) {
    if (s3(e4), !this.spatialReference) {
      const e5 = this.elements.find((e6) => null != e6.georeference && null != e6.georeference.coords);
      this._set("spatialReference", e5 ? e5.georeference.coords.spatialReference : f.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.handles.add(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e4) {
    this._set("elements", n4(e4, this._get("elements"), I3));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus)
      return null;
    const e4 = this._index.fullBounds;
    return null == e4 ? null : new M({ xmin: e4[0], ymin: e4[1], xmax: e4[2], ymax: e4[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e4) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e4) : s.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e4, t4) {
    await this.load(), await Rn(e4.spatialReference, this.spatialReference, null, t4);
    const s6 = S(e4.spatialReference, this.spatialReference) ? e4 : nn(e4, this.spatialReference);
    if (!s6)
      return [];
    const r5 = s6.normalize(), o6 = [];
    for (const n8 of r5)
      this._index.forEachInBounds(o3(n8), ({ normalizedCoords: e5, element: t5 }) => {
        null != e5 && x2(n8, e5) && o6.push(t5);
      });
    return o6.sort((e5, t5) => this._elementsIndexes.get(e5) - this._elementsIndexes.get(t5)), o6;
  }
  _updateIndexForElement(e4, t4) {
    const s6 = e4.normalizedBounds, r5 = this._index.has(e4), o6 = null != s6;
    this._index.delete(e4), o6 && this._index.set(e4, s6), this.notifyChange("fullExtent"), t4 || (r5 !== o6 ? this.emit("refresh") : this.emit("change", { element: e4.element }));
  }
};
e([y()], S3.prototype, "elements", null), e([y({ readOnly: true })], S3.prototype, "fullExtent", null), e([y()], S3.prototype, "spatialReference", null), S3 = e([a("esri.layers.support.LocalMediaElementSource")], S3);
var V3 = S3;

// node_modules/@arcgis/core/layers/MediaLayer.js
function S4(e4) {
  return "object" == typeof e4 && null != e4 && "type" in e4;
}
var g = class extends a2(t(c3(O(b)))) {
  constructor(e4) {
    super(e4), this.effectiveSource = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this.source = new V3();
  }
  load(e4) {
    const t4 = this.source;
    if (!t4)
      return this.addResolvingPromise(Promise.reject(new s2("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer."))), Promise.resolve(this);
    const s6 = S4(t4) ? new V3({ elements: new V([t4]) }) : t4;
    this._set("effectiveSource", s6), this.spatialReference && (s6.spatialReference = this.spatialReference);
    const i7 = s6.load(e4).then(() => {
      this.spatialReference = s6.spatialReference;
    });
    return this.addResolvingPromise(i7), Promise.resolve(this);
  }
  destroy() {
    var _a, _b;
    (_a = this.effectiveSource) == null ? void 0 : _a.destroy(), (_b = this.source) == null ? void 0 : _b.destroy();
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  set source(e4) {
    "not-loaded" === this.loadStatus ? this._set("source", e4) : s.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e4) {
    return e4 ? Array.isArray(e4) ? new V3({ elements: new V(e4) }) : e4 instanceof V ? new V3({ elements: e4 }) : e4 : null;
  }
  readSource(e4, r5, o6) {
    const t4 = "image" === r5.mediaType ? new I2() : "video" === r5.mediaType ? new a5() : null;
    return t4 == null ? void 0 : t4.read(r5, o6), t4;
  }
  writeSource(e4, r5, t4, s6) {
    var _a;
    e4 && S4(e4) && "image" === e4.type ? e4.write(r5, s6) : (s6 == null ? void 0 : s6.messages) && ((_a = s6 == null ? void 0 : s6.messages) == null ? void 0 : _a.push(new s2("media-layer:unsupported-source", "source must be an 'ImageElement'")));
  }
};
e([y({ readOnly: true })], g.prototype, "effectiveSource", void 0), e([y({ type: String })], g.prototype, "copyright", void 0), e([y({ readOnly: true })], g.prototype, "fullExtent", null), e([y({ type: ["MediaLayer"] })], g.prototype, "operationalLayerType", void 0), e([y({ type: ["show", "hide"] })], g.prototype, "listMode", void 0), e([y({ nonNullable: true, json: { write: { enabled: true, allowNull: false } } })], g.prototype, "source", null), e([s4("source")], g.prototype, "castSource", null), e([o("source", ["url"])], g.prototype, "readSource", null), e([r("source")], g.prototype, "writeSource", null), e([y()], g.prototype, "spatialReference", void 0), e([y({ readOnly: true })], g.prototype, "type", void 0), g = e([a("esri.layers.MediaLayer")], g);
var j5 = g;
export {
  j5 as default
};
//# sourceMappingURL=MediaLayer-R2IZ5CVT.js.map
