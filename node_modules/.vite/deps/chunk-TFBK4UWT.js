import {
  A as A2,
  E,
  I as I2
} from "./chunk-57BN4YG4.js";
import {
  r
} from "./chunk-DEBQNQHK.js";
import {
  a as a3
} from "./chunk-UVYXRE2S.js";
import {
  n as n2
} from "./chunk-GD75B7SP.js";
import {
  d as d3
} from "./chunk-AGK2CKWJ.js";
import {
  o
} from "./chunk-WON6TZX6.js";
import {
  m as m2,
  x
} from "./chunk-5RQTPWCM.js";
import {
  u
} from "./chunk-SU7C3V7L.js";
import {
  C
} from "./chunk-FUNFO42Y.js";
import {
  t
} from "./chunk-644IM3NW.js";
import {
  h as h2
} from "./chunk-WT7BDUIR.js";
import {
  d
} from "./chunk-MXVQCJ4K.js";
import {
  n,
  p
} from "./chunk-3FVFBGNT.js";
import {
  w as w2
} from "./chunk-4KXQQ53L.js";
import {
  d as d2
} from "./chunk-TBKQVVVQ.js";
import {
  b as b2
} from "./chunk-CF43FEIV.js";
import {
  b
} from "./chunk-HVAOWOGC.js";
import {
  y as y2
} from "./chunk-WIQR3T32.js";
import {
  a as a2,
  f as f2,
  h,
  l as l2,
  w
} from "./chunk-HPWZ2OON.js";
import {
  h as h3
} from "./chunk-WAPUHORU.js";
import {
  $,
  D,
  Ee,
  F,
  I,
  L,
  b as b3,
  g,
  i,
  q,
  v
} from "./chunk-UHAU5IXU.js";
import {
  f
} from "./chunk-7U6V6KY2.js";
import {
  m,
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  c2 as c,
  j,
  l,
  s2 as s3
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  A
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/support/PBFDecoder.js
var a4 = class {
  constructor(e2) {
    this._controller = e2, this._handle = new i2((r2) => e2.schedule(r2));
  }
  destroy() {
    this._handle.destroy();
  }
  invoke(r2, s4) {
    return r2.buffer && 0 !== r2.buffer.byteLength ? (r2.options.sourceSpatialReference && r2.options.sourceSpatialReference instanceof f && (r2.options = { ...r2.options, sourceSpatialReference: r2.options.sourceSpatialReference.toJSON() }), this._handle.invoke(r2, s4).then((r3) => {
      let s5 = 0, a5 = 0;
      const i4 = async (l3) => {
        if (r3.spatialReference = f.fromJSON(r3.spatialReference), r3.fields) {
          for (; s5 < r3.fields.length; )
            if (r3.fields[s5] = y2.fromJSON(r3.fields[s5]), s5++, l3.madeProgress())
              return this._controller.reschedule((e2) => i4(e2));
        }
        const c3 = r3.spatialReference;
        for (; a5 < r3.features.length; ) {
          const s6 = r3.features[a5];
          if (++a5, s6.uid = h3.generateUID(), null != s6.geometry && (s6.geometry.spatialReference = c3, n3(s6.geometry), l3.madeProgress()))
            return this._controller.reschedule((e2) => i4(e2));
        }
        return r3;
      };
      return this._controller.schedule((e2) => i4(e2));
    })) : Promise.resolve(null);
  }
};
function n3(e2) {
  switch (e2.type) {
    case "polyline":
      e2.paths.reduce((e3, r2) => e3 + r2.length, 0) < A && (e2.paths = e2.hasZ || e2.hasM ? e2.paths.map((e3) => e3.map((e4) => [e4[0], e4[1], e4[2]])) : e2.paths.map((e3) => e3.map((e4) => [e4[0], e4[1]])));
      break;
    case "polygon":
      e2.rings.reduce((e3, r2) => e3 + r2.length, 0) < A && (e2.rings = e2.hasZ || e2.hasM ? e2.rings.map((e3) => e3.map((e4) => [e4[0], e4[1], e4[2]])) : e2.rings.map((e3) => e3.map((e4) => [e4[0], e4[1]])));
  }
}
var i2 = class extends h2 {
  constructor(e2) {
    super("PBFDecoderWorker", "_parseFeatureQuery", { _parseFeatureQuery: (e3) => [e3.buffer] }, e2);
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/featureTileQuery3D.js
var p2 = class extends m {
  constructor(e2) {
    super(e2);
  }
  get queryFeaturesDehydrated() {
    var _a;
    const e2 = this.layer.capabilities, r2 = e2 && e2.query, t2 = r2 && r2.supportsFormatPBF, u2 = this.layer.parsedUrl;
    if (t2) {
      null == this._decoder && (this._decoder = new a4(this.controller));
      const e3 = { sourceSpatialReference: ((_a = this.layer.spatialReference) == null ? void 0 : _a.toJSON()) ?? null, applyTransform: true, maxStringAttributeLength: 1024 };
      return (r3, t3) => x(u2, r3, "pbf", this._createRequestOptions(t3)).then((r4) => (s3(t3), null != this._decoder ? this._decoder.invoke({ buffer: r4.data, options: e3 }, t3.signal) : Promise.reject(c())));
    }
    return (e3, r3) => m2(u2, e3, this.layer.spatialReference, this._createRequestOptions(r3)).then((e4) => d(e4.data));
  }
  queryFeatureCount(e2, r2) {
    return this.layer.queryFeatureCount(e2, r2);
  }
  destroy() {
    this._decoder = l(this._decoder);
  }
  _createRequestOptions(e2) {
    return { ...e2, query: { ...this.layer.customParameters, token: this.layer.apiKey, ...e2 == null ? void 0 : e2.query } };
  }
};
e([y({ constructOnly: true })], p2.prototype, "layer", void 0), e([y({ constructOnly: true })], p2.prototype, "controller", void 0), e([y({ readOnly: true })], p2.prototype, "queryFeaturesDehydrated", null), p2 = e([a("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceQuery3D")], p2);
var c2 = class extends m {
  constructor(e2) {
    super(e2);
  }
  queryFeaturesDehydrated(e2, r2) {
    return this.layer.queryFeatures(e2, r2);
  }
  queryFeatureCount(e2, r2) {
    return this.layer.queryFeatureCount(e2, r2);
  }
};
e([y({ constructOnly: true })], c2.prototype, "layer", void 0), e([y({ readOnly: true })], c2.prototype, "queryFeaturesDehydrated", null), c2 = e([a("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceMeshQuery3D")], c2);
var d4 = class extends m {
  constructor(e2) {
    super(e2);
  }
  queryFeaturesDehydrated(e2, r2) {
    return this.layer.queryFeatures(e2, r2);
  }
};
e([y({ constructOnly: true })], d4.prototype, "layer", void 0), d4 = e([a("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceQuery3D")], d4);
var h4 = class extends m {
  constructor(e2) {
    super(e2);
  }
  queryFeaturesDehydrated(e2, r2) {
    return this.source.queryFeaturesJSON(e2, r2).then(d, (t2) => {
      if (t2 && "query-features-json:unsupported" === t2.name)
        return this.layer.queryFeatures(e2, r2);
      throw t2;
    });
  }
  queryFeatureCount(e2, r2) {
    return this.layer.queryFeatureCount(e2, r2);
  }
};
function m3(e2, r2) {
  return "feature" === e2.type && "feature-layer" === e2.source.type ? null != e2.infoFor3D ? new c2({ layer: e2 }) : new p2({ layer: e2, controller: r2 }) : "feature" === e2.type && "memory" === e2.source.type || "csv" === e2.type || "geojson" === e2.type || "oriented-imagery" === e2.type || "wfs" === e2.type ? new h4({ layer: e2, source: e2.source }) : "ogc-feature" === e2.type ? new d4({ layer: e2 }) : null;
}
e([y({ constructOnly: true })], h4.prototype, "layer", void 0), e([y({ constructOnly: true })], h4.prototype, "source", void 0), h4 = e([a("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileClientQuery3D")], h4);

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3DLayerViewContext.js
var i3 = class {
  constructor(e2) {
    this._memoryCache = null, this._capabilities = null;
    const r2 = e2.layerView.layer;
    this._layerView = e2.layerView, this.objectIdField = r2.objectIdField, this.globalIdField = "globalIdField" in r2 ? r2.globalIdField : null, this._returnZ = e2.returnZ, this._returnM = e2.returnM;
    const i4 = this._layerView.view.resourceController;
    this.query = m3(r2, i4.normal), i4 && this._memoryCacheEnabled && (this._memoryCache = i4.memoryController.newCache(`fl-${r2.uid}`));
  }
  get _memoryCacheEnabled() {
    switch (this._layerView.layer.source.type) {
      case "feature-layer":
      case "ogc-feature":
      case "oriented-imagery":
        return true;
      case "csv":
      case "geojson":
      case "memory":
      case "wfs":
        return false;
    }
  }
  destroy() {
    this._memoryCache = l(this._memoryCache), this.query.destroy();
  }
  createQuery() {
    const e2 = this._layerView.layer.createQuery();
    return e2.outFields = this._layerView.availableFields, e2.returnZ = this._returnZ, e2.returnM = this._returnM, e2.outSpatialReference = this.tilingScheme.spatialReference, e2;
  }
  get memoryCache() {
    return this._memoryCache;
  }
  get viewingMode() {
    return this._layerView.view.state.viewingMode;
  }
  get tilingScheme() {
    return this._layerView.view.featureTiles.tilingScheme;
  }
  get scheduler() {
    const e2 = this._layerView.view.resourceController;
    return e2 ? e2.scheduler : null;
  }
  get geometryType() {
    return this._layerView.layer.geometryType;
  }
  get fullExtent() {
    return this._layerView.layer.fullExtent;
  }
  get tileMaxRecordCount() {
    return this._layerView.layer.capabilities.query.tileMaxRecordCount;
  }
  get maxRecordCount() {
    return this._layerView.layer.capabilities.query.maxRecordCount;
  }
  get capabilities() {
    return null != this._capabilities || (this._capabilities = A2(this._layerView.layer)), this._capabilities;
  }
  logFetchError(e2, r2) {
    e2.error("#fetchTile()", this._layerView.layer, r2 && r2.message ? r2.message : r2);
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var q2 = "esri.views.layers.FeatureLayerView";
var P = s.getLogger(q2);
var _ = (r2) => {
  let _3 = class extends r2 {
    constructor(...e2) {
      super(...e2), this._updatingRequiredFieldsPromise = null, this.filter = null, this.timeExtent = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.handles.add([l2(() => {
        var _a;
        const e2 = this.layer;
        return [(_a = e2 == null ? void 0 : e2.elevationInfo) == null ? void 0 : _a.featureExpressionInfo, e2 && "displayField" in e2 ? e2.displayField : null, e2 && "timeInfo" in e2 && e2.timeInfo, e2 && "renderer" in e2 && e2.renderer, e2 && "labelingInfo" in e2 && e2.labelingInfo, e2 && "floorInfo" in e2 && e2.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), w), a2(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), a2(() => {
        const e2 = this.layer;
        return e2 && "sublayers" in e2 ? e2.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      const { layer: e2, layer: { fieldsIndex: t2 }, requiredFields: r3 } = this;
      return "outFields" in e2 && e2.outFields ? g(t2, [...b3(t2, e2.outFields), ...r3]) : g(t2, r3);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e2) {
      this._override("featureEffect", e2);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e2) {
      P.error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e2) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e2 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t2 = null != this.filter ? this.filter.createQuery(e2) : new b2(e2);
      if ("feature" === this.layer.type) {
        const e3 = o(this);
        null != e3 && (t2.where = t2.where ? `(${t2.where}) AND (${e3})` : e3);
      }
      return null != this.timeExtent && (t2.timeExtent = null != t2.timeExtent ? t2.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t2;
    }
    createAggregateQuery() {
      const e2 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b2(e2);
    }
    queryFeatures(e2, t2) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e2, t2) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e2, t2) {
      throw new Error("missing implementation");
    }
    queryExtent(e2, t2) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeatures(e2, t2) {
      const r3 = this.validateFetchPopupFeatures(t2);
      if (r3)
        throw r3;
      return this.fetchClientPopupFeatures(t2);
    }
    _loadArcadeModules(e2) {
      return e2.get("expressionInfos.length") || Array.isArray(e2.content) && e2.content.some((e3) => "expression" === e3.type) ? i() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e2 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e2), e2.then(() => {
        this._updatingRequiredFieldsPromise === e2 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view)
        return;
      const e2 = "3d" === this.view.type, { layer: t2, layer: { fieldsIndex: r3, objectIdField: s4 } } = this, o2 = "renderer" in t2 && t2.renderer, n4 = "orderBy" in t2 && t2.orderBy, l3 = "featureReduction" in t2 ? t2.featureReduction : null, a5 = /* @__PURE__ */ new Set(), u2 = await j([o2 ? o2.collectRequiredFields(a5, r3) : null, q(a5, t2), e2 ? v(a5, t2) : null, null != this.filter ? L(a5, t2, this.filter) : null, null != this.featureEffect ? L(a5, t2, this.featureEffect.filter) : null, l3 ? $(a5, t2, l3) : null, n4 ? D(a5, t2, n4) : null]);
      if ("timeInfo" in t2 && t2.timeInfo && this.timeExtent && F(a5, t2.fieldsIndex, [t2.timeInfo.startField, t2.timeInfo.endField]), "feature" === t2.type && (t2.floorInfo && F(a5, t2.fieldsIndex, [t2.floorInfo.floorField]), e2 && null != t2.infoFor3D && (null == t2.globalIdField && P.error("globalIdField missing on 3DObjectFeatureLayer"), F(a5, t2.fieldsIndex, [t2.globalIdField]))), "subtype-group" === t2.type) {
        I(a5, r3, t2.subtypeField);
        const e3 = t2.sublayers.map((e4) => {
          var _a;
          return Promise.all([(_a = e4.renderer) == null ? void 0 : _a.collectRequiredFields(a5, r3), q(a5, e4)]);
        });
        await j(e3);
      }
      for (const i4 of u2)
        i4.error && P.error(i4.error);
      I(a5, r3, s4), e2 && "displayField" in t2 && t2.displayField && I(a5, r3, t2.displayField);
      const p3 = Array.from(a5).sort();
      this._set("requiredFields", p3);
    }
    validateFetchPopupFeatures(e2) {
      if (null == e2)
        return null;
      for (const r3 of e2.clientGraphics ?? []) {
        const i4 = r3.layer;
        if ("popupEnabled" in i4 && !i4.popupEnabled)
          return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i4 });
        if (r3.isAggregate) {
          const e3 = "featureReduction" in i4 ? i4.featureReduction : null;
          if (!(e3 && "popupTemplate" in e3 && e3.popupEnabled && e3.popupTemplate))
            return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i4 });
        } else if ("popupTemplate" in i4) {
          if (!p(i4, e2))
            return new s2("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: i4 });
        }
      }
    }
    async fetchClientPopupFeatures(e2) {
      const t2 = null != e2 ? e2.clientGraphics : null;
      if (!t2 || 0 === t2.length)
        return [];
      const r3 = new Array(t2.length), i4 = /* @__PURE__ */ new Map(), s4 = await this.createPopupQuery(e2);
      for (let o2 = 0; o2 < t2.length; o2++) {
        const n4 = t2[o2];
        if (n4.isAggregate) {
          r3[o2] = n4;
          continue;
        }
        const l3 = n4.layer;
        if (!("popupEnabled" in l3))
          continue;
        const a5 = b3(this.layer.fieldsIndex, s4.outFields), u2 = p(l3, e2);
        if (null == u2)
          continue;
        const p3 = await this._loadArcadeModules(u2);
        p3 && p3.arcadeUtils.hasGeometryOperations(u2) || !Ee(a5, n4) ? i4.set(n4.getObjectId(), { graphic: n4, index: o2 }) : r3[o2] = n4;
      }
      if ("stream" === this.layer.type || 0 === i4.size)
        return r3.filter(Boolean);
      s4.objectIds = Array.from(i4.keys());
      try {
        const e3 = await this.layer.queryFeatures(s4);
        for (const t3 of e3.features) {
          const { graphic: { geometry: e4 }, index: s5 } = i4.get(t3.getObjectId());
          t3.geometry || (t3.geometry = e4), r3[s5] = t3;
        }
      } catch {
      }
      return r3.filter(Boolean);
    }
    async createPopupQuery(e2) {
      const t2 = this.layer.createQuery(), r3 = /* @__PURE__ */ new Set();
      let i4 = false;
      const s4 = null != e2 && e2.clientGraphics ? e2.clientGraphics.map((e3) => e3.layer) : [this.layer];
      for (const o2 of s4) {
        if (!("popupEnabled" in o2))
          continue;
        const t3 = p(o2, e2);
        if (null == t3)
          continue;
        const s5 = await this._loadArcadeModules(t3), n4 = s5 && s5.arcadeUtils.hasGeometryOperations(t3);
        i4 = !("point" !== this.layer.geometryType && !n4);
        const l3 = await n(this.layer, t3);
        for (const e3 of l3)
          r3.add(e3);
      }
      if (t2.returnGeometry = i4, t2.returnZ = i4, t2.returnM = i4, t2.outFields = Array.from(r3), t2.outSpatialReference = this.view.spatialReference, "feature" === this.layer.type) {
        const e3 = o(this);
        null != e3 && (t2.where = t2.where ? `(${t2.where}) AND (${e3})` : e3);
      }
      return t2;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
  };
  return e([y()], _3.prototype, "_updatingRequiredFieldsPromise", void 0), e([y({ readOnly: true })], _3.prototype, "availableFields", null), e([y({ type: w2 })], _3.prototype, "featureEffect", null), e([y({ type: d2 })], _3.prototype, "filter", void 0), e([y(b)], _3.prototype, "timeExtent", void 0), e([y()], _3.prototype, "layer", void 0), e([y({ type: Number })], _3.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true, type: Boolean })], _3.prototype, "maximumNumberOfFeaturesExceeded", null), e([y({ readOnly: true })], _3.prototype, "requiredFields", void 0), e([y()], _3.prototype, "suspended", void 0), e([y()], _3.prototype, "view", void 0), _3 = e([a(q2)], _3), _3;
};

// node_modules/@arcgis/core/views/3d/layers/FeatureLayerViewBase3D.js
var b4 = class extends a3(E(_(n2(d3)))) {
  constructor(e2) {
    super(e2), this._controllerTotal = 0, this._processorTotal = 0, this.suspendResumeExtentMode = "data";
  }
  initialize() {
    this.handles.add(l2(() => this._updatingRequiredFieldsPromise, (e2) => this.updatingHandles.addPromise(e2), w));
  }
  destroy() {
    this.updatingHandles.removeAll(), this.handles.removeAll(), this._fetcherContext = l(this._fetcherContext);
  }
  get maximumNumberOfFeatures() {
    var _a;
    return ((_a = this.controller) == null ? void 0 : _a.maximumNumberOfFeatures) ?? this._get("maximumNumberOfFeatures");
  }
  set maximumNumberOfFeatures(e2) {
    this._set("maximumNumberOfFeatures", e2), this.controller && (this.controller.maximumNumberOfFeatures = e2);
  }
  get maximumNumberOfFeaturesExceeded() {
    return !!this.controller && !(this.suspended || !this.controller.maximumNumberOfFeaturesExceeded);
  }
  get updatingProgressValue() {
    var _a, _b;
    let e2 = 0;
    if ((_a = this.controller) == null ? void 0 : _a.updating) {
      const r3 = this.controller.updatingRemaining, t2 = Math.max(this.controller.updatingTotal, this._controllerTotal);
      t2 > 0 && (e2 = (t2 - r3) / t2, this._controllerTotal = t2);
    }
    let r2 = 0;
    if ((_b = this.processor) == null ? void 0 : _b.updating) {
      const e3 = this.processor.updatingRemaining, t2 = Math.max(e3, this._processorTotal);
      t2 > 0 && (r2 = (t2 - e3) / t2, this._processorTotal = t2);
    }
    return 0.5 * (e2 + r2);
  }
  get updatePolicy() {
    if (!this.controller)
      return C.ASYNC;
    switch (this.controller.mode) {
      case "snapshot": {
        const e2 = M.get(this.layer.geometryType);
        return null == e2 || this.controller.serviceDataCount > e2 ? C.ASYNC : C.SYNC;
      }
      case "tiles":
        return C.ASYNC;
    }
  }
  get hasZ() {
    const e2 = this.layer, r2 = e2.capabilities && e2.capabilities.data;
    return !(!r2 || !r2.supportsZ) && ("returnZ" in e2 && null != e2.returnZ ? e2.returnZ : r2.supportsZ);
  }
  get hasM() {
    const e2 = this.layer, r2 = e2.capabilities && e2.capabilities.data;
    return !(!r2 || !r2.supportsM) && ("returnM" in e2 && null != e2.returnM && e2.returnM);
  }
  setVisibility(e2, r2) {
    var _a;
    (_a = this.processor) == null ? void 0 : _a.setObjectIdVisibility(e2, r2);
  }
  createQuery() {
    return super.createQuery();
  }
  queryFeatures(e2, r2) {
    const t2 = () => super.queryFeatures(e2, r2);
    return "mesh" === this.layer.geometryType ? this._queryFeaturesMesh(this._ensureQuery(e2), t2) : t2();
  }
  beforeSetController(e2) {
    e2.maximumNumberOfFeatures = this.maximumNumberOfFeatures;
  }
  createController() {
    this._fetcherContext = new i3({ layerView: this, returnZ: this.hasZ, returnM: this.hasM });
    const e2 = new I2({ layerView: this, context: this._fetcherContext, graphics: new r(), extent: this.clippingExtent });
    return this.updatingHandles.add(() => e2.serviceDataExtent, (e3) => {
      this.processor && (this.processor.dataExtent = e3);
    }, h), this.handles.add(l2(() => this.suspended, (r2) => {
      r2 ? e2.suspend() : e2.resume();
    }, w)), this.updatingHandles.add(() => {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.displayFeatureLimit;
    }, (r2) => e2.displayFeatureLimit = r2, h), this.handles.add(f2(() => !this.updating, () => {
      this._controllerTotal = 0, this._processorTotal = 0;
    })), e2;
  }
  async doRefresh(e2) {
    e2 && !this.suspended && this.controller && this.controller.refetch(), this.processor.refreshFilter();
  }
  get usedMemory() {
    var _a, _b;
    return (((_a = this.processor) == null ? void 0 : _a.usedMemory) ?? 0) + (((_b = this.controller) == null ? void 0 : _b.memoryForUnusedFeatures) ?? 0);
  }
  get unloadedMemory() {
    var _a, _b, _c, _d;
    const e2 = ((_a = this.processor) == null ? void 0 : _a.unprocessedMemoryEstimate) ?? 0, r2 = ((_b = this.controller) == null ? void 0 : _b.expectedFeatureDiff) ?? 0, t2 = ((_c = this.processor) == null ? void 0 : _c.loadedFeatures) ?? 0, s4 = t2 / (t2 + r2);
    return e2 + r2 * (((_d = this.processor) == null ? void 0 : _d.usedMemoryPerFeature) ?? 0) * s4;
  }
  get ignoresMemoryFactor() {
    var _a;
    return (_a = this.controller) == null ? void 0 : _a.hasMaximumNumberOfFeaturesOverride;
  }
  async _queryFeaturesMesh(e2, r2) {
    await this._validateQueryFeaturesMesh(e2);
    const t2 = await r2();
    if (e2 && e2.outStatistics || null == this.graphics3DProcessor)
      return t2;
    const s4 = this.layer.objectIdField, o2 = this.graphics3DProcessor.graphics3DGraphicsByObjectID, i4 = [];
    for (const a5 of t2.features)
      if (a5.geometry) {
        const e3 = o2.get(a5.attributes[s4]);
        e3 && (a5.geometry = u(e3.graphic.geometry), i4.push(a5));
      } else
        i4.push(a5);
    return t2.features = i4, t2;
  }
  async _validateQueryFeaturesMesh(e2) {
    if (!e2)
      return;
    const t2 = (e3) => {
      throw new s2("feature-layer-view:unsupported-query", `Queries on Mesh feature collection layers do not support '${e3}'`);
    }, s4 = ["quantizationParameters", "geometryPrecision", "maxAllowableOffset"];
    for (const r2 of s4)
      null != e2[r2] && t2(r2);
    "returnM" in e2 && e2.returnM && t2("returnM"), "returnCentroid" in e2 && e2.returnCentroid && t2("returnCentroid"), null == e2.outSpatialReference || e2.outSpatialReference.equals(this.view.spatialReference) || t2("outSpatialReference");
  }
  get performanceInfo() {
    var _a, _b, _c, _d;
    const e2 = (_a = this.controller) == null ? void 0 : _a.displayFeatureLimit, r2 = null != e2 ? e2.averageSymbolComplexity : void 0, t2 = null != r2 ? `f:${r2.primitivesPerFeature},v:${r2.primitivesPerCoordinate}` : "n/a";
    return { ...this._getResourceInfo(), partial: this.maximumNumberOfFeaturesExceeded, mode: ((_b = this.controller) == null ? void 0 : _b.mode) ?? "n/a", symbolComplexity: t2, nodes: ((_c = this.controller) == null ? void 0 : _c.tileDescriptors.length) ?? 0, ...((_d = this.controller) == null ? void 0 : _d.debug) ?? { storedFeatures: 0, totalVertices: 0 } };
  }
  get test() {
    var _a;
    return { updatePolicy: this.updatePolicy, controller: this.controller, loadedGraphics: (_a = this.controller) == null ? void 0 : _a.graphics };
  }
};
e([y()], b4.prototype, "layer", void 0), e([y()], b4.prototype, "controller", void 0), e([y()], b4.prototype, "_controllerTotal", void 0), e([y()], b4.prototype, "_processorTotal", void 0), e([y()], b4.prototype, "maximumNumberOfFeatures", null), e([y()], b4.prototype, "maximumNumberOfFeaturesExceeded", null), e([y(t)], b4.prototype, "updatingProgress", void 0), e([y({ readOnly: true })], b4.prototype, "updatingProgressValue", null), e([y({ readOnly: true })], b4.prototype, "updatePolicy", null), e([y({ readOnly: true })], b4.prototype, "hasZ", null), e([y({ readOnly: true })], b4.prototype, "hasM", null), e([y()], b4.prototype, "suspendResumeExtentMode", void 0), b4 = e([a("esri.views.3d.layers.FeatureLayerViewBase3D")], b4);
var M = /* @__PURE__ */ new Map([["point", 5e3], ["polygon", 500], ["polyline", 1e3]]);
var _2 = b4;

export {
  _2 as _
};
//# sourceMappingURL=chunk-TFBK4UWT.js.map
