import {
  r
} from "./chunk-AKC33IOF.js";
import {
  o
} from "./chunk-6WMPCNUB.js";
import {
  a as a2
} from "./chunk-UVYXRE2S.js";
import {
  n as n2
} from "./chunk-GD75B7SP.js";
import {
  d
} from "./chunk-AGK2CKWJ.js";
import {
  T,
  q
} from "./chunk-7FY52GZ6.js";
import {
  m
} from "./chunk-HM64G5CG.js";
import "./chunk-D4OUCQGI.js";
import "./chunk-HBTZJH6T.js";
import "./chunk-FCNQKNAD.js";
import "./chunk-4GKXMRJI.js";
import "./chunk-HKJ2JMCX.js";
import "./chunk-644IM3NW.js";
import "./chunk-KWPMDFFW.js";
import {
  n
} from "./chunk-G3Q2URFK.js";
import "./chunk-5DK7WWJE.js";
import "./chunk-UI5O37MZ.js";
import "./chunk-XFZB3R5P.js";
import "./chunk-YRKEWWDW.js";
import "./chunk-F4YTVHY4.js";
import "./chunk-FOJITELY.js";
import "./chunk-25GSBURT.js";
import "./chunk-63ERNIOV.js";
import "./chunk-DWF7HN4X.js";
import "./chunk-2ORXZKWN.js";
import "./chunk-KTGLOZE4.js";
import "./chunk-K6DV6EVZ.js";
import "./chunk-MNDNZJD5.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-CUZNACFZ.js";
import "./chunk-ZHUFARKQ.js";
import "./chunk-4RU6WIRN.js";
import "./chunk-HLBPEADQ.js";
import "./chunk-JPAY3V43.js";
import "./chunk-Y2ZDD3I4.js";
import {
  p
} from "./chunk-3FVFBGNT.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-SS3YG6J3.js";
import {
  b
} from "./chunk-HVAOWOGC.js";
import "./chunk-6NPJZOPM.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-2TWR6EVF.js";
import "./chunk-IR32DXLL.js";
import "./chunk-DKCDRJ5N.js";
import "./chunk-KGA7WAD3.js";
import "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-C3PCK5WU.js";
import "./chunk-HE256ZWN.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-W3WHCGIQ.js";
import {
  j
} from "./chunk-HPWZ2OON.js";
import {
  h
} from "./chunk-WAPUHORU.js";
import "./chunk-HXDFHMRK.js";
import "./chunk-5HSVWQOA.js";
import "./chunk-C2BBLDPU.js";
import "./chunk-GWA3PLGA.js";
import "./chunk-FXWSVUF2.js";
import "./chunk-CNS4YGGN.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-CEXY22SC.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7JNPZC53.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-UNJDKTFU.js";
import "./chunk-DH42JQZX.js";
import "./chunk-674HAVOZ.js";
import "./chunk-MHGDFNBE.js";
import "./chunk-J2V5CZSS.js";
import "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import "./chunk-UYRCWUYQ.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/layers/ImageryTileLayerView.js
var p2 = (p3) => {
  let u = class extends p3 {
    constructor() {
      super(...arguments), this._rasterFieldPrefix = "Raster.", this.layer = null, this.view = null, this.tileInfo = null;
    }
    get fullExtent() {
      return this._getfullExtent();
    }
    _getfullExtent() {
      return this.projectFullExtent(this.view.spatialReference);
    }
    get hasTilingEffects() {
      return !!(this.layer.renderer && "dynamicRangeAdjustment" in this.layer.renderer && this.layer.renderer.dynamicRangeAdjustment);
    }
    get datumTransformation() {
      return T(this.layer.fullExtent, this.view.spatialReference, true);
    }
    supportsSpatialReference(e2) {
      return !!this.projectFullExtent(e2);
    }
    projectFullExtent(e2) {
      const t = this.layer.fullExtent, r2 = T(t, e2, false);
      return q(t, e2, r2);
    }
    async fetchPopupFeatures(e2, o2) {
      const { layer: s2 } = this;
      if (!e2)
        throw new s("imageryTileLayerView:fetchPopupFeatures", "Nothing to fetch without area", { layer: s2 });
      const { popupEnabled: i } = s2, a3 = p(s2, o2);
      if (!i || null == a3)
        throw new s("imageryTileLayerView:fetchPopupFeatures", "Missing required popupTemplate or popupEnabled", { popupEnabled: i, popupTemplate: a3 });
      const n3 = [], { value: p4, magdirValue: u2, processedValue: c } = await s2.identify(e2, { timeExtent: this.timeExtent });
      let f = "";
      if (p4 && p4.length) {
        f = "imagery-tile" === s2.type && s2.hasStandardTime() && null != p4[0] ? p4.map((e4) => s2.getStandardTimeValue(e4)).join(", ") : p4.join(", ");
        const e3 = { ObjectId: 0 }, r2 = "Raster.ServicePixelValue";
        e3[r2] = (c == null ? void 0 : c.join(", ")) ?? f, e3[r2 + ".Raw"] = f;
        const o3 = s2.rasterInfo.attributeTable;
        if (null != o3) {
          const { fields: t, features: r3 } = o3, s3 = t.find(({ name: e4 }) => "value" === e4.toLowerCase()), i3 = s3 ? r3.find((e4) => String(e4.attributes[s3.name]) === f) : null;
          if (i3) {
            for (const o4 in i3.attributes)
              if (i3.attributes.hasOwnProperty(o4)) {
                e3[this._rasterFieldPrefix + o4] = i3.attributes[o4];
              }
          }
        }
        const i2 = s2.rasterInfo.dataType;
        "vector-magdir" !== i2 && "vector-uv" !== i2 || (e3["Raster.Magnitude"] = u2 == null ? void 0 : u2[0], e3["Raster.Direction"] = u2 == null ? void 0 : u2[1]);
        const a4 = new h(this.fullExtent.clone(), null, e3);
        a4.layer = s2, a4.sourceLayer = a4.layer, n3.push(a4);
      }
      return n3;
    }
  };
  return e([y()], u.prototype, "layer", void 0), e([y(b)], u.prototype, "timeExtent", void 0), e([y()], u.prototype, "view", void 0), e([y()], u.prototype, "fullExtent", null), e([y()], u.prototype, "tileInfo", void 0), e([y({ readOnly: true })], u.prototype, "hasTilingEffects", null), e([y()], u.prototype, "datumTransformation", null), u = e([a("esri.views.layers.ImageryTileLayerView")], u), u;
};

// node_modules/@arcgis/core/views/3d/layers/ImageryTileLayerView3D.js
var y2 = class extends p2(a2(o(n2(d)))) {
  constructor() {
    super(...arguments), this.type = "imagery-tile-3d", this.isAlignedMapTile = true;
  }
  initialize() {
    this.layer.increaseRasterJobHandlerUsage(), null == this.fullExtent && this.addResolvingPromise(Promise.reject(new s("layerview:spatial-reference-incompatible", "The layer extent cannot be projected to the view's spatial reference", { layer: this.layer })));
    const e2 = j(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
    }).then(() => {
      const e3 = this.view.basemapTerrain.tilingScheme, t = this.layer.tileInfo, r2 = ["png", "png24", "png32", "jpg", "mixed"].includes(t.format) && e3.compatibleWith(t);
      this.isAlignedMapTile = r2;
      const i = r2 ? t : e3.toTileInfo();
      this.tileInfo = i, this.updatingHandles.add(() => [this.layer.renderer, this.layer.interpolation, this.layer.bandIds, this.layer.multidimensionalDefinition, this.layer.multidimensionalSubset, this.layer.rasterFunction, this.timeExtent], () => this.refresh());
    });
    this.addResolvingPromise(e2);
  }
  destroy() {
    this.layer.decreaseRasterJobHandlerUsage(), this.view = null;
  }
  get _blankTile() {
    const e2 = document.createElement("canvas"), t = e2.getContext("2d"), [r2, i] = this.tileInfo.size;
    return e2.width = r2, e2.height = i, t.clearRect(0, 0, r2, i), t.getImageData(0, 0, r2, i);
  }
  get imageFormatIsOpaque() {
    return "jpg" === this.layer.tileInfo.format;
  }
  get hasMixedImageFormats() {
    return "mixed" === this.layer.tileInfo.format;
  }
  get dataLevelRange() {
    const e2 = this.tileInfo.lods, t = this.layer.tileInfo.lods, r2 = e2[0].scale, i = t[t.length - 1].scale;
    return this.levelRangeFromScaleRange(r2, i);
  }
  _getfullExtent() {
    return this.projectFullExtent(this.view.basemapTerrain && null != this.view.basemapTerrain.spatialReference ? this.view.basemapTerrain.spatialReference : this.view.spatialReference);
  }
  async fetchTile(e2, t, r2, i) {
    const s2 = this.tileInfo, a3 = this._canSymbolizeInWebGL(), l = { tileInfo: s2, requestRawData: a3, signal: i.signal, timeExtent: this.timeExtent, requestAsImageElement: this.isAlignedMapTile }, o2 = await this.layer.fetchTile(e2, t, r2, l);
    if (o2 instanceof HTMLImageElement)
      return o2;
    let m2 = o2 && o2.pixelBlock;
    if (null == m2)
      return this._blankTile;
    if (!a3 && (m2 = await this.layer.applyRenderer(o2), null == m2))
      return this._blankTile;
    const p3 = new m([e2, t, r2], m2, s2.size[0], s2.size[1]);
    return a3 ? (p3.symbolizerRenderer = this.layer.symbolizer.rendererJSON, p3.symbolizerParameters = this.layer.symbolizer.generateWebGLParameters(this._getSymbolizerOptions(e2)), p3.transformGrid = o2.transformGrid) : p3.isRendereredSource = true, p3.interpolation = this.layer.interpolation, p3.bandIds = this.layer.bandIds, p3;
  }
  _getSymbolizerOptions(e2) {
    const t = this.tileInfo.lodAt(e2).resolution;
    return { pixelBlock: null, isGCS: this.view.basemapTerrain && null != this.view.basemapTerrain.spatialReference ? this.view.basemapTerrain.spatialReference.isGeographic : this.view.spatialReference.isGeographic, resolution: { x: t, y: t }, bandIds: this.layer.bandIds };
  }
  ensureSymbolizerParameters(e2) {
    this._canSymbolizeInWebGL() && JSON.stringify(e2.symbolizerRenderer) !== JSON.stringify(this.layer.symbolizer.rendererJSON) && (e2.symbolizerParameters = this.layer.symbolizer.generateWebGLParameters(this._getSymbolizerOptions(e2.lij[0])));
  }
  createFetchPopupFeaturesQueryGeometry(e2, t) {
    return r(e2, t, this.view);
  }
  refresh() {
    this.emit("data-changed");
  }
  async doRefresh() {
    this.suspended || this.emit("data-changed");
  }
  _canSymbolizeInWebGL() {
    return n("3d").supportsTextureFloat && this.layer.symbolizer.canRenderInWebGL;
  }
};
e([y({ readOnly: true })], y2.prototype, "_blankTile", null), e([y({ readOnly: true })], y2.prototype, "imageFormatIsOpaque", null), e([y({ readOnly: true })], y2.prototype, "hasMixedImageFormats", null), e([y({ readOnly: true })], y2.prototype, "dataLevelRange", null), y2 = e([a("esri.views.3d.layers.ImageryTileLayerView3D")], y2);
var d2 = y2;
export {
  d2 as default
};
//# sourceMappingURL=ImageryTileLayerView3D-ERMFAD5Y.js.map
