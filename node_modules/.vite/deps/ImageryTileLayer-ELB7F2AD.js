import {
  D as D2,
  E,
  L as L4,
  N as N2,
  Q as Q2,
  a as a4,
  a2 as a5,
  c as c4,
  c2 as c5,
  d as d3,
  d2 as d4,
  f as f6,
  g as g2,
  h as h3,
  h2 as h4,
  i2,
  k as k2,
  l as l5,
  m2 as m4,
  o as o4,
  p as p4,
  q as q2,
  t as t2
} from "./chunk-CTIWLBC7.js";
import {
  T as T3
} from "./chunk-VDT2UHLV.js";
import {
  _,
  f as f5,
  h as h2,
  i,
  n as n3,
  y as y4
} from "./chunk-J2NHIS7S.js";
import {
  $,
  C,
  J,
  K,
  Q,
  V,
  _ as _2,
  ie,
  k,
  ne,
  q
} from "./chunk-7FY52GZ6.js";
import {
  B,
  D,
  I,
  L as L2,
  L2 as L3,
  N,
  P,
  R as R2,
  R2 as R3,
  T as T2,
  U,
  U2,
  W,
  f2 as f4,
  g2 as g,
  h2 as h,
  j as j5,
  l2 as l3,
  m as m2,
  m2 as m3,
  n,
  n3 as n2,
  r as r2,
  r2 as r3,
  s5 as s3,
  u as u2,
  u2 as u3,
  u4,
  v as v2
} from "./chunk-F5EKF66B.js";
import "./chunk-2735WBYK.js";
import "./chunk-PVUG2RDQ.js";
import "./chunk-J3HE7QNA.js";
import "./chunk-YZ24SAPZ.js";
import "./chunk-KKDPZLGI.js";
import "./chunk-XTOI3E3Y.js";
import "./chunk-RSPVLZNN.js";
import {
  j as j4,
  p as p2
} from "./chunk-JPAY3V43.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-WWUAHPIM.js";
import {
  l as l4
} from "./chunk-FN34IFMV.js";
import {
  o as o3
} from "./chunk-252JHW3U.js";
import {
  a as a3
} from "./chunk-KPA3L4VZ.js";
import {
  p as p3
} from "./chunk-OK4LIPGX.js";
import "./chunk-WXSXHXM4.js";
import {
  d as d2
} from "./chunk-PYQNXC2L.js";
import "./chunk-NHHKW3WR.js";
import "./chunk-V4EIGIRT.js";
import "./chunk-VYG5A4VI.js";
import {
  j as j3
} from "./chunk-QO446QEK.js";
import "./chunk-4FZRA4VI.js";
import {
  c as c3
} from "./chunk-G32FVJ4L.js";
import {
  O
} from "./chunk-XJXVKVA7.js";
import {
  c as c2,
  f as f3
} from "./chunk-HVAOWOGC.js";
import "./chunk-MNR4BIGQ.js";
import "./chunk-IHCIS6PT.js";
import "./chunk-OHH3UAUS.js";
import "./chunk-EIQYIBNS.js";
import "./chunk-2NTQWEQZ.js";
import "./chunk-E2PV5YTZ.js";
import "./chunk-GLVTFP5O.js";
import "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import {
  y as y3
} from "./chunk-2TWR6EVF.js";
import {
  p
} from "./chunk-MIHY6FSC.js";
import "./chunk-IR32DXLL.js";
import "./chunk-7BMUKKBX.js";
import {
  y as y2
} from "./chunk-WIQR3T32.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-DKJBDKGA.js";
import "./chunk-4CZO65BK.js";
import "./chunk-DR3XNW4L.js";
import "./chunk-DKCDRJ5N.js";
import "./chunk-PCTUO7WS.js";
import {
  a as a2
} from "./chunk-BS4MX2AF.js";
import {
  t
} from "./chunk-R47DHBCM.js";
import "./chunk-KGA7WAD3.js";
import "./chunk-ZUBHLDU6.js";
import "./chunk-C3PCK5WU.js";
import "./chunk-HE256ZWN.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import {
  b
} from "./chunk-PZXYASUU.js";
import "./chunk-3ESTI2X4.js";
import "./chunk-YK2WEG7V.js";
import "./chunk-POEWD5LS.js";
import "./chunk-HTVQN75V.js";
import "./chunk-W3WHCGIQ.js";
import {
  l as l2
} from "./chunk-HPWZ2OON.js";
import "./chunk-WAPUHORU.js";
import {
  k as k3
} from "./chunk-HXDFHMRK.js";
import "./chunk-5HSVWQOA.js";
import "./chunk-C2BBLDPU.js";
import "./chunk-GWA3PLGA.js";
import "./chunk-FXWSVUF2.js";
import "./chunk-CNS4YGGN.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-CEXY22SC.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7JNPZC53.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import {
  o as o2
} from "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-UNJDKTFU.js";
import "./chunk-DH42JQZX.js";
import "./chunk-674HAVOZ.js";
import "./chunk-MHGDFNBE.js";
import "./chunk-J2V5CZSS.js";
import {
  m
} from "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import {
  j as j2
} from "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import {
  L
} from "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import {
  M
} from "./chunk-T35GN7EL.js";
import {
  f as f2,
  x2 as x
} from "./chunk-7U6V6KY2.js";
import {
  H,
  d,
  o
} from "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import {
  l
} from "./chunk-CHTUPHTO.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  T,
  v
} from "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  c2 as c,
  f2 as f,
  j,
  r,
  u,
  w
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R,
  has
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/EphemeralBlockCache.js
var t3 = class {
  constructor(t6 = 15e3, e3 = 5e3) {
    this._timer = null, this._cachedBlocks = /* @__PURE__ */ new Map(), this._size = -1, this._duration = t6, this._interval = Math.min(t6, e3);
  }
  decreaseRefCount(t6, e3) {
    const s5 = t6 + "/" + e3, r7 = this._cachedBlocks;
    if (r7.has(s5)) {
      const t7 = r7.get(s5);
      return t7.refCount--, t7.refCount <= 0 && (r7.delete(s5), t7.controller && t7.controller.abort()), t7.refCount;
    }
    return 0;
  }
  getBlock(t6, e3) {
    const s5 = t6 + "/" + e3, r7 = this._cachedBlocks;
    if (r7.has(s5)) {
      const t7 = r7.get(s5);
      return t7.ts = Date.now(), t7.refCount++, r7.delete(s5), r7.set(s5, t7), t7.block;
    }
    return null;
  }
  putBlock(t6, e3, s5, r7) {
    const i5 = this._cachedBlocks, c11 = t6 + "/" + e3;
    if (i5.has(c11)) {
      const t7 = i5.get(c11);
      t7.ts = Date.now(), t7.refCount++;
    } else
      i5.set(c11, { block: s5, ts: Date.now(), refCount: 1, controller: r7 });
    this._trim(), this._updateTimer();
  }
  deleteBlock(t6, e3) {
    const s5 = this._cachedBlocks, r7 = t6 + "/" + e3;
    s5.has(r7) && s5.delete(r7);
  }
  updateMaxSize(t6) {
    this._size = t6, this._trim();
  }
  empty() {
    this._cachedBlocks.clear(), this._clearTimer();
  }
  getCurrentSize() {
    return this._cachedBlocks.size;
  }
  _updateTimer() {
    if (null != this._timer)
      return;
    const t6 = this._cachedBlocks;
    this._timer = setInterval(() => {
      const e3 = Array.from(t6), s5 = Date.now();
      for (let r7 = 0; r7 < e3.length && e3[r7][1].ts <= s5 - this._duration; r7++)
        t6.delete(e3[r7][0]);
      0 === t6.size && this._clearTimer();
    }, this._interval);
  }
  _trim() {
    const t6 = this._cachedBlocks;
    if (-1 === this._size || this._size >= t6.size)
      return;
    const e3 = Array.from(t6);
    for (let s5 = 0; s5 < e3.length - this._size; s5++)
      t6.delete(e3[s5][0]);
  }
  _clearTimer() {
    null != this._timer && (clearInterval(this._timer), this._timer = null);
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/RawBlockCache.js
var r4 = /* @__PURE__ */ new Map();
var c6 = new t3();
function i3(e3, t6) {
  return null == t6 ? e3 : `${e3}?sliceId=${t6}`;
}
function s4(e3, t6, n8) {
  var _a, _b;
  const o7 = r4.get(e3);
  if (!o7)
    return null == t6 ? c6.decreaseRefCount(e3, n8) : 0;
  if (null == t6 || null == o7[t6])
    return c6.decreaseRefCount(e3, n8);
  const l7 = (_a = o7[t6]) == null ? void 0 : _a.cache, i5 = l7 == null ? void 0 : l7.get(n8);
  if (l7 && i5) {
    if (i5.refCount--, 0 === i5.refCount) {
      l7.delete(n8);
      for (let e4 = 0; e4 < o7.length; e4++)
        (_b = o7[e4]) == null ? void 0 : _b.cache.delete(n8);
      i5.controller && i5.controller.abort();
    }
    return i5.refCount;
  }
  return 0;
}
function m5(e3, t6, n8) {
  var _a, _b, _c;
  const o7 = r4.get(e3);
  if (!o7)
    return null == t6 ? c6.getBlock(e3, n8) : null;
  if (null == t6 || null == o7[t6]) {
    for (let e4 = 0; e4 < o7.length; e4++) {
      const t7 = (_a = o7[e4]) == null ? void 0 : _a.cache.get(n8);
      if (t7)
        return t7.refCount++, t7.block;
    }
    return c6.getBlock(e3, n8);
  }
  const l7 = (_b = o7[t6]) == null ? void 0 : _b.cache.get(n8);
  if (l7)
    return l7.refCount++, l7.block;
  for (let r7 = 0; r7 < o7.length; r7++) {
    if (r7 === t6 || !o7[r7])
      continue;
    const e4 = (_c = o7[r7]) == null ? void 0 : _c.cache, l8 = e4 == null ? void 0 : e4.get(n8);
    if (e4 && l8)
      return l8.refCount++, e4.set(n8, l8), l8.block;
  }
  return null;
}
function x2(e3, t6, n8, o7, l7 = null) {
  var _a;
  const i5 = r4.get(e3);
  if (!i5)
    return void (null == t6 && c6.putBlock(e3, n8, o7, l7));
  if (null == t6 || null == i5[t6])
    return void c6.putBlock(e3, n8, o7, l7);
  const u7 = { refCount: 1, block: o7, isResolved: false, isRejected: false, controller: l7 };
  o7.then(() => u7.isResolved = true).catch(() => u7.isRejected = true), (_a = i5[t6]) == null ? void 0 : _a.cache.set(n8, u7);
}
function h5(e3, t6, n8) {
  var _a;
  const o7 = r4.get(e3);
  o7 ? null != t6 && null != o7[t6] ? (_a = o7[t6]) == null ? void 0 : _a.cache.delete(n8) : c6.deleteBlock(e3, n8) : null == t6 && c6.deleteBlock(e3, n8);
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var N3 = 8;
var V2 = 256;
var U3 = class extends m(l) {
  constructor() {
    super(...arguments), this.datasetName = null, this.datasetFormat = null, this.hasUniqueSourceStorageInfo = true, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  async init() {
    const e3 = k();
    this.addResolvingPromise(e3), await this.when();
  }
  normalizeCtorArgs(e3) {
    return e3 && e3.ioConfig && (e3 = { ...e3, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: j4.create(), ...e3.ioConfig } }), e3;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: e3 } = this, t6 = K(e3.spatialReference);
    return null != t6 && e3.extent.width >= t6 / 2;
  }
  get _hasNoneOrGCSShiftTransform() {
    const { transform: e3 } = this.rasterInfo;
    return null == e3 || "gcs-shift" === e3.type;
  }
  set rasterJobHandler(e3) {
    var _a, _b;
    this._set("rasterJobHandler", e3), "Function" === this.datasetFormat && ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.forEach((t6) => t6.rasterJobHandler = e3));
  }
  set url(e3) {
    this._set("url", y3(e3, s.getLogger(this)));
  }
  async open(e3) {
    throw new s2("BaseRaster:open-not-implemented", "open() is not implemented");
  }
  async fetchTile(e3, t6, i5, o7 = {}) {
    const r7 = o7.tileInfo || this.rasterInfo.storageInfo.tileInfo, n8 = this.getTileExtentFromTileInfo(e3, t6, i5, r7);
    return this.fetchPixels(n8, r7.size[0], r7.size[1], o7);
  }
  async identify(e3, t6 = {}) {
    var _a;
    e3 = v(x, e3).clone().normalize();
    const { multidimensionalDefinition: i5, timeExtent: o7 } = t6, { rasterInfo: r7 } = this, { hasMultidimensionalTranspose: n8, multidimensionalInfo: s5 } = r7;
    let { transposedVariableName: l7 } = t6;
    const a7 = null != s5 && n8 && (null != o7 || h3(i5));
    if (a7 && !l7) {
      l7 = null != i5 && i5.length > 0 ? i5[0].variableName ?? void 0 : s5.variables[0].name, t6 = { ...t6, transposedVariableName: l7 };
    }
    t6 = this._getRequestOptionsWithSliceId(t6);
    const { spatialReference: m7, extent: f8 } = r7, { datumTransformation: u7 } = t6;
    let h9 = _2(e3, m7, u7);
    if (!f8.intersects(h9))
      return { location: h9, value: null };
    if (null != r7.transform) {
      const e4 = r7.transform.inverseTransform(h9);
      if (!r7.nativeExtent.intersects(e4))
        return { location: e4, value: null };
      h9 = e4;
    }
    let p6 = 0;
    const d7 = null != l7 && null != s5 && r7.hasMultidimensionalTranspose;
    if ("Function" === this.datasetFormat) {
      const e4 = this.primaryRasters.rasters[0];
      if (d7)
        return e4.identify(h9, t6);
      const { pixelSize: i6 } = r7, o8 = 3, n9 = i6.x * o8 / 2, s6 = i6.y * o8 / 2, l8 = new M({ xmin: h9.x - n9, xmax: h9.x + n9, ymin: h9.y - s6, ymax: h9.y + s6, spatialReference: m7 }), a8 = { interpolation: "nearest" }, { pixelBlock: c11 } = await e4.fetchPixels(l8, o8, o8, a8), { pixelBlock: f9 } = await this.fetchPixels(l8, o8, o8, a8);
      if (null == c11)
        return { location: h9, value: null };
      const u8 = Math.floor(o8 * o8 * 0.5), p7 = !c11.mask || c11.mask[u8] ? c11.pixels.map((e5) => e5[u8]) : null;
      let x8;
      return null != f9 && (x8 = !f9.mask || f9.mask[u8] ? f9.pixels.map((e5) => e5[u8]) : void 0), { location: h9, value: p7, processedValue: x8, pyramidLevel: 0 };
    }
    if (!d7) {
      if (t6.srcResolution) {
        p6 = ie(t6.srcResolution, r7, this.ioConfig.sampling).pyramidLevel;
      } else if (p6 = await this.computeBestPyramidLevelForLocation(e3, t6), null == p6)
        return { location: h9, value: null };
    }
    const x7 = this.identifyPixelLocation(h9, p6, null, d7);
    if (null === x7)
      return { location: h9, value: null };
    const { row: g5, col: I3, rowOffset: R4, colOffset: T4, blockWidth: b2 } = x7, v5 = l7 ?? t6.sliceId, P2 = i3(this.url, v5), B3 = `${p6}/${g5}/${I3}`;
    let M2 = m5(P2, null, B3);
    null == M2 && (M2 = this.fetchRawTile(p6, g5, I3, t6), x2(P2, null, B3, M2));
    const _4 = await M2;
    if (null == _4 || !((_a = _4.pixels) == null ? void 0 : _a.length))
      return { location: h9, value: null };
    const W2 = R4 * b2 + T4;
    return this._processIdentifyResult(_4, { srcLocation: h9, position: W2, pyramidLevel: p6, useTransposedTile: !!d7, requestSomeSlices: a7, identifyOptions: t6 });
  }
  async fetchPixels(e3, t6, i5, o7 = {}) {
    e3 = ne(e3), o7 = this._getRequestOptionsWithSliceId(o7);
    const { _hasNoneOrGCSShiftTransform: r7 } = this;
    if (o7.requestRawData && r7)
      return this._fetchPixels(e3, t6, i5, o7);
    const n8 = K(e3.spatialReference), s5 = Q(e3);
    if (null == n8 || 0 === s5 || 1 === s5 && this._isGlobalWrappableSource && r7)
      return this._fetchPixels(e3, t6, i5, o7);
    if (s5 >= 3)
      return { extent: e3, pixelBlock: null };
    const l7 = [], { xmin: a7, xmax: c11 } = e3, m7 = Math.round(n8 / (c11 - a7) * t6), f8 = m7 - Math.round((n8 / 2 - a7) / (c11 - a7) * t6);
    let u7 = 0;
    const h9 = [];
    for (let y7 = 0; y7 <= s5; y7++) {
      const r8 = new M({ xmin: 0 === y7 ? a7 : -n8 / 2, xmax: y7 === s5 ? c11 - n8 * y7 : n8 / 2, ymin: e3.ymin, ymax: e3.ymax, spatialReference: e3.spatialReference }), p7 = 0 === y7 ? m7 - f8 : y7 === s5 ? t6 - u7 : m7;
      u7 += p7, h9.push(p7);
      const d8 = o7.disableWrapAround && y7 > 0 ? null : this._fetchPixels(r8, p7, i5, o7);
      l7.push(d8);
    }
    const p6 = (await Promise.all(l7)).map((e4) => e4 == null ? void 0 : e4.pixelBlock);
    let d7 = null;
    const x7 = { width: t6, height: i5 };
    if (this.rasterJobHandler) {
      d7 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: p6, srcMosaicSize: x7, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: h9 }, o7)).pixelBlock;
    } else
      d7 = U2(p6, x7, { blockWidths: h9 });
    return { extent: e3, srcExtent: q(e3, this.rasterInfo.spatialReference, o7.datumTransformation), pixelBlock: d7 };
  }
  async fetchRawPixels(e3, t6, i5, o7 = {}) {
    t6 = { x: Math.floor(t6.x), y: Math.floor(t6.y) };
    const r7 = await this._fetchRawTiles(e3, t6, i5, o7), { nativeExtent: n8, nativePixelSize: s5, storageInfo: l7 } = this.rasterInfo, a7 = 2 ** e3, c11 = s5.x * a7, m7 = s5.y * a7, f8 = new M({ xmin: n8.xmin + c11 * t6.x, xmax: n8.xmin + c11 * (t6.x + i5.width - 1), ymin: n8.ymax - m7 * (t6.y + i5.height - 1), ymax: n8.ymax - m7 * t6.y, spatialReference: n8.spatialReference });
    if (!r7)
      return { extent: f8, srcExtent: f8, pixelBlock: null };
    const { pixelBlocks: u7, mosaicSize: h9 } = r7;
    if (1 === u7.length && null != u7[0] && u7[0].width === i5.width && u7[0].height === i5.height)
      return { extent: f8, srcExtent: f8, pixelBlock: r7.pixelBlocks[0] };
    const p6 = e3 > 0 ? l7.pyramidBlockWidth : l7.blockWidth, d7 = e3 > 0 ? l7.pyramidBlockHeight : l7.blockHeight, x7 = { x: t6.x % p6, y: t6.y % d7 };
    let y7;
    if (this.rasterJobHandler) {
      y7 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: u7, srcMosaicSize: h9, destDimension: i5, clipOffset: x7, clipSize: i5, coefs: null, sampleSpacing: null, interpolation: o7.interpolation, alignmentInfo: null, blockWidths: null }, o7)).pixelBlock;
    } else
      y7 = U2(u7, h9, { clipOffset: x7, clipSize: i5 });
    return { extent: f8, srcExtent: f8, pixelBlock: y7 };
  }
  fetchRawTile(e3, t6, o7, r7) {
    throw new s2("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(e3) {
    return q(this.rasterInfo.extent, e3);
  }
  decodePixelBlock(e3, t6) {
    return !this.rasterJobHandler || t6.useCanvas ? j5(e3, t6) : this.rasterJobHandler.decode({ data: e3, options: t6 });
  }
  async request(e3, i5, o7 = 0) {
    const { customFetchParameters: r7 } = this.ioConfig, { range: n8, query: s5, headers: l7 } = i5;
    o7 = o7 ?? i5.retryCount ?? this.ioConfig.retryCount;
    const a7 = n8 ? { Range: `bytes=${n8.from}-${n8.to}` } : null;
    try {
      return await j2(e3, { ...i5, query: { ...s5, ...r7 }, headers: { ...l7, ...a7 } });
    } catch (c11) {
      if (o7 > 0)
        return o7--, this.request(e3, i5, o7);
      throw c11;
    }
  }
  getSliceIndex(e3) {
    const { multidimensionalInfo: t6 } = this.rasterInfo;
    return null == t6 || null == e3 || 0 === e3.length ? null : D2(e3, t6);
  }
  getTileExtentFromTileInfo(e3, t6, i5, o7) {
    const r7 = u(o7.lodAt(e3));
    return this.getTileExtent({ x: r7.resolution, y: r7.resolution }, t6, i5, o7.origin, o7.spatialReference, o7.size);
  }
  updateTileInfo() {
    const { storageInfo: e3, spatialReference: t6, extent: i5, pixelSize: o7 } = this.rasterInfo;
    if (!e3.tileInfo) {
      const r7 = [], n8 = e3.maximumPyramidLevel || 0;
      let s5 = Math.max(o7.x, o7.y), l7 = 1 / 0.0254 * 96 * s5;
      for (let e4 = 0; e4 <= n8; e4++)
        r7.push(new p2({ level: n8 - e4, resolution: s5, scale: l7 })), s5 *= 2, l7 *= 2;
      const a7 = new x({ x: i5.xmin, y: i5.ymax, spatialReference: t6 });
      e3.tileInfo = new j4({ origin: a7, size: [e3.blockWidth, e3.blockHeight], spatialReference: t6, lods: r7 }), e3.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(e3, t6 = 512, i5 = 512, o7) {
    const { width: r7, height: n8, nativeExtent: s5, pixelSize: l7, spatialReference: a7 } = e3, c11 = new x({ x: s5.xmin, y: s5.ymax, spatialReference: a7 });
    null == o7 && (o7 = Math.max(0, Math.round(Math.log(Math.max(r7, n8)) / Math.LN2 - 8)));
    const m7 = this.computeBlockBoundary(s5, 512, 512, { x: s5.xmin, y: s5.ymax }, [l7], o7);
    e3.storageInfo = new n2({ blockWidth: t6, blockHeight: i5, pyramidBlockWidth: t6, pyramidBlockHeight: i5, origin: c11, firstPyramidLevel: 1, maximumPyramidLevel: o7, blockBoundary: m7 });
  }
  async computeBestPyramidLevelForLocation(e3, t6 = {}) {
    return 0;
  }
  computeBlockBoundary(e3, t6, i5, o7, r7, n8 = 0, s5 = 2) {
    if (1 === r7.length && n8 > 0) {
      r7 = [...r7];
      let { x: e4, y: t7 } = r7[0];
      for (let i6 = 0; i6 < n8; i6++)
        e4 *= s5, t7 *= s5, r7.push({ x: e4, y: t7 });
    }
    const l7 = [], { x: a7, y: c11 } = o7;
    for (let m7 = 0; m7 < r7.length; m7++) {
      const { x: o8, y: n9 } = r7[m7];
      l7.push({ minCol: Math.floor((e3.xmin - a7 + 0.1 * o8) / t6 / o8), maxCol: Math.floor((e3.xmax - a7 - 0.1 * o8) / t6 / o8), minRow: Math.floor((c11 - e3.ymax + 0.1 * n9) / i5 / n9), maxRow: Math.floor((c11 - e3.ymin - 0.1 * n9) / i5 / n9) });
    }
    return l7;
  }
  getPyramidPixelSize(e3) {
    const { nativePixelSize: t6 } = this.rasterInfo, { pyramidResolutions: i5, pyramidScalingFactor: o7 } = this.rasterInfo.storageInfo;
    if (0 === e3)
      return t6;
    if (null != i5 && i5.length)
      return i5[e3 - 1];
    const r7 = o7 ** e3;
    return { x: t6.x * r7, y: t6.y * r7 };
  }
  identifyPixelLocation(e3, t6, i5, o7) {
    const { spatialReference: r7, nativeExtent: n8, storageInfo: s5 } = this.rasterInfo, { maximumPyramidLevel: l7, origin: a7, transposeInfo: c11 } = s5, m7 = o7 && null != c11 ? c11.tileSize[0] : s5.blockWidth, f8 = o7 && null != c11 ? c11.tileSize[1] : s5.blockHeight, u7 = _2(e3, r7, i5);
    if (!n8.intersects(u7))
      return null;
    if (t6 < 0 || t6 > l7)
      return null;
    const h9 = this.getPyramidPixelSize(t6), { x: p6, y: d7 } = h9, x7 = (a7.y - u7.y) / d7 / f8, y7 = (u7.x - a7.x) / p6 / m7, g5 = Math.min(f8 - 1, Math.floor((x7 - Math.floor(x7)) * f8)), I3 = Math.min(m7 - 1, Math.floor((y7 - Math.floor(y7)) * m7));
    return { pyramidLevel: t6, row: Math.floor(x7), col: Math.floor(y7), rowOffset: g5, colOffset: I3, blockWidth: m7, srcLocation: u7 };
  }
  getTileExtent(e3, t6, i5, o7, r7, n8) {
    const [s5, l7] = n8, a7 = o7.x + i5 * s5 * e3.x, c11 = a7 + s5 * e3.x, m7 = o7.y - t6 * l7 * e3.y, f8 = m7 - l7 * e3.y;
    return new M({ xmin: a7, xmax: c11, ymin: f8, ymax: m7, spatialReference: r7 });
  }
  getBlockWidthHeight(e3) {
    return { blockWidth: e3 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: e3 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(e3, t6, i5) {
    const o7 = this.rasterInfo.storageInfo.blockBoundary[e3];
    return !o7 || o7.maxRow < t6 || o7.maxCol < i5 || o7.minRow > t6 || o7.minCol > i5;
  }
  async _fetchPixels(e3, t6, i5, o7 = {}) {
    let r7 = Q(e3);
    if (r7 >= 2)
      return { extent: e3, pixelBlock: null };
    const n8 = this._getSourceDataInfo(e3, t6, i5, o7), { pyramidLevel: s5, srcResolution: l7, srcExtent: a7, srcWidth: c11, srcHeight: m7, ul: f8 } = n8;
    if (0 === c11 || 0 === m7)
      return { extent: e3, srcExtent: a7, pixelBlock: null };
    const { rasterInfo: u7 } = this, h9 = u7.transform, p6 = "gcs-shift" === (h9 == null ? void 0 : h9.type), d7 = null != K(e3.spatialReference);
    !p6 && d7 || (r7 = Q(n8.srcExtent, p6));
    const x7 = await this._fetchRawTiles(s5, f8, { width: c11, height: m7, wrapCount: r7 }, o7);
    if (!x7)
      return { extent: e3, srcExtent: a7, pixelBlock: null };
    const y7 = u7.storageInfo, g5 = s5 > 0 ? y7.pyramidBlockWidth : y7.blockWidth, I3 = s5 > 0 ? y7.pyramidBlockHeight : y7.blockHeight;
    let { x: R4, y: w3 } = u7.pixelSize;
    if (s5 > 0) {
      const { pyramidResolutions: e4, pyramidScalingFactor: t7 } = y7;
      if (null != e4 && e4[s5 - 1])
        ({ x: R4, y: w3 } = e4[s5 - 1]);
      else {
        const e5 = t7 ** s5;
        R4 *= e5, w3 *= e5;
      }
    }
    const S3 = u7.spatialReference, k4 = new x({ x: R4, y: w3, spatialReference: S3 }), T4 = g5 === c11 && I3 === m7 && f8.x % g5 == 0 && f8.y % I3 == 0, b2 = new x({ x: (e3.xmax - e3.xmin) / t6, y: (e3.ymax - e3.ymin) / i5, spatialReference: e3.spatialReference }), v5 = !e3.spatialReference.equals(S3), P2 = S3.isGeographic ? 1e-9 : 1e-4, { datumTransformation: j6 } = o7;
    if (!v5 && T4 && 1 === x7.pixelBlocks.length && g5 === t6 && I3 === i5 && this._isSameResolution(l7, b2, P2))
      return { extent: e3, srcExtent: a7, srcTilePixelSize: k4, pixelBlock: x7.pixelBlocks[0] };
    const H2 = d7 && null != K(a7.spatialReference) && this._hasNoneOrGCSShiftTransform, z = o7.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    z && !this.rasterJobHandler && await k();
    const E3 = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: e3, srcBufferExtent: x7.extent, pixelSize: b2.toJSON(), datumTransformation: j6, rasterTransform: h9, hasWrapAround: r7 > 0 || H2, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: z }, o7) : $({ projectedExtent: e3, srcBufferExtent: x7.extent, pixelSize: b2, datumTransformation: j6, rasterTransform: h9, hasWrapAround: r7 > 0 || H2, isAdaptive: false, includeGCSGrid: z });
    let F2;
    const O2 = !o7.requestRawData, G = { rows: E3.spacing[0], cols: E3.spacing[1] }, q3 = this._hasNoneOrGCSShiftTransform ? this._getRasterTileAlignmentInfo(s5, x7.extent.xmin) : void 0, { pixelBlocks: N4, mosaicSize: V4, isPartiallyFilled: U4 } = x7;
    let $3 = null;
    if (this.rasterJobHandler) {
      const e4 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: N4, srcMosaicSize: V4, destDimension: O2 ? { width: t6, height: i5 } : null, coefs: O2 ? E3.coefficients : null, sampleSpacing: O2 ? G : null, projectDirections: z, gcsGrid: z ? E3.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: o7.interpolation, alignmentInfo: q3, blockWidths: null }, o7);
      ({ pixelBlock: F2, localNorthDirections: $3 } = e4);
    } else {
      const e4 = U2(N4, V4, { alignmentInfo: q3 });
      F2 = O2 ? R3(e4, { width: t6, height: i5 }, E3.coefficients, G, o7.interpolation) : e4, z && E3.gcsGrid && ($3 = I({ width: t6, height: i5 }, E3.gcsGrid), F2 = u4(F2, this.rasterInfo.dataType, $3));
    }
    return o7.requestRawData || z ? { extent: e3, srcExtent: a7, srcTilePixelSize: k4, pixelBlock: F2, transformGrid: E3, localNorthDirections: $3, isPartiallyFilled: U4 } : { extent: e3, srcExtent: a7, srcTilePixelSize: k4, pixelBlock: F2 };
  }
  async _fetchRawTiles(e3, t6, i5, o7) {
    const { origin: r7, blockBoundary: n8 } = this.rasterInfo.storageInfo, { blockWidth: s5, blockHeight: l7 } = this.getBlockWidthHeight(e3);
    let { x: a7, y: c11 } = t6, { width: m7, height: f8, wrapCount: u7 } = i5;
    const h9 = this._getRasterTileAlignmentInfo(e3, 0);
    o7.buffer && (a7 -= o7.buffer.cols, c11 -= o7.buffer.rows, m7 += 2 * o7.buffer.cols, f8 += 2 * o7.buffer.rows);
    let p6 = 0, d7 = 0, x7 = 0;
    if (u7 && null != h9) {
      ({ worldColumnCountFromOrigin: d7, originColumnOffset: x7, rightPadding: p6 } = h9);
      d7 * h9.blockWidth - p6 >= a7 + m7 && (p6 = 0);
    }
    const y7 = Math.floor(a7 / s5), g5 = Math.floor(c11 / l7), I3 = Math.floor((a7 + m7 + p6 - 1) / s5), R4 = Math.floor((c11 + f8 + p6 - 1) / l7), w3 = n8[e3];
    if (!w3)
      return null;
    const { minRow: S3, minCol: k4, maxCol: T4, maxRow: b2 } = w3;
    if (0 === u7 && (R4 < S3 || I3 < k4 || g5 > b2 || y7 > T4))
      return null;
    const v5 = new Array();
    let P2 = false;
    const B3 = null == this.ioConfig.allowPartialFill ? o7.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let z = g5; z <= R4; z++)
      for (let t7 = y7; t7 <= I3; t7++) {
        let i6 = t7;
        if (!o7.disableWrapAround && u7 && null != h9 && d7 <= t7 && (i6 = t7 - d7 - x7), z >= S3 && i6 >= k4 && b2 >= z && T4 >= i6) {
          const t8 = this._fetchRawTile(e3, z, i6, o7);
          B3 ? v5.push(new Promise((e4) => {
            t8.then((t9) => e4(t9)).catch(() => {
              P2 = true, e4(null);
            });
          })) : v5.push(t8);
        } else
          v5.push(Promise.resolve(null));
      }
    if (0 === v5.length)
      return null;
    const M2 = await Promise.all(v5), _4 = { height: (R4 - g5 + 1) * l7, width: (I3 - y7 + 1) * s5 }, { spatialReference: W2 } = this.rasterInfo, C2 = this.getPyramidPixelSize(e3), { x: j6, y: H2 } = C2;
    return { extent: new M({ xmin: r7.x + y7 * s5 * j6, xmax: r7.x + (I3 + 1) * s5 * j6, ymin: r7.y - (R4 + 1) * l7 * H2, ymax: r7.y - g5 * l7 * H2, spatialReference: W2 }), pixelBlocks: M2, mosaicSize: _4, isPartiallyFilled: P2 };
  }
  _isSameResolution(e3, t6, i5) {
    return Math.abs(e3.x - t6.x) < i5 && Math.abs(e3.y - t6.y) < i5;
  }
  _fetchRawTile(e3, t6, i5, o7) {
    const r7 = this.rasterInfo.storageInfo.blockBoundary[e3];
    if (!r7)
      return Promise.resolve(null);
    const { minRow: n8, minCol: s5, maxCol: a7, maxRow: c11 } = r7;
    if (t6 < n8 || i5 < s5 || t6 > c11 || i5 > a7)
      return Promise.resolve(null);
    const m7 = i3(this.url, o7.sliceId), f8 = `${e3}/${t6}/${i5}`;
    let u7 = m5(m7, o7.registryId, f8);
    if (null == u7) {
      const r8 = new AbortController();
      u7 = this.fetchRawTile(e3, t6, i5, { ...o7, signal: r8.signal }), x2(m7, o7.registryId, f8, u7, r8), u7.catch(() => h5(m7, o7.registryId, f8));
    }
    return o7.signal && w(o7, () => {
      s4(m7, o7.registryId, f8);
    }), u7;
  }
  _computeMagDirValues(e3) {
    var _a;
    const { bandCount: t6, dataType: i5 } = this.rasterInfo;
    if (!(2 === t6 && "vector-magdir" === i5 || "vector-uv" === i5) || 2 !== (e3 == null ? void 0 : e3.length) || !((_a = e3[0]) == null ? void 0 : _a.length))
      return null;
    const o7 = e3[0].length;
    if ("vector-magdir" === i5) {
      const t7 = e3[1].map((e4) => (e4 + 360) % 360);
      return [e3[0], t7];
    }
    const [r7, n8] = e3, s5 = [], l7 = [];
    for (let a7 = 0; a7 < o7; a7++) {
      const [e4, t7] = l3([r7[a7], n8[a7]]);
      s5.push(e4), l7.push(t7);
    }
    return [s5, l7];
  }
  _getRasterTileAlignmentInfo(e3, t6) {
    return null == this._rasterTileAlighmentInfo && (this._rasterTileAlighmentInfo = V(this.rasterInfo)), null == this._rasterTileAlighmentInfo.pyramidsInfo ? null : { startX: t6, halfWorldWidth: this._rasterTileAlighmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlighmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlighmentInfo.pyramidsInfo[e3] };
  }
  _getSourceDataInfo(e3, t6, i5, o7 = {}) {
    const r7 = { datumTransformation: o7.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0, ul: { x: 0, y: 0 } };
    o7.srcResolution && (r7.srcResolution = o7.srcResolution, this._updateSourceDataInfo(e3, r7));
    const n8 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s5, srcHeight: l7, pyramidLevel: a7 } = r7, c11 = s5 / t6, m7 = l7 / i5, f8 = a7 < n8 && c11 * m7 >= 16, u7 = a7 === n8 && this._requireTooManySrcTiles(s5, l7, t6, i5);
    if (f8 || u7 || (0 === s5 || 0 === l7)) {
      const s6 = new x({ x: (e3.xmax - e3.xmin) / t6, y: (e3.ymax - e3.ymin) / i5, spatialReference: e3.spatialReference });
      let l8 = C(s6, this.rasterInfo.spatialReference, e3, r7.datumTransformation);
      const u8 = !l8 || o7.srcResolution && l8.x + l8.y < o7.srcResolution.x + o7.srcResolution.y;
      if (f8 && o7.srcResolution && u8) {
        const e4 = Math.round(Math.log(Math.max(c11, m7)) / Math.LN2) - 1;
        if (n8 - a7 + 3 >= e4) {
          const t7 = 2 ** e4;
          l8 = { x: o7.srcResolution.x * t7, y: o7.srcResolution.y * t7 };
        }
      }
      l8 && (r7.srcResolution = l8, this._updateSourceDataInfo(e3, r7));
    }
    return this._requireTooManySrcTiles(r7.srcWidth, r7.srcHeight, t6, i5) && (r7.srcWidth = 0, r7.srcHeight = 0), r7;
  }
  _requireTooManySrcTiles(e3, t6, i5, o7) {
    const { tileInfo: r7 } = this.rasterInfo.storageInfo;
    return Math.ceil(e3 / r7.size[0]) * Math.ceil(t6 / r7.size[1]) >= V2 || e3 / i5 > N3 || t6 / o7 > N3;
  }
  _updateSourceDataInfo(e3, t6) {
    t6.srcWidth = 0, t6.srcHeight = 0;
    const { rasterInfo: i5 } = this, o7 = i5.spatialReference, { srcResolution: r7, datumTransformation: n8 } = t6, { pyramidLevel: s5, pyramidResolution: l7, excessiveReading: a7 } = ie(r7, i5, this.ioConfig.sampling);
    if (a7)
      return;
    let c11 = t6.srcExtent || q(e3, o7, n8);
    if (null == c11)
      return;
    const m7 = i5.transform;
    m7 && (c11 = m7.inverseTransform(c11)), t6.srcExtent = c11;
    const { x: f8, y: u7 } = i5.storageInfo.origin, h9 = Math.floor((c11.xmin - f8) / l7.x + 0.1), p6 = Math.floor((u7 - c11.ymax) / l7.y + 0.1), d7 = Math.floor((c11.xmax - f8) / l7.x - 0.1), x7 = Math.floor((u7 - c11.ymin) / l7.y - 0.1), y7 = c11.width < 0.1 * l7.x ? 0 : d7 - h9 + 1, g5 = c11.height < 0.1 * l7.y ? 0 : x7 - p6 + 1;
    t6.pyramidLevel = s5, t6.pyramidResolution = l7, t6.srcWidth = y7, t6.srcHeight = g5, t6.ul = { x: h9, y: p6 };
  }
  _getRequestOptionsWithSliceId(e3) {
    return null != this.rasterInfo.multidimensionalInfo && null == e3.sliceId && (e3 = { ...e3, sliceId: this.getSliceIndex(e3.multidimensionalDefinition) }), e3;
  }
  _processIdentifyResult(e3, t6) {
    const { srcLocation: i5, position: o7, pyramidLevel: r7, useTransposedTile: n8 } = t6, s5 = e3.pixels[0].length / e3.width / e3.height;
    if (!(!e3.mask || e3.mask[o7]))
      return { location: i5, value: null };
    const { multidimensionalInfo: l7 } = this.rasterInfo;
    if (null == l7 || !n8) {
      const t7 = e3.pixels.map((e4) => e4[o7]), n9 = { location: i5, value: t7, pyramidLevel: r7 }, s6 = this._computeMagDirValues(t7.map((e4) => [e4]));
      return (s6 == null ? void 0 : s6.length) && (n9.magdirValue = s6.map((e4) => e4[0])), n9;
    }
    let a7 = e3.pixels.map((e4) => e4.slice(o7 * s5, o7 * s5 + s5)), c11 = this._computeMagDirValues(a7);
    const { requestSomeSlices: m7, identifyOptions: f8 } = t6;
    let u7 = i2(l7, f8.transposedVariableName);
    if (m7) {
      const e4 = a5(u7, f8.multidimensionalDefinition, f8.timeExtent);
      a7 = a7.map((t7) => e4.map((e5) => t7[e5])), c11 = c11 == null ? void 0 : c11.map((t7) => e4.map((e5) => t7[e5])), u7 = e4.map((e5) => u7[e5]);
    }
    const p6 = e3.noDataValues || this.rasterInfo.noDataValue, d7 = { pixels: a7, pixelType: e3.pixelType };
    let x7;
    null != p6 && (u2(d7, p6), x7 = d7.mask);
    return { location: i5, value: null, dataSeries: u7.map((e4, t7) => {
      const i6 = { value: 0 === (x7 == null ? void 0 : x7[t7]) ? null : a7.map((e5) => e5[t7]), multidimensionalDefinition: e4.multidimensionalDefinition.map((e5) => new p4({ ...e5, isSlice: true })) };
      return (c11 == null ? void 0 : c11.length) && (i6.magdirValue = [c11[0][t7], c11[1][t7]]), i6;
    }), pyramidLevel: r7 };
  }
};
e([y()], U3.prototype, "_rasterTileAlighmentInfo", void 0), e([y({ readOnly: true })], U3.prototype, "_isGlobalWrappableSource", null), e([y({ readOnly: true })], U3.prototype, "_hasNoneOrGCSShiftTransform", null), e([y()], U3.prototype, "rasterJobHandler", null), e([y(f3)], U3.prototype, "url", null), e([y({ type: String, json: { write: true } })], U3.prototype, "datasetName", void 0), e([y({ type: String, json: { write: true } })], U3.prototype, "datasetFormat", void 0), e([y()], U3.prototype, "hasUniqueSourceStorageInfo", void 0), e([y()], U3.prototype, "rasterInfo", void 0), e([y()], U3.prototype, "ioConfig", void 0), e([y()], U3.prototype, "sourceJSON", void 0), U3 = e([a("esri.layers.support.rasterDatasets.BaseRaster")], U3);
var $2 = U3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/FunctionRaster.js
var n4 = class extends $2 {
  constructor() {
    super(...arguments), this.datasetFormat = "Function", this.tileType = "Raster", this.rasterFunction = null;
  }
  async open(t6) {
    var _a, _b, _c, _d;
    await this.init();
    const { rasterFunction: r7 } = this;
    ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.length) ? r7.sourceRasters = this.primaryRasters.rasters : (this.primaryRasters = r7.getPrimaryRasters(), this.rasterJobHandler && ((_c = this.primaryRasters.rasters) == null ? void 0 : _c.forEach((t7) => t7.rasterJobHandler = this.rasterJobHandler)));
    const { rasters: s5, rasterIds: a7 } = this.primaryRasters, i5 = s5.map((e3) => e3.rasterInfo ? void 0 : e3.open(t6));
    await Promise.all(i5);
    const n8 = s5.map(({ rasterInfo: t7 }) => t7), c11 = r7.bind({ rasterInfos: n8, rasterIds: a7 });
    if (!c11.success || 0 === n8.length)
      throw new s2("raster-function:open", `cannot bind the function: ${c11.error ?? ""}`);
    const l7 = "Table" === r7.functionName ? r7 : (_d = r7.functionArguments) == null ? void 0 : _d.raster;
    "Table" === (l7 == null ? void 0 : l7.functionName) && (r7.rasterInfo.attributeTable = d2.fromJSON(l7.functionArguments.attributeTableAsRecordSet)), await this.syncJobHandler();
    const p6 = n8[0];
    this.hasUniqueSourceStorageInfo = 1 === n8.length || n8.slice(1).every((t7) => this._hasSameStorageInfo(t7, p6)), this.set("sourceJSON", s5[0].sourceJSON), this.set("rasterInfo", r7.rasterInfo);
  }
  async syncJobHandler() {
    var _a;
    return (_a = this.rasterJobHandler) == null ? void 0 : _a.updateRasterFunction(this.rasterFunction);
  }
  async fetchPixels(t6, e3, r7, s5 = {}) {
    var _a, _b;
    const { rasters: a7, rasterIds: o7 } = this.primaryRasters;
    let n8 = false;
    const { interpolation: c11 } = s5, l7 = (_a = this.rasterFunction.flatWebGLFunctionChain) == null ? void 0 : _a.hasSurfaceFunction;
    !s5.requestRawData && "bilinear" !== c11 && l7 && (n8 = 1 === a7.length && !s5.skipRasterFunction, s5 = { ...s5, interpolation: "bilinear", requestRawData: n8 });
    const p6 = a7.map((a8) => a8.fetchPixels(t6, e3, r7, s5)), u7 = await Promise.all(p6), m7 = u7.map((t7) => t7.pixelBlock), h9 = n8 || s5.requestRawData ? u7.map((t7) => t7.srcTilePixelSize) : null;
    if (s5.skipRasterFunction || m7.every((t7) => null == t7))
      return u7[0];
    const f8 = ((_b = u7.find((t7) => null != t7.pixelBlock)) == null ? void 0 : _b.extent) ?? t6, d7 = this.rasterJobHandler ? await this.rasterJobHandler.process({ extent: f8, primaryPixelBlocks: m7, primaryPixelSizes: h9, primaryRasterIds: o7 }) : this.rasterFunction.process({ extent: f8, primaryPixelBlocks: m7, primaryPixelSizes: h9, primaryRasterIds: o7 }), { transformGrid: y7 } = u7[0];
    if (!n8 || null == d7 || null == y7)
      return { ...u7[0], pixelBlock: d7 };
    const x7 = { rows: y7.spacing[0], cols: y7.spacing[1] };
    let b2;
    if (this.rasterJobHandler) {
      b2 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: [d7], srcMosaicSize: { width: d7.width, height: d7.height }, destDimension: { width: e3, height: r7 }, coefs: y7.coefficients, sampleSpacing: x7, projectDirections: false, gcsGrid: null, isUV: false, interpolation: c11, alignmentInfo: void 0, blockWidths: null }, s5)).pixelBlock;
    } else
      b2 = R3(d7, { width: e3, height: r7 }, y7.coefficients, x7, c11);
    return { extent: t6, srcExtent: u7[0].srcExtent, pixelBlock: b2 };
  }
  _hasSameStorageInfo(t6, e3) {
    const { storageInfo: r7, pixelSize: s5, spatialReference: a7, extent: i5 } = t6, { storageInfo: o7, pixelSize: n8, spatialReference: c11, extent: l7 } = e3;
    return s5.x === n8.x && s5.y === n8.y && a7.equals(c11) && i5.equals(l7) && r7.blockHeight === o7.blockHeight && r7.blockWidth === o7.blockWidth && r7.maximumPyramidLevel === o7.maximumPyramidLevel;
  }
};
e([y({ type: String, json: { write: true } })], n4.prototype, "datasetFormat", void 0), e([y()], n4.prototype, "tileType", void 0), e([y()], n4.prototype, "rasterFunction", void 0), e([y()], n4.prototype, "primaryRasters", void 0), n4 = e([a("esri.layers.support.rasterDatasets.FunctionRaster")], n4);
var c7 = n4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/clipUtils.js
function n5(e3, i5) {
  if (e3.spatialReference.equals(i5))
    return e3;
  const n8 = H(e3.spatialReference), a7 = H(i5);
  if (n8 === a7)
    return e3;
  const h9 = n8 / a7;
  return { x: e3.x * h9, y: e3.y * h9 };
}
async function a6(t6, e3, n8) {
  if ("extent" === n8.type)
    return o5(t6, e3, n8);
  const { width: a7, height: x7 } = t6, l7 = new Uint8Array(a7 * x7), { contains: m7, intersects: s5 } = await import("./geometryEngine-LO3MQFLQ.js");
  return s5(e3, n8) ? "polyline" === n8.type ? r5(t6, e3, n8) : m7(n8, e3) ? t6 : h6(t6, e3, n8) : new u3({ pixelType: t6.pixelType, width: a7, height: x7, mask: l7, maskIsAlpha: false, pixels: [...t6.pixels] });
}
function h6(t6, e3, n8) {
  if (!t6)
    return t6;
  const { width: a7, height: h9 } = t6, o7 = e3.width / a7, r7 = e3.height / h9, { xmin: x7, ymax: l7 } = e3;
  let m7;
  if ("extent" === n8.type) {
    const t7 = (n8.xmin - x7) / o7, e4 = (n8.xmax - x7) / o7, i5 = (l7 - n8.ymax) / r7, a8 = (l7 - n8.ymin) / r7;
    m7 = [[[t7, i5], [t7, a8], [e4, a8], [e4, i5], [t7, i5]]];
  } else
    m7 = n8.rings.map((t7) => t7.map(([t8, e4]) => [(t8 - x7) / o7, (l7 - e4) / r7]));
  const s5 = document.createElement("canvas");
  s5.width = a7, s5.height = h9;
  const p6 = s5.getContext("2d");
  p6.fillStyle = "#f00", m7.forEach((t7) => {
    p6.beginPath(), p6.moveTo(t7[0][0], t7[0][1]);
    for (let e4 = 0; e4 < t7.length; e4++)
      p6.lineTo(t7[e4][0], t7[e4][1]);
    p6.closePath(), p6.fill();
  });
  const f8 = p6.getImageData(0, 0, a7, h9).data, y7 = t6.mask, c11 = a7 * h9, M2 = new Uint8Array(c11);
  for (let i5 = 0; i5 < c11; i5++)
    y7 && !y7[i5] || (M2[i5] = f8[4 * i5 + 3] > 127 ? 255 : 0);
  return new u3({ pixelType: t6.pixelType, width: a7, height: h9, mask: M2, maskIsAlpha: false, pixels: [...t6.pixels] });
}
function o5(t6, e3, n8) {
  const { width: a7, height: h9 } = t6, o7 = new Uint8Array(a7 * h9), r7 = e3.width / a7, x7 = e3.height / h9;
  if (n8.width / r7 < 0.5 || n8.height / x7 < 0.5)
    return new u3({ pixelType: t6.pixelType, width: a7, height: h9, mask: o7, pixels: [...t6.pixels] });
  const { xmin: l7, xmax: m7, ymin: s5, ymax: p6 } = e3, { xmin: f8, xmax: y7, ymin: c11, ymax: M2 } = n8, u7 = Math.max(l7, f8), w3 = Math.min(m7, y7), d7 = Math.max(s5, c11), g5 = Math.min(p6, M2), T4 = 0.5 * r7, k4 = 0.5 * x7;
  if (w3 - u7 < T4 || g5 - d7 < k4 || w3 < l7 + T4 || u7 > m7 - T4 || d7 > p6 - k4 || g5 < s5 + k4)
    return new u3({ pixelType: t6.pixelType, width: a7, height: h9, mask: o7, pixels: [...t6.pixels] });
  const A = Math.max(0, (u7 - l7) / r7), R4 = Math.min(a7, Math.max(0, (w3 - l7) / r7)), U4 = Math.max(0, (p6 - g5) / x7), j6 = Math.min(h9, Math.max(0, (p6 - d7) / x7)), E3 = Math.round(A), I3 = Math.round(R4) - 1, P2 = Math.round(U4), v5 = Math.round(j6) - 1;
  if (E3 === I3 && A % 1 > 0.5 && R4 % 1 < 0.5 || P2 === v5 && U4 % 1 > 0.5 && j6 % 1 < 0.5)
    return new u3({ pixelType: t6.pixelType, width: a7, height: h9, mask: o7, pixels: [...t6.pixels] });
  if (0 === E3 && 0 === P2 && I3 === a7 && v5 === h9)
    return t6;
  const b2 = t6.mask;
  for (let i5 = P2; i5 <= v5; i5++)
    for (let t7 = E3; t7 <= I3; t7++) {
      const e4 = i5 * a7 + t7;
      o7[e4] = b2 ? b2[e4] : 255;
    }
  return new u3({ pixelType: t6.pixelType, width: a7, height: h9, mask: o7, pixels: [...t6.pixels] });
}
function r5(t6, e3, n8) {
  const { width: a7, height: h9 } = t6, o7 = new Uint8Array(a7 * h9), r7 = e3.width / a7, x7 = e3.height / h9, { xmin: l7, ymax: m7 } = e3, { paths: s5 } = n8, p6 = t6.mask;
  for (let i5 = 0; i5 < s5.length; i5++) {
    const t7 = s5[i5];
    for (let e4 = 0; e4 < t7.length - 1; e4++) {
      const [i6, n9] = t7[e4], [s6, f8] = t7[e4 + 1];
      let y7 = Math.floor((m7 - n9) / x7), c11 = Math.floor((m7 - f8) / x7);
      if (c11 < y7) {
        const t8 = y7;
        y7 = c11, c11 = t8;
      }
      y7 = Math.max(0, y7), c11 = Math.min(h9 - 1, c11);
      const M2 = (s6 - i6) / (f8 - n9);
      for (let t8 = y7; t8 <= c11; t8++) {
        const e5 = t8 === y7 ? Math.max(n9, f8) : (h9 + 1 - t8) * x7, m8 = t8 === c11 ? Math.min(n9, f8) : e5 - x7;
        let u7 = f8 === n9 ? Math.floor((i6 - l7) / r7) : Math.floor((M2 * (e5 - n9) + i6 - l7) / r7), w3 = f8 === n9 ? Math.floor((s6 - l7) / r7) : Math.floor((M2 * (m8 - n9) + i6 - l7) / r7);
        if (w3 < u7) {
          const t9 = u7;
          u7 = w3, w3 = t9;
        }
        const d7 = t8 * a7;
        u7 = Math.max(0, u7), w3 = Math.min(a7 - 1, w3);
        for (let t9 = d7 + u7; t9 <= d7 + w3; t9++)
          o7[t9] = p6 ? p6[t9] : 255;
      }
    }
  }
  return new u3({ pixelType: t6.pixelType, width: a7, height: h9, mask: o7, pixels: [...t6.pixels] });
}
function x3(t6, i5, a7, h9 = true) {
  const { spatialReference: o7 } = t6, { x: r7, y: x7 } = n5(a7, o7);
  let l7, m7, s5;
  const p6 = "extent" === i5.type ? i5 : i5.extent;
  let { xmin: f8, xmax: y7, ymax: c11, ymin: M2 } = p6;
  const { xmin: u7, ymax: w3 } = t6.extent;
  return h9 ? (f8 = u7 + (f8 > u7 ? r7 * Math.round((f8 - u7) / r7) : 0), c11 = w3 - (c11 < w3 ? x7 * Math.round((w3 - c11) / x7) : 0), y7 = u7 + (y7 > u7 ? r7 * Math.round((y7 - u7) / r7) : 0), M2 = w3 - (M2 < w3 ? x7 * Math.round((w3 - M2) / x7) : 0), l7 = new M({ xmin: f8, ymax: c11, xmax: y7, ymin: M2, spatialReference: o7 }), m7 = Math.round(l7.width / r7), s5 = Math.round(l7.height / x7)) : (m7 = Math.floor((y7 - f8) / r7 + 0.8), s5 = Math.floor((c11 - M2) / x7 + 0.8), f8 = u7 + (f8 > u7 ? r7 * Math.floor((f8 - u7) / r7 + 0.1) : 0), c11 = w3 - (c11 < w3 ? x7 * Math.floor((w3 - c11) / x7 + 0.1) : 0), y7 = f8 + m7 * r7, M2 = c11 - s5 * x7, l7 = new M({ xmin: f8, ymax: c11, xmax: y7, ymin: M2, spatialReference: o7 })), { extent: l7, width: m7, height: s5 };
}

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var B2 = s.getLogger("esri.layers.mixins.ImageryTileMixin");
var V3 = (o7) => {
  let V4 = class extends o7 {
    constructor(...t6) {
      var _a, _b;
      super(...t6), this._isConstructedFromFunctionRaster = false, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this.bandIds = null, this.copyright = null, this.interpolation = "nearest", this.multidimensionalSubset = null, this.raster = null, this.rasterInfo = null, this.sourceJSON = null, this.spatialReference = null, this.symbolizer = null, this._isConstructedFromFunctionRaster = "Function" === ((_b = (_a = t6[0]) == null ? void 0 : _a.raster) == null ? void 0 : _b.datasetFormat);
    }
    get fullExtent() {
      var _a;
      return (_a = this.rasterInfo) == null ? void 0 : _a.extent;
    }
    set multidimensionalDefinition(t6) {
      this._set("multidimensionalDefinition", t6), this.updateRenderer();
    }
    set rasterFunction(t6) {
      var _a;
      "none" === ((_a = t6 == null ? void 0 : t6.functionName) == null ? void 0 : _a.toLowerCase()) && (t6 = void 0), this._set("rasterFunction", t6), this.updateRasterFunction();
    }
    set url(t6) {
      this._set("url", y3(t6, B2));
    }
    set renderer(t6) {
      null == t6 && null == this.rasterFunction ? this._configDefaultRenderer("override") : (this._set("renderer", t6), this.updateRenderer());
    }
    readRenderer(t6, e3, r7) {
      var _a, _b;
      const n8 = (_b = (_a = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer;
      return c4(n8, r7) || void 0;
    }
    async convertVectorFieldData(t6, e3) {
      if (null == t6 || !this.rasterInfo)
        return null;
      const r7 = this._rasterJobHandler.instance, i5 = this.rasterInfo.dataType;
      return r7 ? r7.convertVectorFieldData({ pixelBlock: t6, dataType: i5 }, e3) : f4(t6, i5);
    }
    async computeStatisticsHistograms(t6, e3) {
      t6 = v(h4, t6).clone();
      const { rasterInfo: r7 } = this, { geometry: i5 } = t6;
      if (null == i5)
        throw new s2("imagery-tile-mixin:compute-statistics-histograms", "geometry must be specified");
      let n8 = i5;
      const { spatialReference: o8 } = r7;
      i5.spatialReference.equals(o8) || (await k(), n8 = "extent" === i5.type ? q(i5, o8) : J(i5, o8));
      const a7 = t6.pixelSize ?? new x({ x: r7.pixelSize.x, y: r7.pixelSize.y, spatialReference: o8 }), { extent: u7, width: c11, height: d7 } = x3(r7, n8, a7), m7 = await this.fetchPixels(u7, c11, d7, { ...e3, interpolation: "nearest" });
      if (null == m7.pixelBlock)
        throw new s2("imagery-tile-mixin:compute-statistics-histograms", "failed to fetch pixels");
      const h9 = await a6(m7.pixelBlock, u7, n8), p6 = this._rasterJobHandler.instance;
      return p6 ? p6.computeStatisticsHistograms({ pixelBlock: h9 }, e3) : m3(h9);
    }
    async createFlowMesh(t6, e3) {
      const r7 = this._rasterJobHandler.instance;
      return r7 ? r7.createFlowMesh(t6, e3) : s3(t6.meshType, t6.simulationSettings, t6.flowData, null != e3.signal ? e3.signal : new AbortController().signal);
    }
    normalizeRasterFetchOptions(t6) {
      var _a, _b;
      const { multidimensionalInfo: e3 } = this.rasterInfo ?? {};
      if (null == e3)
        return t6;
      let r7 = t6.multidimensionalDefinition || this.multidimensionalDefinition;
      null != r7 && r7.length || (r7 = d4(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset }));
      const i5 = t6.timeExtent || this.timeExtent;
      if (null != r7 && null != i5 && (null != i5.start || null != i5.end)) {
        r7 = r7.map((t7) => t7.clone());
        const n8 = (_b = (_a = e3.variables.find(({ name: t7 }) => t7 === r7[0].variableName)) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find(({ name: t7 }) => "StdTime" === t7), s5 = r7.find(({ dimensionName: t7 }) => "StdTime" === t7);
        if (!n8 || !s5)
          return { ...t6, multidimensionalDefinition: null };
        const { start: o8, end: a7 } = i5, l7 = null == o8 ? null : o8.getTime(), u7 = null == a7 ? null : a7.getTime(), c11 = l7 ?? u7, d7 = u7 ?? l7;
        if (null != n8.values) {
          const t7 = n8.values.filter((t8) => {
            if (Array.isArray(t8)) {
              if (c11 === d7)
                return t8[0] <= c11 && t8[1] >= c11;
              const e4 = t8[0] <= c11 && t8[1] > c11 || t8[0] < d7 && t8[1] >= d7, r8 = t8[0] >= c11 && t8[1] <= d7 || t8[0] < c11 && t8[1] > d7;
              return e4 || r8;
            }
            return c11 === d7 ? t8 === c11 : t8 >= c11 && t8 <= d7;
          });
          if (t7.length) {
            const e4 = t7.sort((t8, e5) => {
              const r8 = Array.isArray(t8) ? t8[0] : t8, i6 = Array.isArray(t8) ? t8[1] : t8, n9 = Array.isArray(e5) ? e5[0] : e5, s6 = Array.isArray(e5) ? e5[1] : e5;
              if (c11 === d7)
                return r8 - n9;
              return Math.abs(i6 - d7) - Math.abs(s6 - d7);
            })[0];
            s5.values = [e4];
          } else
            r7 = null;
        } else if (n8.hasRegularIntervals && n8.extent) {
          const [t7, e4] = n8.extent;
          c11 > e4 || d7 < t7 ? r7 = null : s5.values = c11 === d7 ? [c11] : [Math.max(t7, c11), Math.min(e4, d7)];
        }
      }
      return null != r7 && o4(r7, this.multidimensionalSubset) ? { ...t6, multidimensionalDefinition: null } : { ...t6, multidimensionalDefinition: r7 };
    }
    async updateRasterFunction() {
      var _a, _b, _c;
      if (!this.loaded || "imagery-tile" !== this.type || !this.rasterFunction && !this._cachedRasterFunctionJson || JSON.stringify(this.rasterFunction) === JSON.stringify(this._cachedRasterFunctionJson))
        return;
      if (this._isConstructedFromFunctionRaster && "Function" === this.raster.datasetFormat) {
        const t7 = this.raster.rasterFunction.toJSON();
        return !this.rasterFunction && t7 && this._set("rasterFunction", N2.fromJSON(t7)), void (this._cachedRasterFunctionJson = (_a = this.rasterFunction) == null ? void 0 : _a.toJSON());
      }
      let t6, e3 = this.raster, r7 = false;
      "Function" === e3.datasetFormat ? (t6 = e3.primaryRasters.rasters, e3 = t6[0], r7 = true) : t6 = [e3];
      const { rasterFunction: i5 } = this;
      if (i5) {
        const r8 = { raster: e3 };
        t6.length > 1 && t6.forEach((t7) => r8[t7.url] = t7);
        const n9 = _(((_b = i5.functionDefinition) == null ? void 0 : _b.toJSON()) ?? i5.toJSON(), r8), s6 = new c7({ rasterFunction: n9 });
        s6.rasterJobHandler = this._rasterJobHandler.instance, await s6.open(), this._cachedRasterFunctionJson = (_c = this.rasterFunction) == null ? void 0 : _c.toJSON(), this.raster = s6;
      } else
        this.raster = e3, this._cachedRasterFunctionJson = null, await e3.when();
      if (this._cachedRendererJson = null, !r7 && !i5)
        return;
      const { bandIds: n8 } = this, { bandCount: s5 } = this.raster.rasterInfo, o8 = (n8 == null ? void 0 : n8.length) ? n8.some((t7) => t7 >= s5) : s5 >= 3;
      n8 && (o8 || this.renderer && "raster-stretch" !== this.renderer.type) && this._set("bandIds", null), this._configDefaultRenderer("auto");
    }
    async updateRenderer() {
      const { loaded: t6, symbolizer: e3 } = this;
      if (!t6 || !e3 || !this.renderer)
        return;
      const { rasterInfo: r7 } = this.raster, i5 = f6(r7, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), n8 = i5 == null ? void 0 : i5.name, s5 = Q2({ ...this.renderer.toJSON(), variableName: n8 });
      if (JSON.stringify(this._cachedRendererJson) === JSON.stringify(s5))
        return;
      const o8 = this._rasterJobHandler.instance;
      o8 && (e3.rasterInfo = E(r7, n8), e3.rendererJSON = s5, e3.bind(), await o8.updateSymbolizer(e3), this._cachedRendererJson = s5);
    }
    async applyRenderer(t6, e3) {
      const r7 = t6 && t6.pixelBlock;
      if (!(null != r7 && r7.pixels && r7.pixels.length > 0))
        return null;
      let i5;
      await this.updateRenderer();
      const n8 = this._rasterJobHandler.instance, s5 = this.bandIds ?? [];
      return i5 = n8 ? await n8.symbolize({ ...t6, simpleStretchParams: e3, bandIds: s5 }) : this.symbolizer.symbolize({ ...t6, simpleStretchParams: e3, bandIds: s5 }), i5;
    }
    getTileUrl(t6, e3, r7) {
      return "RasterTileServer" === this.raster.datasetFormat ? `${this.url}/tile/${t6}/${e3}/${r7}` : "";
    }
    getCompatibleTileInfo(t6, e3, r7 = false) {
      if (!this.loaded || null == e3)
        return null;
      if (r7 && t6.equals(this.spatialReference))
        return this.tileInfo;
      const i5 = d(t6);
      return j4.create({ size: 256, spatialReference: t6, origin: i5 ? { x: i5.origin[0], y: i5.origin[1] } : { x: e3.xmin, y: e3.ymax } });
    }
    getCompatibleFullExtent(t6) {
      return this.loaded ? (this._compatibleFullExtent && this._compatibleFullExtent.spatialReference.equals(t6) || (this._compatibleFullExtent = this.raster.computeExtent(t6)), this._compatibleFullExtent) : null;
    }
    async fetchTile(t6, e3, r7, i5 = {}) {
      var _a;
      if (L5(this), i5.requestAsImageElement) {
        const s6 = this.getTileUrl(t6, e3, r7);
        return j2(s6, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: i5.signal }).then((t7) => t7.data);
      }
      const { rasterInfo: s5 } = this;
      if (null != s5.multidimensionalInfo && null == (i5 = this.normalizeRasterFetchOptions(i5)).multidimensionalDefinition) {
        const n8 = i5.tileInfo || s5.storageInfo.tileInfo;
        return { extent: this.raster.getTileExtentFromTileInfo(t6, e3, r7, n8), pixelBlock: null };
      }
      return await this._initJobHandler(), await this.updateRasterFunction(), "raster-shaded-relief" === ((_a = this.renderer) == null ? void 0 : _a.type) && (i5 = { ...i5, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(t6, e3, r7, i5);
    }
    async fetchPixels(t6, e3, r7, i5 = {}) {
      return null != this.rasterInfo.multidimensionalInfo && null == (i5 = this.normalizeRasterFetchOptions(i5)).multidimensionalDefinition ? { extent: t6, pixelBlock: null } : (await this._initJobHandler(), await this.updateRasterFunction(), e3 = Math.round(e3), r7 = Math.round(r7), this.raster.fetchPixels(t6, e3, r7, i5));
    }
    async identify(t6, e3 = {}) {
      var _a;
      const { raster: r7, rasterInfo: i5 } = this;
      if (null != i5.multidimensionalInfo) {
        if (!(i5.hasMultidimensionalTranspose && !!(h3(e3.multidimensionalDefinition) || e3.transposedVariableName || e3.timeExtent)) && null == (e3 = this.normalizeRasterFetchOptions(e3)).multidimensionalDefinition)
          return { location: t6, value: null };
      }
      const n8 = (_a = this.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
      if (n8 && !n8.contains(t6))
        throw new s2("imagery-tile-mixin:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      return r7.identify(t6, e3);
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    hasStandardTime() {
      var _a, _b, _c;
      const t6 = (_a = this.rasterInfo) == null ? void 0 : _a.multidimensionalInfo;
      if (null == t6 || "standard-time" !== ((_b = this.rasterInfo) == null ? void 0 : _b.dataType))
        return false;
      const e3 = this.multidimensionalDefinition, r7 = (_c = e3 == null ? void 0 : e3[0]) == null ? void 0 : _c.variableName;
      return t6.variables.some((t7) => t7.name === r7 && (!(e3 == null ? void 0 : e3[0].dimensionName) || t7.dimensions.some((t8) => "StdTime" === t8.name)));
    }
    getStandardTimeValue(t6) {
      return new Date(24 * (t6 - 25569) * 3600 * 1e3).toString();
    }
    getMultidimensionalSubsetVariables(t6) {
      var _a;
      const e3 = t6 ?? ((_a = this.rasterInfo) == null ? void 0 : _a.multidimensionalInfo);
      return g2(this.multidimensionalSubset, e3);
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = d4(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset })), this.rasterFunction && "Function" === this.raster.datasetFormat && (this._cachedRasterFunctionJson = this.rasterFunction.toJSON()), this._configDefaultRenderer();
    }
    _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const t6 = new t2();
      return this._rasterJobHandler.connectionPromise = t6.initialize().then(async () => {
        L5(this), this._rasterJobHandler.instance = t6, this.raster.rasterJobHandler = t6, "Function" === this.raster.datasetFormat && this.raster.syncJobHandler(), this.rasterFunction && await this.updateRasterFunction().catch(() => {
        }), this.renderer && this.updateRenderer();
      }).catch(() => {
      }), this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null, this.raster && (this.raster.rasterJobHandler = null);
    }
    _configDefaultInterpolation() {
      var _a;
      if (null == this.interpolation) {
        L5(this);
        const { raster: t6 } = this, e3 = L4(t6.rasterInfo, t6.tileType, (_a = this.sourceJSON) == null ? void 0 : _a.defaultResamplingMethod);
        this._set("interpolation", e3);
      }
    }
    _configDefaultRenderer(t6 = "no") {
      var _a, _b;
      L5(this);
      const { rasterInfo: e3 } = this.raster;
      !this.bandIds && e3.bandCount > 1 && (this.bandIds = q2(e3));
      const r7 = f6(e3, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), i5 = r7 == null ? void 0 : r7.name;
      if (!this.renderer || "override" === t6) {
        const t7 = k2(e3, { bandIds: this.bandIds, variableName: i5 }), r8 = e3.statistics, n9 = r8 && r8.length > 0 ? r8[0] : null, s6 = (n9 == null ? void 0 : n9.max) ?? 0, o9 = (n9 == null ? void 0 : n9.min) ?? 0;
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === t7.type && (s6 > 1e24 || o9 < -1e24) && (t7.dynamicRangeAdjustment = true, t7.statistics = null, "none" === t7.stretchType && (t7.stretchType = "min-max")), this.renderer = t7;
      }
      const n8 = Q2({ ...this.renderer.toJSON(), variableName: i5 }), s5 = E(e3, i5);
      this.symbolizer ? (this.symbolizer.rendererJSON = n8, this.symbolizer.rasterInfo = s5) : this.symbolizer = new L3({ rendererJSON: n8, rasterInfo: s5 });
      const o8 = this.symbolizer.bind();
      if (o8.success) {
        if ("auto" === t6) {
          const { colormap: t7 } = this.raster.rasterInfo, e4 = this.renderer;
          if (null != t7 && "raster-colormap" === e4.type) {
            const t8 = k2(this.raster.rasterInfo);
            JSON.stringify(t8) !== JSON.stringify(e4) && this._configDefaultRenderer("override");
          } else if ("raster-stretch" === e4.type) {
            const t8 = (_a = this.bandIds) == null ? void 0 : _a.length, r8 = (_b = e4.statistics) == null ? void 0 : _b.length;
            !e4.dynamicRangeAdjustment && r8 && t8 && r8 !== t8 && this._configDefaultRenderer("override");
          }
        }
      } else
        B2.warn("imagery-tile-mixin", o8.error || "The given renderer is not supported by the layer."), "auto" === t6 && this._configDefaultRenderer("override");
    }
  };
  function L5(t6) {
    if (!t6.raster || !t6.rasterInfo)
      throw new s2("imagery-tile", "no raster");
  }
  return e([y()], V4.prototype, "_cachedRendererJson", void 0), e([y()], V4.prototype, "_cachedRasterFunctionJson", void 0), e([y()], V4.prototype, "_compatibleFullExtent", void 0), e([y()], V4.prototype, "_isConstructedFromFunctionRaster", void 0), e([y()], V4.prototype, "_rasterJobHandler", void 0), e([y()], V4.prototype, "bandIds", void 0), e([y({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], V4.prototype, "copyright", void 0), e([y({ json: { read: false } })], V4.prototype, "fullExtent", null), e([y()], V4.prototype, "interpolation", void 0), e([y()], V4.prototype, "ioConfig", void 0), e([y({ type: [p4], json: { write: true } })], V4.prototype, "multidimensionalDefinition", null), e([y({ type: c5, json: { write: true } })], V4.prototype, "multidimensionalSubset", void 0), e([y()], V4.prototype, "raster", void 0), e([y({ type: N2, json: { name: "renderingRule", write: true } })], V4.prototype, "rasterFunction", null), e([y()], V4.prototype, "rasterInfo", void 0), e([y()], V4.prototype, "sourceJSON", void 0), e([y({ readOnly: true, type: f2, json: { read: false } })], V4.prototype, "spatialReference", void 0), e([y({ type: j4 })], V4.prototype, "tileInfo", void 0), e([y(f3)], V4.prototype, "url", null), e([y({ types: l5, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
    var _a;
    const t6 = "raster-stretch" === ((_a = this.renderer) == null ? void 0 : _a.type) && "none" === this.renderer.stretchType && !this.renderer.useGamma;
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || !t6 };
  } }, origins: { "web-scene": { types: d3, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (t6) => ({ enabled: t6 && "vector-field" !== t6.type && "flow" !== t6.type }) } } } } })], V4.prototype, "renderer", null), e([o("renderer")], V4.prototype, "readRenderer", null), e([y()], V4.prototype, "symbolizer", void 0), V4 = e([a("esri.layers.ImageryTileMixin")], V4), V4;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t4(e3) {
  const t6 = e3.fields, r7 = e3.records, n8 = t6.some((e4) => "oid" === e4.name.toLowerCase()) ? "OBJECTID" : "OID", i5 = [{ name: n8, type: "esriFieldTypeOID", alias: "OID" }].concat(t6.map((e4) => ({ name: e4.name, type: "esriFieldType" + e4.typeName, alias: e4.name }))), s5 = i5.map((e4) => e4.name), a7 = [];
  let o7 = 0, l7 = 0;
  return r7.forEach((e4) => {
    const t7 = {};
    for (t7[n8] = o7++, l7 = 1; l7 < s5.length; l7++)
      t7[s5[l7]] = e4[l7 - 1];
    a7.push({ attributes: t7 });
  }), { displayFieldName: "", fields: i5, features: a7 };
}
var r6 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r7) {
    const n8 = new DataView(r7), i5 = 3 & n8.getUint8(0);
    if (3 !== i5)
      return { header: { version: i5 }, recordSet: null };
    const s5 = n8.getUint32(4, true), a7 = n8.getUint16(8, true), o7 = n8.getUint16(10, true), l7 = { version: i5, recordCount: s5, headerByteCount: a7, recordByteCount: o7 };
    let p6 = 32;
    const g5 = [], u7 = [];
    let d7;
    if (3 === i5) {
      for (; 13 !== n8.getUint8(p6); )
        d7 = String.fromCharCode(n8.getUint8(p6 + 11)).trim(), g5.push({ name: r2(new Uint8Array(r7, p6, 11)), type: d7, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(d7)], length: n8.getUint8(p6 + 16) }), p6 += 32;
      if (p6 += 1, g5.length > 0)
        for (; u7.length < s5 && r7.byteLength - p6 > o7; ) {
          const t6 = [];
          32 === n8.getUint8(p6) ? (p6 += 1, g5.forEach((n9) => {
            if ("C" === n9.type)
              t6.push(r2(new Uint8Array(r7, p6, n9.length)).trim());
            else if ("N" === n9.type)
              t6.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r7, p6, n9.length)).trim(), 10));
            else if ("F" === n9.type)
              t6.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r7, p6, n9.length)).trim()));
            else if ("D" === n9.type) {
              const e3 = String.fromCharCode.apply(null, new Uint8Array(r7, p6, n9.length)).trim();
              t6.push(new Date(parseInt(e3.substring(0, 4), 10), parseInt(e3.substring(4, 6), 10) - 1, parseInt(e3.substring(6, 8), 10)));
            }
            p6 += n9.length;
          }), u7.push(t6)) : p6 += o7;
        }
    }
    return { header: l7, fields: g5, records: u7, recordSet: t4({ fields: g5, records: u7 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/CloudRaster.js
var g3 = /* @__PURE__ */ new Map();
g3.set("int16", "esriFieldTypeSmallInteger"), g3.set("int32", "esriFieldTypeInteger"), g3.set("int64", "esriFieldTypeInteger"), g3.set("float32", "esriFieldTypeSingle"), g3.set("float64", "esriFieldTypeDouble"), g3.set("text", "esriFieldTypeString");
var y5 = 8;
var x4 = class extends $2 {
  constructor() {
    super(...arguments), this.storageInfo = null, this.datasetFormat = "CRF";
  }
  async open(e3) {
    await this.init();
    const { data: r7 } = await this.request(this.url + "/conf.json", { signal: e3 == null ? void 0 : e3.signal });
    if (!this._validateHeader(r7))
      throw new s2("cloudraster:open", "Invalid or unsupported conf.json.");
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { storageInfo: i5, rasterInfo: o7 } = this._parseHeader(r7);
    if ("thematic" === o7.dataType) {
      const e4 = await this._fetchAuxiliaryInformation();
      o7.attributeTable = e4;
    }
    this._set("storageInfo", i5), this._set("rasterInfo", o7), this.ioConfig.retryCount = this.ioConfig.retryCount || 0;
  }
  async fetchRawTile(e3, t6, r7, i5 = {}) {
    const { transposeInfo: o7 } = this.rasterInfo.storageInfo, { transposedVariableName: s5 } = i5, a7 = !(!o7 || !s5), n8 = a7 ? 0 : this.rasterInfo.storageInfo.maximumPyramidLevel - e3;
    if (n8 < 0)
      return null;
    const l7 = this._buildCacheFilePath(n8, t6, r7, i5.multidimensionalDefinition, s5), f8 = this._getIndexRecordFromBundle(t6, r7, a7), m7 = await this.request(l7, { range: { from: 0, to: this.storageInfo.headerSize - 1 }, responseType: "array-buffer", signal: i5.signal });
    if (!m7)
      return null;
    const c11 = new Uint8Array(m7.data), p6 = this._getTileEndAndContentType(c11, f8);
    if (0 === p6.recordSize)
      return null;
    const d7 = await this.request(l7, { range: { from: p6.position, to: p6.position + p6.recordSize }, responseType: "array-buffer", signal: i5.signal });
    if (!d7)
      return null;
    const [u7, h9] = this._getTileSize(a7);
    return this.decodePixelBlock(d7.data, { width: u7, height: h9, planes: null, pixelType: null, returnInterleaved: a7 });
  }
  _validateHeader(e3) {
    const t6 = ["origin", "extent", "geodataXform", "LODInfos", "blockWidth", "blockHeight", "bandCount", "pixelType", "pixelSizeX", "pixelSizeY", "format", "packetSize"];
    return e3 && "RasterInfo" === e3.type && !t6.some((t7) => !e3[t7]);
  }
  _parseHeader(e3) {
    var _a;
    const t6 = ["u1", "u2", "u4", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"][e3.pixelType], { bandCount: r7, histograms: i5, colormap: l7, blockWidth: f8, blockHeight: m7, firstPyramidLevel: c11, maximumPyramidLevel: p6 } = e3, g5 = e3.statistics && e3.statistics.map((e4) => ({ min: e4.min, max: e4.max, avg: e4.mean, stddev: e4.standardDeviation, median: e4.median, mode: e4.mode })), x7 = e3.extent.spatialReference, S3 = (_a = e3.geodataXform) == null ? void 0 : _a.spatialReference, I3 = new f2((x7 == null ? void 0 : x7.wkid) || (x7 == null ? void 0 : x7.wkt) ? x7 : S3);
    let w3 = new M({ xmin: e3.extent.xmin, ymin: e3.extent.ymin, xmax: e3.extent.xmax, ymax: e3.extent.ymax, spatialReference: I3 });
    const _4 = new x({ x: e3.pixelSizeX, y: e3.pixelSizeY, spatialReference: I3 }), v5 = Math.round((w3.xmax - w3.xmin) / _4.x), b2 = Math.round((w3.ymax - w3.ymin) / _4.y), z = this._parseTransform(e3.geodataXform), T4 = z ? w3 : null;
    z && (w3 = z.forwardTransform(w3), _4.x = (w3.xmax - w3.xmin) / v5, _4.y = (w3.ymax - w3.ymin) / b2);
    const k4 = e3.properties ?? {}, j6 = e3.format.toLowerCase().replace("cache/", ""), C2 = new x(e3.origin.x, e3.origin.y, I3);
    let R4, F2, P2, H2;
    if (l7 && l7.colors)
      for (R4 = [], F2 = 0; F2 < l7.colors.length; F2++)
        P2 = l7.colors[F2], H2 = l7.values ? l7.values[F2] : F2, R4.push([H2, 255 & P2, P2 << 16 >>> 24, P2 << 8 >>> 24, P2 >>> 24]);
    const D3 = e3.LODInfos, L5 = [];
    for (F2 = 0; F2 < D3.levels.length; F2++)
      L5.push(new p2({ level: D3.levels[F2], resolution: D3.resolutions[F2], scale: 96 / 0.0254 * D3.resolutions[F2] }));
    const M2 = new j4({ dpi: 96, lods: L5, format: j6, origin: C2, size: [f8, m7], spatialReference: I3 }), O2 = { recordSize: y5, packetSize: e3.packetSize, headerSize: e3.packetSize * e3.packetSize * y5 + 64 }, B3 = [{ maxCol: Math.ceil(v5 / f8) - 1, maxRow: Math.ceil(b2 / m7) - 1, minCol: 0, minRow: 0 }];
    let $3 = 2;
    if (p6 > 0)
      for (F2 = 0; F2 < p6; F2++)
        B3.push({ maxCol: Math.ceil(v5 / $3 / f8) - 1, maxRow: Math.ceil(b2 / $3 / m7) - 1, minCol: 0, minRow: 0 }), $3 *= 2;
    const N4 = e3.mdInfo;
    let q3 = null;
    if (N4 && k4._yxs) {
      const e4 = k4._yxs;
      q3 = { packetSize: e4.PacketSize, tileSize: [e4.TileXSize, e4.TileYSize] };
    }
    return { storageInfo: O2, rasterInfo: new m2({ width: v5, height: b2, pixelType: t6, bandCount: r7, extent: w3, nativeExtent: T4, transform: z, spatialReference: I3, pixelSize: _4, keyProperties: k4, statistics: g5, histograms: i5, multidimensionalInfo: N4, colormap: R4, storageInfo: new n2({ blockWidth: f8, blockHeight: m7, pyramidBlockWidth: f8, pyramidBlockHeight: m7, origin: C2, tileInfo: M2, transposeInfo: q3, firstPyramidLevel: c11, maximumPyramidLevel: p6, blockBoundary: B3 }) }) };
  }
  _parseTransform(e3) {
    var _a, _b;
    if (!f5(e3))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transform types");
    const r7 = i(e3);
    if ("identity" === r7.type)
      return null;
    if ("polynomial" !== r7.type || !((_a = r7.forwardCoefficients) == null ? void 0 : _a.length) || !((_b = r7.inverseCoefficients) == null ? void 0 : _b.length))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");
    return r7;
  }
  async _fetchAuxiliaryInformation(e3) {
    const t6 = this.request(this.url + "/conf.vat.json", { signal: e3 }).then((e4) => e4.data).catch(() => null), r7 = this.request(this.url + "/conf.vat.dbf", { responseType: "array-buffer", signal: e3 }).then((e4) => e4.data).catch(() => null), i5 = await Promise.all([t6, r7]);
    let o7;
    if (i5[0]) {
      let e4 = i5[0].fields;
      const t7 = i5[0].values;
      if (e4 && t7) {
        e4 = e4.map((e5) => ({ type: "OID" === e5.name ? "esriFieldTypeOID" : g3.get(e5.type), name: e5.name, alias: e5.alias || e5.name }));
        const r8 = t7.map((e5) => ({ attributes: e5 }));
        e4 && t7 && (o7 = { fields: e4, features: r8 });
      }
    }
    if (!o7 && i5[1]) {
      o7 = r6.parse(i5[1]).recordSet;
    }
    return d2.fromJSON(o7);
  }
  _buildCacheFilePath(e3, t6, r7, i5, o7) {
    const s5 = this._getPackageSize(!!o7), a7 = Math.floor(t6 / s5) * s5, n8 = Math.floor(r7 / s5) * s5, l7 = "R" + this._toHexString4(a7) + "C" + this._toHexString4(n8);
    let f8 = "L";
    f8 += e3 >= 10 ? e3.toString() : "0" + e3.toString();
    const { multidimensionalInfo: m7 } = this.rasterInfo, c11 = i5 == null ? void 0 : i5[0];
    if (null == m7 || !c11)
      return `${this.url}/_alllayers/${f8}/${l7}.bundle`;
    let p6 = "_yxs";
    if (!o7) {
      p6 = m7.variables.find((e5) => e5.name === c11.variableName).dimensions[0].values.indexOf(c11.values[0]).toString(16);
      const e4 = 4 - p6.length;
      for (let t7 = 0; t7 < e4; t7++)
        p6 = "0" + p6;
      p6 = "S" + p6;
    }
    const d7 = this._getVariableFolderName(o7 || c11.variableName);
    return `${this.url}/_alllayers/${d7}/${p6}/${f8}/${l7}.bundle`;
  }
  _getPackageSize(e3 = false) {
    const { transposeInfo: t6 } = this.rasterInfo.storageInfo;
    return e3 && null != t6 ? t6.packetSize ?? 0 : this.storageInfo.packetSize;
  }
  _getTileSize(e3 = false) {
    const { storageInfo: t6 } = this.rasterInfo, { transposeInfo: r7 } = t6;
    return e3 && null != r7 ? r7.tileSize : t6.tileInfo.size;
  }
  _getVariableFolderName(e3) {
    return "" === (e3 = e3.trim()) ? "_v" : e3.replaceAll(/[\{|\}\-]/g, "_").replace("\\*", "_v");
  }
  _getIndexRecordFromBundle(e3, t6, r7 = false) {
    const i5 = this._getPackageSize(r7), o7 = i5 * (e3 % i5) + t6 % i5;
    if (o7 < 0)
      throw new Error("Invalid level / row / col");
    return 20 + o7 * this.storageInfo.recordSize + 44;
  }
  _getTileEndAndContentType(e3, t6) {
    const r7 = e3.subarray(t6, t6 + 8);
    let i5, o7 = 0;
    for (i5 = 0; i5 < 5; i5++)
      o7 |= (255 & r7[i5]) << 8 * i5;
    const s5 = 1099511627775 & o7;
    for (o7 = 0, i5 = 5; i5 < 8; i5++)
      o7 |= (255 & r7[i5]) << 8 * (i5 - 5);
    return { position: s5, recordSize: 1099511627775 & o7 };
  }
  _toHexString4(e3) {
    let t6 = e3.toString(16);
    if (4 !== t6.length) {
      let e4 = 4 - t6.length;
      for (; e4-- > 0; )
        t6 = "0" + t6;
    }
    return t6;
  }
};
e([y({ readOnly: true })], x4.prototype, "storageInfo", void 0), e([y({ type: String, json: { write: true } })], x4.prototype, "datasetFormat", void 0), x4 = e([a("esri.layers.support.rasterDatasets.CloudRaster")], x4);
var S = x4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var c8 = class extends $2 {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.data = null;
  }
  async open(t6) {
    await this.init();
    const e3 = this.data, { pixelBlock: s5, statistics: r7, histograms: i5, name: a7, keyProperties: n8, nativeExtent: m7, transform: c11 } = this.data, { width: h9, height: f8, pixelType: u7 } = s5, d7 = e3.extent ?? new M({ xmin: -0.5, ymin: 0.5, xmax: h9 - 0.5, ymax: f8 - 0.5, spatialReference: new f2({ wkid: 3857 }) }), y7 = e3.isPseudoSpatialReference ?? !e3.extent, x7 = { x: d7.width / h9, y: d7.height / f8 }, g5 = new m2({ width: h9, height: f8, pixelType: u7, extent: d7, nativeExtent: m7, transform: c11, pixelSize: x7, spatialReference: d7.spatialReference, bandCount: s5.pixels.length, keyProperties: n8 || {}, statistics: r7, isPseudoSpatialReference: y7, histograms: i5 });
    this.createRemoteDatasetStorageInfo(g5, 512, 512), this._set("rasterInfo", g5), this.updateTileInfo(), await this._buildInMemoryRaster(s5, { width: 512, height: 512 }, t6), this.datasetName = a7, this.url = "/InMemory/" + a7;
  }
  fetchRawTile(t6, e3, s5, r7 = {}) {
    const i5 = this._pixelBlockTiles.get(`${t6}/${e3}/${s5}`);
    return Promise.resolve(i5);
  }
  async _buildInMemoryRaster(t6, r7, i5) {
    var _a, _b;
    const o7 = this.rasterInfo.storageInfo.maximumPyramidLevel, a7 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t6, tileSize: r7, maximumPyramidLevel: o7 }, i5) : Promise.resolve(W(t6, r7, o7)), l7 = null != this.rasterInfo.statistics, p6 = null != this.rasterInfo.histograms, c11 = l7 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t6 }, i5) : Promise.resolve(h(t6)), h9 = await j([a7, c11]);
    if (!h9[0].value && h9[1].value)
      throw new s2("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = h9[0].value, l7 || (this.rasterInfo.statistics = (_a = h9[1].value) == null ? void 0 : _a.statistics), p6 || (this.rasterInfo.histograms = (_b = h9[1].value) == null ? void 0 : _b.histograms);
  }
};
e([y({ type: String, json: { write: true } })], c8.prototype, "datasetFormat", void 0), e([y()], c8.prototype, "data", void 0), c8 = e([a("esri.layers.support.rasterDatasets.InMemoryRaster")], c8);
var h7 = c8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n6(e3, t6) {
  if (!e3 || !t6)
    return [];
  let l7 = t6;
  t6.includes("/") ? (l7 = t6.slice(0, t6.indexOf("/")), t6 = t6.slice(t6.indexOf("/") + 1)) : t6 = "";
  const r7 = [];
  if (t6) {
    const u8 = n6(e3, l7);
    for (let e4 = 0; e4 < u8.length; e4++) {
      n6(u8[e4], t6).forEach((n8) => r7.push(n8));
    }
    return r7;
  }
  const u7 = e3.getElementsByTagNameNS("*", l7);
  if (!u7 || 0 === u7.length)
    return [];
  for (let n8 = 0; n8 < u7.length; n8++)
    r7.push(u7[n8] || u7.item(n8));
  return r7;
}
function e2(t6, l7) {
  if (!t6 || !l7)
    return null;
  let r7 = l7;
  l7.includes("/") ? (r7 = l7.slice(0, l7.indexOf("/")), l7 = l7.slice(l7.indexOf("/") + 1)) : l7 = "";
  const u7 = n6(t6, r7);
  return u7.length > 0 ? l7 ? e2(u7[0], l7) : u7[0] : null;
}
function t5(n8, t6 = null) {
  const l7 = t6 ? e2(n8, t6) : n8;
  let r7;
  return l7 ? (r7 = l7.textContent || l7.nodeValue, r7 ? r7.trim() : null) : null;
}
function l6(e3, t6) {
  const l7 = n6(e3, t6), r7 = [];
  let u7;
  for (let n8 = 0; n8 < l7.length; n8++)
    u7 = l7[n8].textContent || l7[n8].nodeValue, u7 && (u7 = u7.trim(), "" !== u7 && r7.push(u7));
  return r7;
}
function u5(n8, e3) {
  return l6(n8, e3).map((n9) => Number(n9));
}
function o6(n8, e3) {
  const l7 = t5(n8, e3);
  return Number(l7);
}
function i4(n8, e3) {
  var _a;
  const t6 = (_a = n8 == null ? void 0 : n8.nodeName) == null ? void 0 : _a.toLowerCase(), l7 = e3.toLowerCase();
  return t6.slice(t6.lastIndexOf(":") + 1) === l7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function f7(e3, t6) {
  if (!e3 || !t6)
    return null;
  const n8 = [];
  for (let r7 = 0; r7 < e3.length; r7++)
    n8.push(e3[r7]), n8.push(t6[r7]);
  return n8;
}
function u6(e3) {
  const t6 = e2(e3, "GeodataXform"), r7 = m6(o6(t6, "SpatialReference/WKID") || t5(t6, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t6.getAttribute("xsi:type"))
    return { spatialReference: r7, transform: null };
  const o7 = o6(t6, "PolynomialOrder") ?? 1, u7 = u5(t6, "CoeffX/Double"), c11 = u5(t6, "CoeffY/Double"), d7 = u5(t6, "InverseCoeffX/Double"), p6 = u5(t6, "InverseCoeffY/Double"), S3 = f7(u7, c11), C2 = f7(d7, p6);
  return { spatialReference: r7, transform: S3 && C2 && S3.length && C2.length ? new y4({ spatialReference: r7, polynomialOrder: o7, forwardCoefficients: S3, inverseCoefficients: C2 }) : null };
}
function c9(e3) {
  var _a;
  const t6 = o6(e3, "NoDataValue"), i5 = e2(e3, "Histograms/HistItem"), l7 = o6(i5, "HistMin"), o7 = o6(i5, "HistMax"), f8 = o6(i5, "BucketCount"), u7 = (_a = t5(i5, "HistCounts")) == null ? void 0 : _a.split("|").map((e4) => Number(e4));
  let c11, m7, d7, p6;
  n6(e3, "Metadata/MDI").forEach((e4) => {
    const t7 = Number(e4.textContent ?? e4.nodeValue);
    switch (e4.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c11 = t7;
        break;
      case "STATISTICS_MAXIMUM":
        m7 = t7;
        break;
      case "STATISTICS_MEAN":
        d7 = t7;
        break;
      case "STATISTICS_STDDEV":
        p6 = t7;
    }
  });
  const S3 = o6(e3, "Metadata/SourceBandIndex");
  return { noDataValue: t6, histogram: (u7 == null ? void 0 : u7.length) && null != l7 && null != o7 ? { min: l7, max: o7, size: f8 || u7.length, counts: u7 } : null, sourceBandIndex: S3, statistics: null != c11 && null != m7 ? { min: c11, max: m7, avg: d7, stddev: p6 } : null };
}
function m6(e3) {
  if (!e3)
    return null;
  let t6 = Number(e3);
  if (!isNaN(t6) && 0 !== t6)
    return new f2({ wkid: t6 });
  if ((e3 = String(e3)).startsWith("COMPD_CS")) {
    if (!e3.includes("VERTCS") || !e3.includes("GEOGCS") && !e3.startsWith("PROJCS"))
      return null;
    const n8 = e3.indexOf("VERTCS"), r7 = e3.indexOf("PROJCS"), s5 = r7 > -1 ? r7 : e3.indexOf("GEOGCS");
    if (-1 === s5)
      return null;
    const a7 = e3.slice(s5, e3.lastIndexOf("]", n8) + 1).trim(), i5 = e3.slice(n8, e3.lastIndexOf("]")).trim();
    t6 = d5(a7);
    const l7 = new f2(t6 ? { wkid: t6 } : { wkt: a7 }), f8 = d5(i5);
    return f8 && (l7.vcsWkid = f8), l7;
  }
  return e3.startsWith("GEOGCS") || e3.startsWith("PROJCS") ? (t6 = d5(e3), new f2(0 !== t6 ? { wkid: t6 } : { wkt: e3 })) : null;
}
function d5(e3) {
  var _a;
  const t6 = e3.replaceAll("]", "[").replaceAll('"', "").split("[").map((e4) => e4.trim()).filter((e4) => "" !== e4), n8 = t6[t6.length - 1].split(","), r7 = (_a = n8[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === r7 || "esri" === r7) && e3.endsWith('"]]')) {
    const e4 = Number(n8[1]);
    if (!isNaN(e4) && 0 !== e4)
      return e4;
  }
  return 0;
}
function p5(s5) {
  var _a;
  if ("pamdataset" !== ((_a = s5 == null ? void 0 : s5.documentElement.tagName) == null ? void 0 : _a.toLowerCase()))
    return {};
  const a7 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  s5.documentElement.childNodes.forEach((e3) => {
    if (1 === e3.nodeType) {
      if (i4(e3, "SRS")) {
        if (!a7.spatialReference) {
          const t6 = t5(e3);
          a7.spatialReference = m6(t6);
        }
      } else if (i4(e3, "Metadata"))
        if ("xml:ESRI" === e3.getAttribute("domain")) {
          const { spatialReference: t6, transform: n8 } = u6(e3);
          a7.transform = n8, a7.spatialReference || (a7.spatialReference = t6);
        } else {
          n6(e3, "MDI").forEach((e4) => a7.metadata[e4.getAttribute("key")] = t5(e4));
        }
      else if (i4(e3, "PAMRasterBand")) {
        const t6 = c9(e3);
        null != t6.sourceBandIndex && null == a7.rasterBands[t6.sourceBandIndex] ? a7.rasterBands[t6.sourceBandIndex] = t6 : a7.rasterBands.push(t6);
      }
    }
  });
  const i5 = a7.rasterBands;
  if (i5.length) {
    const t6 = !!i5[0].statistics;
    a7.statistics = t6 ? i5.map((e3) => e3.statistics).filter(R) : null;
    const n8 = !!i5[0].histogram;
    a7.histograms = n8 ? i5.map((e3) => e3.histogram).filter(R) : null;
  }
  return a7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h8 = class extends $2 {
  async open(t6) {
    await this.init();
    const e3 = await this._fetchData(t6);
    let { spatialReference: s5, statistics: r7, histograms: a7, transform: o7 } = await this._fetchAuxiliaryData(t6);
    const i5 = !s5;
    i5 && (s5 = new f2({ wkid: 3857 })), (a7 == null ? void 0 : a7.length) && null == r7 && (r7 = g(a7));
    const { width: l7, height: m7 } = e3;
    let c11 = new M({ xmin: -0.5, ymin: 0.5 - m7, xmax: l7 - 0.5, ymax: 0.5, spatialReference: s5 });
    const h9 = o7 ? o7.forwardTransform(c11) : c11;
    let d7 = true;
    if (o7) {
      const t7 = o7.forwardCoefficients;
      d7 = t7 && 0 === t7[1] && 0 === t7[2], d7 && (o7 = null, c11 = h9);
    }
    const w3 = new h7({ data: { extent: h9, nativeExtent: c11, transform: o7, pixelBlock: e3, statistics: r7, histograms: a7, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: i5 } });
    await w3.open(), w3.data = null, this._set("rasterInfo", w3.rasterInfo), this._inMemoryRaster = w3;
  }
  fetchRawTile(t6, e3, s5, r7 = {}) {
    return this._inMemoryRaster.fetchRawTile(t6, e3, s5, r7);
  }
  async _fetchData(t6) {
    const { data: s5 } = await this.request(this.url, { responseType: "array-buffer", signal: t6 == null ? void 0 : t6.signal }), r7 = P(s5).toUpperCase();
    if ("JPG" !== r7 && "PNG" !== r7 && "GIF" !== r7 && "BMP" !== r7)
      throw new s2("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r7);
    const a7 = r7.toLowerCase(), o7 = "gif" === a7 || "bmp" === a7 || !has("ios"), i5 = await this.decodePixelBlock(s5, { format: a7, useCanvas: o7, hasNoZlibMask: true });
    if (null == i5)
      throw new s2("image-aux-raster:open", "the data cannot be decoded");
    return i5;
  }
  async _fetchAuxiliaryData(t6) {
    var _a;
    const e3 = t6 == null ? void 0 : t6.signal, a7 = this.ioConfig.skipExtensions ?? [], o7 = a7.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3 }), i5 = this.datasetFormat, n8 = "JPG" === i5 ? "jgw" : "PNG" === i5 ? "pgw" : "BMP" === i5 ? "bpw" : null, m7 = n8 && a7.includes(n8) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + n8, { responseType: "text", signal: e3 }), p6 = await j([o7, m7]);
    if (e3 == null ? void 0 : e3.aborted)
      throw c();
    const f8 = p5((_a = p6[0].value) == null ? void 0 : _a.data);
    if (!f8.transform) {
      const t7 = p6[1].value ? p6[1].value.data.split("\n").slice(0, 6).map((t8) => Number(t8)) : null;
      f8.transform = 6 === (t7 == null ? void 0 : t7.length) ? new y4({ forwardCoefficients: [t7[4], t7[5], t7[0], -t7[1], t7[2], -t7[3]] }) : null;
    }
    return f8;
  }
};
e([y({ type: String, json: { write: true } })], h8.prototype, "datasetFormat", void 0), h8 = e([a("esri.layers.support.rasterDatasets.ImageAuxRaster")], h8);
var d6 = h8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var x5 = class extends $2 {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async open(e3) {
    var _a, _b;
    await this.init();
    const r7 = e3 && e3.signal, a7 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r7 });
    a7.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l7 = a7.data;
    if (this.sourceJSON = l7, !l7)
      throw new s2("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l7.tileInfo)
      throw new s2("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const m7 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l7.cacheType, null == this.tileType && (m7.includes(l7.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l7.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = ((_a = l7.name) == null ? void 0 : _a.slice(l7.name.indexOf("/") + 1)) ?? "";
    const u7 = await this._fetchRasterInfo({ signal: r7 });
    if (null == u7)
      throw new s2("image-server-raster:open", "cannot initialize image service");
    const h9 = "Map" === this.tileType ? g4(l7.tileInfo, l7) : j4.fromJSON(l7.tileInfo);
    r(h9);
    const [f8, p6] = this._computeMinMaxLOD(u7, h9), { extent: d7, pixelSize: y7 } = u7, x7 = 0.5 / u7.width * y7.x, v5 = Math.max(y7.x, y7.y), { lods: S3 } = h9;
    ("Map" !== this.tileType && 0 !== l7.maxScale || Math.abs(y7.x - y7.y) > x7 || !S3.some((e4) => Math.abs(e4.resolution - v5) < x7)) && (y7.x = y7.y = f8.resolution, u7.width = Math.ceil((d7.xmax - d7.xmin) / y7.x - 0.1), u7.height = Math.ceil((d7.ymax - d7.ymin) / y7.y - 0.1));
    const I3 = f8.level - p6.level, [w3, j6] = h9.size, M2 = [], b2 = [];
    S3.forEach((e4, t6) => {
      e4.level >= p6.level && e4.level <= f8.level && M2.push({ x: e4.resolution, y: e4.resolution }), t6 < S3.length - 1 && b2.push(Math.round(10 * e4.resolution / S3[t6 + 1].resolution) / 10);
    }), M2.sort((e4, t6) => e4.x - t6.x);
    const T4 = this.computeBlockBoundary(d7, w3, j6, h9.origin, M2, I3), _4 = M2.length > 1 ? M2.slice(1) : null;
    let O2;
    l7.transposeInfo && (O2 = { tileSize: [l7.transposeInfo.rows, l7.transposeInfo.cols], packetSize: ((_b = u7.keyProperties) == null ? void 0 : _b._yxs.PacketSize) ?? 0 });
    const R4 = b2.length <= 1 || b2.length >= 3 && b2.slice(0, b2.length - 1).every((e4) => e4 === b2[0]) ? b2[0] ?? 2 : Math.round(10 / (p6.resolution / f8.resolution) ** (-1 / I3)) / 10;
    if (u7.storageInfo = new n2({ blockWidth: h9.size[0], blockHeight: h9.size[1], pyramidBlockWidth: h9.size[0], pyramidBlockHeight: h9.size[1], pyramidResolutions: _4, pyramidScalingFactor: R4, compression: h9.format, origin: h9.origin, firstPyramidLevel: 1, maximumPyramidLevel: I3, tileInfo: h9, transposeInfo: O2, blockBoundary: T4 }), this._fixGCSShift(u7), this._set("rasterInfo", u7), l7.capabilities.toLowerCase().includes("tilemap")) {
      const e4 = { tileInfo: u7.storageInfo.tileInfo, parsedUrl: L(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new T3({ layer: e4 });
    }
  }
  async fetchRawTile(e3, t6, i5, s5 = {}) {
    const { storageInfo: r7, extent: a7 } = this.rasterInfo, { transposeInfo: l7 } = r7, o7 = null != l7 && !!s5.transposedVariableName;
    if (this._slices && !o7 && null == s5.sliceId)
      return null;
    const n8 = o7 ? 0 : r7.maximumPyramidLevel - e3 + this._levelOffset, c11 = `${this.url}/tile/${n8}/${t6}/${i5}`, m7 = this._slices ? o7 ? { variable: s5.transposedVariableName } : { sliceId: s5.sliceId || 0 } : null, { data: h9 } = await this.request(c11, { query: m7, responseType: "array-buffer", signal: s5.signal });
    if (!h9)
      return null;
    const f8 = o7 ? l7.tileSize : r7.tileInfo.size, p6 = await this.decodePixelBlock(h9, { width: f8[0], height: f8[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: o7, noDataValue: this.rasterInfo.noDataValue });
    if (null == p6)
      return null;
    const d7 = r7.blockBoundary[e3];
    if ("jpg" !== r7.compression || i5 > d7.minCol && i5 < d7.maxCol && t6 > d7.minRow && t6 < d7.maxRow)
      return p6;
    const { origin: y7, blockWidth: x7, blockHeight: g5 } = r7, { x: v5, y: S3 } = this.getPyramidPixelSize(e3), I3 = Math.round((a7.xmin - y7.x) / v5) % x7, w3 = Math.round((a7.xmax - y7.x) / v5) % x7 || x7, j6 = Math.round((y7.y - a7.ymax) / S3) % g5, M2 = Math.round((y7.y - a7.ymin) / S3) % g5 || g5, b2 = i5 === d7.minCol ? I3 : 0, T4 = t6 === d7.minRow ? j6 : 0, _4 = i5 === d7.maxCol ? w3 : x7, O2 = t6 === d7.maxRow ? M2 : g5;
    return T2(p6, { x: b2, y: T4 }, { width: _4 - b2, height: O2 - T4 }), p6;
  }
  getSliceIndex(e3) {
    if (!this._slices || null == e3 || 0 === e3.length)
      return null;
    const t6 = e3;
    for (let i5 = 0; i5 < this._slices.length; i5++) {
      const e4 = this._slices[i5].multidimensionalDefinition;
      if (e4.length === t6.length && !e4.some((e5) => {
        const i6 = t6.find((t7) => e5.variableName === t7.variableName && t7.dimensionName === e5.dimensionName);
        if (!i6)
          return true;
        return (Array.isArray(e5.values[0]) ? `${e5.values[0][0]}-${e5.values[0][1]}` : e5.values[0]) !== (Array.isArray(i6.values[0]) ? `${i6.values[0][0]}-${i6.values[0][1]}` : i6.values[0]);
      }))
        return i5;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e3, t6) {
    const i5 = this.request(this.url + "/statistics", { query: { variable: e3, f: "json" }, signal: t6 }).then((e4) => {
      var _a;
      return (_a = e4.data) == null ? void 0 : _a.statistics;
    }), s5 = this.request(this.url + "/histograms", { query: { variable: e3, f: "json" }, signal: t6 }).then((e4) => {
      var _a;
      return (_a = e4.data) == null ? void 0 : _a.histograms;
    }), r7 = await Promise.all([i5, s5]);
    return r7[0] && r7[0].forEach((e4) => {
      e4.avg = e4.mean, e4.stddev = e4.standardDeviation;
    }), { statistics: r7[0] || null, histograms: r7[1] || null };
  }
  async computeBestPyramidLevelForLocation(e3, t6 = {}) {
    if (!this._tilemapCache)
      return 0;
    let i5 = this.identifyPixelLocation(e3, 0, t6.datumTransformation);
    if (null === i5)
      return null;
    let s5 = 0;
    const { maximumPyramidLevel: r7 } = this.rasterInfo.storageInfo;
    let a7 = r7 - s5 + this._levelOffset;
    const l7 = i5.srcLocation;
    for (; a7 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a7, i5.row, i5.col, t6))
          break;
      } catch {
      }
      if (a7--, s5++, i5 = this.identifyPixelLocation(l7, s5, t6.datumTransformation), null === i5)
        return null;
    }
    return -1 === a7 || null == i5 ? null : s5;
  }
  async _fetchRasterInfo(e3) {
    const t6 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e4 = t6.fullExtent || t6.extent, i6 = Math.ceil((e4.xmax - e4.xmin) / t6.pixelSizeX - 0.1), s6 = Math.ceil((e4.ymax - e4.ymin) / t6.pixelSizeY - 0.1), r8 = f2.fromJSON(t6.spatialReference || e4.spatialReference), a8 = new x({ x: t6.pixelSizeX, y: t6.pixelSizeY, spatialReference: r8 });
      return new m2({ width: i6, height: s6, bandCount: 3, extent: M.fromJSON(e4), spatialReference: r8, pixelSize: a8, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i5 } = e3, s5 = m4(this.url, this.sourceJSON, { signal: i5, query: this.ioConfig.customFetchParameters }), r7 = t6.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i5 }).then((e4) => e4.data && e4.data.slices).catch(() => null) : null, a7 = await Promise.all([s5, r7]);
    return this._slices = a7[1], a7[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e3 } = this;
    e3.minScale && e3.minScale < 0 && (e3.minScale = 0), e3.maxScale && e3.maxScale < 0 && (e3.maxScale = 0);
  }
  _fixGCSShift(e3) {
    const { extent: t6, spatialReference: i5 } = e3;
    t6.xmin > -1 && t6.xmax > 181 && (i5 == null ? void 0 : i5.wkid) && i5.isGeographic && (e3.nativeExtent = e3.extent, e3.transform = new n3(), e3.extent = e3.transform.forwardTransform(t6));
  }
  _computeMinMaxLOD(e3, t6) {
    const { pixelSize: i5 } = e3, s5 = 0.5 / e3.width * i5.x, { lods: r7 } = t6, a7 = t6.lodAt(Math.max.apply(null, r7.map((e4) => e4.level))), l7 = t6.lodAt(Math.min.apply(null, r7.map((e4) => e4.level))), { tileType: o7 } = this;
    if ("Map" === o7)
      return this._levelOffset = r7[0].level, [a7, l7];
    if ("Raster" === o7) {
      return [r7.find((e4) => e4.resolution === i5.x) ?? a7, l7];
    }
    const { minScale: n8, maxScale: c11 } = this.sourceJSON;
    let m7 = a7;
    c11 > 0 && (m7 = r7.find((e4) => Math.abs(e4.scale - c11) < s5), m7 || (m7 = r7.filter((e4) => e4.scale > c11).sort((e4, t7) => e4.scale > t7.scale ? 1 : -1)[0] ?? a7));
    let u7 = l7;
    return n8 > 0 && (u7 = r7.find((e4) => Math.abs(e4.scale - n8) < s5) ?? l7, this._levelOffset = u7.level - l7.level), [m7, u7];
  }
};
function g4(e3, t6) {
  if (!e3)
    return null;
  const { minScale: i5, maxScale: s5, minLOD: r7, maxLOD: a7 } = t6;
  if (null != r7 && null != a7)
    return j4.fromJSON({ ...e3, lods: e3.lods.filter(({ level: e4 }) => null != e4 && e4 >= r7 && e4 <= a7) });
  if (0 !== i5 && 0 !== s5) {
    const t7 = (e4) => Math.round(1e4 * e4) / 1e4, r8 = i5 ? t7(i5) : 1 / 0, a8 = s5 ? t7(s5) : -1 / 0;
    return j4.fromJSON({ ...e3, lods: e3.lods.filter((e4) => {
      const i6 = t7(e4.scale);
      return i6 <= r8 && i6 >= a8;
    }) });
  }
  return j4.fromJSON(e3);
}
e([y({ type: String, json: { write: true } })], x5.prototype, "datasetFormat", void 0), e([y()], x5.prototype, "tileType", void 0), x5 = e([a("esri.layers.support.rasterDatasets.ImageServerRaster")], x5);
var v3 = x5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y6 = /* @__PURE__ */ new Map();
y6.set("Int8", "s8"), y6.set("UInt8", "u8"), y6.set("Int16", "s16"), y6.set("UInt16", "u16"), y6.set("Int32", "s32"), y6.set("UInt32", "u32"), y6.set("Float32", "f32"), y6.set("Float64", "f32"), y6.set("Double64", "f32");
var x6 = /* @__PURE__ */ new Map();
x6.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x6.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x6.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x6.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var w2 = class extends $2 {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async open(t6) {
    var _a;
    await this.init(), this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e3 = t6 ? t6.signal : null, r7 = await this.request(this.url, { responseType: "xml", signal: e3 }), { rasterInfo: s5, files: o7 } = this._parseHeader(r7.data);
    if (-1 === ((_a = this.ioConfig.skipExtensions) == null ? void 0 : _a.indexOf("aux.xml"))) {
      const e4 = await this._fetchAuxiliaryData(t6);
      null != e4 && (s5.statistics = e4.statistics ?? s5.statistics, s5.histograms = e4.histograms, e4.histograms && null == s5.statistics && (s5.statistics = g(e4.histograms)));
    }
    this._set("rasterInfo", s5), this._files = o7;
    const i5 = await this.request(o7.index, { responseType: "array-buffer", signal: e3 });
    this._storageIndex = this._parseIndex(i5.data);
    const { blockWidth: a7, blockHeight: n8 } = this.rasterInfo.storageInfo, l7 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: f8, height: c11 } = this.rasterInfo, p6 = [], m7 = this._getBandSegmentCount();
    let u7 = 0, g5 = -1;
    for (; u7 < this._storageIndex.length; ) {
      g5++;
      const t7 = Math.ceil(f8 / a7 / l7 ** g5) - 1, e4 = Math.ceil(c11 / n8 / l7 ** g5) - 1;
      u7 += (t7 + 1) * (e4 + 1) * m7 * 4, p6.push({ maxRow: e4, maxCol: t7, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = p6, g5 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = g5), this.updateTileInfo();
  }
  async fetchRawTile(t6, e3, r7, s5 = {}) {
    const { blockWidth: i5, blockHeight: a7, blockBoundary: n8 } = this.rasterInfo.storageInfo, l7 = n8[t6];
    if (!l7 || l7.maxRow < e3 || l7.maxCol < r7 || l7.minRow > e3 || l7.minCol > r7)
      return null;
    const { bandCount: f8, pixelType: c11 } = this.rasterInfo, { ranges: p6, actualTileWidth: m7, actualTileHeight: h9 } = this._getTileLocation(t6, e3, r7);
    if (!p6 || 0 === p6.length)
      return null;
    if (0 === p6[0].from && 0 === p6[0].to) {
      const t7 = new Uint8Array(i5 * a7);
      return new u3({ width: i5, height: a7, pixels: null, mask: t7, validPixelCount: 0 });
    }
    const { bandIds: u7 } = this.ioConfig, g5 = this._getBandSegmentCount(), d7 = [];
    let y7 = 0;
    for (y7 = 0; y7 < g5; y7++)
      u7 && !u7.includes(y7) || d7.push(this.request(this._files.data, { range: { from: p6[y7].from, to: p6[y7].to }, responseType: "array-buffer", signal: s5.signal }));
    const w3 = await Promise.all(d7), I3 = w3.map((t7) => t7.data.byteLength).reduce((t7, e4) => t7 + e4), b2 = new Uint8Array(I3);
    let A = 0;
    for (y7 = 0; y7 < g5; y7++)
      b2.set(new Uint8Array(w3[y7].data), A), A += w3[y7].data.byteLength;
    const F2 = x6.get(this.rasterInfo.storageInfo.compression).decoderFormat, _4 = await this.decodePixelBlock(b2.buffer, { width: i5, height: a7, format: F2, planes: (u7 == null ? void 0 : u7.length) || f8, pixelType: c11 });
    if (null == _4)
      return null;
    let { noDataValue: R4 } = this.rasterInfo;
    if (null != R4 && "lerc" !== F2 && !_4.mask && (R4 = R4[0], null != R4)) {
      const t7 = _4.width * _4.height, e4 = new Uint8Array(t7);
      if (Math.abs(R4) > 1e24)
        for (y7 = 0; y7 < t7; y7++)
          Math.abs((_4.pixels[0][y7] - R4) / R4) > 1e-6 && (e4[y7] = 1);
      else
        for (y7 = 0; y7 < t7; y7++)
          _4.pixels[0][y7] !== R4 && (e4[y7] = 1);
      _4.mask = e4;
    }
    let S3 = 0, j6 = 0;
    if (m7 !== i5 || h9 !== a7) {
      let t7 = _4.mask;
      if (t7)
        for (y7 = 0; y7 < a7; y7++)
          if (j6 = y7 * i5, y7 < h9)
            for (S3 = m7; S3 < i5; S3++)
              t7[j6 + S3] = 0;
          else
            for (S3 = 0; S3 < i5; S3++)
              t7[j6 + S3] = 0;
      else
        for (t7 = new Uint8Array(i5 * a7), _4.mask = t7, y7 = 0; y7 < h9; y7++)
          for (j6 = y7 * i5, S3 = 0; S3 < m7; S3++)
            t7[j6 + S3] = 1;
    }
    return _4;
  }
  _parseIndex(t6) {
    if (t6.byteLength % 16 > 0)
      throw new Error("invalid array buffer must be multiples of 16");
    let e3, r7, s5, o7, i5, a7;
    if (r3) {
      for (r7 = new Uint8Array(t6), o7 = new ArrayBuffer(t6.byteLength), s5 = new Uint8Array(o7), i5 = 0; i5 < t6.byteLength / 4; i5++)
        for (a7 = 0; a7 < 4; a7++)
          s5[4 * i5 + a7] = r7[4 * i5 + 3 - a7];
      e3 = new Uint32Array(o7);
    } else
      e3 = new Uint32Array(t6);
    return e3;
  }
  _getBandSegmentCount() {
    return x6.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t6, e3, r7) {
    const { blockWidth: s5, blockHeight: o7, pyramidScalingFactor: i5 } = this.rasterInfo.storageInfo, { width: a7, height: n8 } = this.rasterInfo, l7 = this._getBandSegmentCount();
    let f8, c11, p6, m7 = 0, h9 = 0;
    for (p6 = 0; p6 < t6; p6++)
      h9 = i5 ** p6, f8 = Math.ceil(a7 / s5 / h9), c11 = Math.ceil(n8 / o7 / h9), m7 += f8 * c11;
    h9 = i5 ** t6, f8 = Math.ceil(a7 / s5 / h9), c11 = Math.ceil(n8 / o7 / h9), m7 += e3 * f8 + r7, m7 *= 4 * l7;
    const u7 = this._storageIndex.subarray(m7, m7 + 4 * l7);
    let g5 = 0, d7 = 0;
    const y7 = [];
    for (let x7 = 0; x7 < l7; x7++)
      g5 = u7[4 * x7] * 2 ** 32 + u7[4 * x7 + 1], d7 = g5 + u7[4 * x7 + 2] * 2 ** 32 + u7[4 * x7 + 3], y7.push({ from: g5, to: d7 });
    return { ranges: y7, actualTileWidth: r7 < f8 - 1 ? s5 : Math.ceil(a7 / h9) - s5 * (f8 - 1), actualTileHeight: e3 < c11 - 1 ? o7 : Math.ceil(n8 / h9) - o7 * (c11 - 1) };
  }
  _parseHeader(t6) {
    const r7 = e2(t6, "MRF_META/Raster");
    if (!r7)
      throw new s2("mrf:open", "not a valid MRF format");
    const s5 = e2(r7, "Size"), o7 = parseInt(s5.getAttribute("x"), 10), n8 = parseInt(s5.getAttribute("y"), 10), f8 = parseInt(s5.getAttribute("c"), 10), m7 = (t5(r7, "Compression") || "none").toLowerCase();
    if (!x6.has(m7))
      throw new s2("mrf:open", "currently does not support compression " + m7);
    const h9 = t5(r7, "DataType") || "UInt8", w3 = y6.get(h9);
    if (null == w3)
      throw new s2("mrf:open", "currently does not support pixel type " + h9);
    const I3 = e2(r7, "PageSize"), b2 = parseInt(I3.getAttribute("x"), 10), A = parseInt(I3.getAttribute("y"), 10), F2 = e2(r7, "DataValues");
    let _4, R4;
    F2 && (R4 = F2.getAttribute("NoData"), null != R4 && (_4 = R4.trim().split(" ").map((t7) => parseFloat(t7))));
    if (e2(t6, "MRF_META/CachedSource"))
      throw new s2("mrf:open", "currently does not support MRF referencing other data files");
    const S3 = e2(t6, "MRF_META/GeoTags"), j6 = e2(S3, "BoundingBox");
    let k4, M2 = false;
    if (null != j6) {
      const t7 = parseFloat(j6.getAttribute("minx")), e3 = parseFloat(j6.getAttribute("miny")), r8 = parseFloat(j6.getAttribute("maxx")), s6 = parseFloat(j6.getAttribute("maxy")), o8 = t5(S3, "Projection") || "";
      let i5 = f2.WGS84;
      if ("LOCAL_CS[]" !== o8)
        if (o8.toLowerCase().startsWith("epsg:")) {
          const t8 = Number(o8.slice(5));
          isNaN(t8) || 0 === t8 || (i5 = new f2({ wkid: t8 }));
        } else
          i5 = m6(o8) ?? f2.WGS84;
      else
        M2 = true, i5 = new f2({ wkid: 3857 });
      k4 = new M(t7, e3, r8, s6), k4.spatialReference = i5;
    } else
      M2 = true, k4 = new M({ xmin: -0.5, ymin: 0.5 - n8, xmax: o7 - 0.5, ymax: 0.5, spatialReference: new f2({ wkid: 3857 }) });
    const T4 = e2(t6, "MRF_META/Rsets"), C2 = parseInt(T4 && T4.getAttribute("scale") || "2", 10), U4 = k4.spatialReference, B3 = new n2({ origin: new x({ x: k4.xmin, y: k4.ymax, spatialReference: U4 }), blockWidth: b2, blockHeight: A, pyramidBlockWidth: b2, pyramidBlockHeight: A, compression: m7, pyramidScalingFactor: C2 }), E3 = new x({ x: k4.width / o7, y: k4.height / n8, spatialReference: U4 }), L5 = new m2({ width: o7, height: n8, extent: k4, isPseudoSpatialReference: M2, spatialReference: U4, bandCount: f8, pixelType: w3, pixelSize: E3, noDataValue: _4, storageInfo: B3 }), P2 = t5(t6, "datafile"), W2 = t5(t6, "IndexFile");
    return { rasterInfo: L5, files: { mrf: this.url, index: W2 || this.url.replace(".mrf", ".idx"), data: P2 || this.url.replace(".mrf", x6.get(m7).blobExtension) } };
  }
  async _fetchAuxiliaryData(t6) {
    try {
      const { data: e3 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t6 == null ? void 0 : t6.signal });
      return p5(e3);
    } catch {
      return null;
    }
  }
};
e([y()], w2.prototype, "_files", void 0), e([y()], w2.prototype, "_storageIndex", void 0), e([y({ type: String, json: { write: true } })], w2.prototype, "datasetFormat", void 0), w2 = e([a("esri.layers.support.rasterIO.MRFRaster")], w2);
var I2 = w2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var F = (e3, t6) => {
  var _a;
  return (_a = e3.get(t6)) == null ? void 0 : _a.values;
};
var E2 = (e3, t6) => {
  var _a, _b;
  return (_b = (_a = e3.get(t6)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
};
var S2 = class extends $2 {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async open(e3) {
    var _a, _b, _c, _d;
    await this.init();
    const t6 = e3 ? e3.signal : null, { data: i5 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: t6 });
    if (!i5)
      throw new s2("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: s5, firstIFDPos: a7, isBigTiff: n8 } = v2(i5), o7 = [];
    await this._readIFDs(o7, i5, s5, a7, 0, n8 ? 8 : 4, t6);
    const { imageInfo: f8, rasterInfo: l7 } = this._parseIFDs(o7), u7 = U(o7), m7 = N(o7);
    if (this._headerInfo = { littleEndian: s5, isBigTiff: n8, ifds: o7, pyramidIFDs: u7, maskIFDs: m7, ...f8 }, this._set("rasterInfo", l7), !f8.isSupported)
      throw new s2("tiffraster:open", "this tiff is not supported: " + f8.message);
    if (!f8.tileWidth)
      throw new s2("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    const d7 = (_b = (_a = o7[0].get("PREDICTOR")) == null ? void 0 : _a.values) == null ? void 0 : _b[0], y7 = (_d = (_c = o7[0].get("SAMPLEFORMAT")) == null ? void 0 : _c.values) == null ? void 0 : _d[0];
    if (3 === y7 && 2 === d7)
      throw new s2("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floatting point data");
    const { skipExtensions: g5 = [] } = this.ioConfig;
    if (!g5.includes("aux.xml")) {
      const t7 = await this._fetchAuxiliaryMetaData(e3);
      null != t7 && this._processPAMInfo(t7, l7);
    }
    g5.includes("vat.dbf") || 1 !== l7.bandCount || "u8" !== l7.pixelType || (l7.attributeTable = await this._fetchAuxiliaryTable(e3), null != l7.attributeTable && (l7.keyProperties.DataType = "thematic")), this.updateTileInfo();
  }
  async fetchRawTile(e3, t6, r7, i5 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e3, t6, r7))
      return null;
    const s5 = await this._fetchRawTiffTile(e3, t6, r7, false, i5);
    if (null != s5 && this._headerInfo.hasMaskBand) {
      const a7 = await this._fetchRawTiffTile(e3, t6, r7, true, i5);
      null != a7 && a7.pixels[0] instanceof Uint8Array && (s5.mask = a7.pixels[0]);
    }
    return s5;
  }
  _parseIFDs(e3) {
    var _a, _b;
    const t6 = R2(e3), { width: r7, height: i5, tileWidth: s5, tileHeight: o7, planes: f8, pixelType: u7, compression: c11, firstPyramidLevel: p6, maximumPyramidLevel: h9, pyramidBlockWidth: d7, pyramidBlockHeight: y7, tileBoundary: g5, affine: T4, metadata: x7 } = t6, w3 = ((_a = t6.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = t6.extent.spatialReference) == null ? void 0 : _b.wkid);
    let S3 = m6(w3), v5 = !!t6.isPseudoGeographic;
    null == S3 && (v5 = true, S3 = new f2({ wkid: 3857 }));
    const D3 = new M({ ...t6.extent, spatialReference: S3 }), P2 = new x(D3 ? { x: D3.xmin, y: D3.ymax, spatialReference: S3 } : { x: 0, y: 0 }), k4 = new n2({ blockWidth: s5, blockHeight: o7, pyramidBlockWidth: d7, pyramidBlockHeight: y7, compression: c11, origin: P2, firstPyramidLevel: p6, maximumPyramidLevel: h9, blockBoundary: g5 }), O2 = new x({ x: (D3.xmax - D3.xmin) / r7, y: (D3.ymax - D3.ymin) / i5, spatialReference: S3 }), j6 = x7 ? { BandProperties: x7.bandProperties, DataType: x7.dataType } : {};
    let B3 = null;
    const L5 = E2(e3[0], "PHOTOMETRICINTERPRETATION"), A = F(e3[0], "COLORMAP");
    if (L5 <= 3 && (A == null ? void 0 : A.length) > 3 && A.length % 3 == 0) {
      B3 = [];
      const e4 = A.length / 3;
      for (let t7 = 0; t7 < e4; t7++)
        B3.push([t7, A[t7] >>> 8, A[t7 + e4] >>> 8, A[t7 + 2 * e4] >>> 8]);
    }
    const z = new m2({ width: r7, height: i5, bandCount: f8, pixelType: u7, pixelSize: O2, storageInfo: k4, spatialReference: S3, isPseudoSpatialReference: v5, keyProperties: j6, extent: D3, colormap: B3, statistics: x7 ? x7.statistics : null });
    return (T4 == null ? void 0 : T4.length) && (z.nativeExtent = new M({ xmin: -0.5, ymin: 0.5 - i5, xmax: r7 - 0.5, ymax: 0.5, spatialReference: S3 }), z.transform = new y4({ polynomialOrder: 1, forwardCoefficients: [T4[2] + T4[0] / 2, T4[5] - T4[3] / 2, T4[0], T4[3], -T4[1], -T4[4]] }), z.extent = z.transform.forwardTransform(z.nativeExtent), z.pixelSize = new x({ x: (D3.xmax - D3.xmin) / r7, y: (D3.ymax - D3.ymin) / i5, spatialReference: S3 }), k4.origin.x = -0.5, k4.origin.y = 0.5), { imageInfo: t6, rasterInfo: z };
  }
  _processPAMInfo(e3, t6) {
    if (t6.statistics = e3.statistics ?? t6.statistics, t6.histograms = e3.histograms, e3.histograms && null == t6.statistics && (t6.statistics = g(e3.histograms)), e3.transform && null == t6.transform) {
      t6.transform = e3.transform, t6.nativeExtent = t6.extent;
      const r7 = t6.transform.forwardTransform(t6.nativeExtent);
      t6.pixelSize = new x({ x: (r7.xmax - r7.xmin) / t6.width, y: (r7.ymax - r7.ymin) / t6.height, spatialReference: t6.spatialReference }), t6.extent = r7;
    }
    t6.isPseudoSpatialReference && e3.spatialReference && (t6.spatialReference = e3.spatialReference, t6.extent.spatialReference = t6.nativeExtent.spatialReference = t6.storageInfo.origin.spatialReference = t6.spatialReference);
  }
  async _readIFDs(e3, t6, r7, i5, s5, a7 = 4, n8) {
    if (!i5)
      return null;
    if (i5 >= t6.byteLength || i5 < 0) {
      t6 = (await this.request(this.url, { range: { from: i5 + s5, to: i5 + s5 + this._bufferSize }, responseType: "array-buffer", signal: n8 })).data, s5 = i5 + s5, i5 = 0;
    }
    const o7 = await this._readIFD(t6, r7, i5, s5, n.TIFF_TAGS, a7, n8);
    if (e3.push(o7.ifd), !o7.nextIFD)
      return null;
    await this._readIFDs(e3, t6, r7, o7.nextIFD - s5, s5, a7, n8);
  }
  async _readIFD(e3, r7, i5, s5, a7 = n.TIFF_TAGS, n8 = 4, o7) {
    var _a, _b;
    if (!e3)
      return null;
    const f8 = B(e3, r7, i5, s5, a7, n8);
    if (f8.success) {
      const i6 = [];
      if ((_a = f8.ifd) == null ? void 0 : _a.forEach((e4) => {
        e4.values || i6.push(e4);
      }), i6.length > 0) {
        const a8 = i6.map((e4) => e4.offlineOffsetSize).filter(R), n9 = Math.min.apply(null, a8.map((e4) => e4[0]));
        if (Math.min.apply(null, a8.map((e4) => e4[0] + e4[1])) - n9 <= this._bufferSize) {
          const { data: t6 } = await this.request(this.url, { range: { from: n9, to: n9 + this._bufferSize }, responseType: "array-buffer", signal: o7 });
          e3 = t6, s5 = n9, i6.forEach((t7) => L2(e3, r7, t7, s5));
        }
      }
      if ((_b = f8.ifd) == null ? void 0 : _b.has("GEOKEYDIRECTORY")) {
        const t6 = f8.ifd.get("GEOKEYDIRECTORY"), i7 = t6 == null ? void 0 : t6.values;
        if (i7 && i7.length > 4) {
          const a8 = i7[0] + "." + i7[1] + "." + i7[2], n9 = await this._readIFD(e3, r7, t6.valueOffset + 6 - s5, s5, n.GEO_KEYS, 2, o7);
          t6.data = n9.ifd, t6.data && t6.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a8] });
        }
      }
      return f8;
    }
    if (f8.requiredBufferSize && f8.requiredBufferSize !== e3.byteLength) {
      const t6 = await this.request(this.url, { range: { from: s5, to: s5 + f8.requiredBufferSize + 4 }, responseType: "array-buffer", signal: o7 });
      return (e3 = t6.data).byteLength < f8.requiredBufferSize ? null : this._readIFD(e3, r7, 0, s5, n.TIFF_TAGS, 4, o7);
    }
  }
  async _fetchRawTiffTile(e3, t6, r7, i5, s5 = {}) {
    const a7 = this._getTileLocation(e3, t6, r7, i5);
    if (!a7)
      return null;
    const { ranges: n8, actualTileWidth: o7, actualTileHeight: f8, ifd: l7 } = a7, u7 = n8.map((e4) => this.request(this.url, { range: e4, responseType: "array-buffer", signal: s5.signal })), c11 = await Promise.all(u7), p6 = c11.map((e4) => e4.data.byteLength).reduce((e4, t7) => e4 + t7), h9 = 1 === c11.length ? c11[0].data : new ArrayBuffer(p6), m7 = [0], d7 = [0];
    if (c11.length > 1) {
      const e4 = new Uint8Array(h9);
      for (let t7 = 0, r8 = 0; t7 < c11.length; t7++) {
        const i6 = c11[t7].data;
        e4.set(new Uint8Array(i6), r8), m7[t7] = r8, r8 += i6.byteLength, d7[t7] = i6.byteLength;
      }
    }
    const { blockWidth: y7, blockHeight: g5 } = this.getBlockWidthHeight(e3), T4 = await this.decodePixelBlock(h9, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l7, offsets: m7, sizes: d7 }, width: y7, height: g5, planes: null, pixelType: null });
    if (null == T4)
      return null;
    let x7, I3, w3;
    if (o7 !== y7 || f8 !== g5) {
      let e4 = T4.mask;
      if (e4)
        for (x7 = 0; x7 < g5; x7++)
          if (w3 = x7 * y7, x7 < f8)
            for (I3 = o7; I3 < y7; I3++)
              e4[w3 + I3] = 0;
          else
            for (I3 = 0; I3 < y7; I3++)
              e4[w3 + I3] = 0;
      else
        for (e4 = new Uint8Array(y7 * g5), T4.mask = e4, x7 = 0; x7 < f8; x7++)
          for (w3 = x7 * y7, I3 = 0; I3 < o7; I3++)
            e4[w3 + I3] = 1;
    }
    return T4;
  }
  _getTileLocation(e3, t6, r7, i5 = false) {
    const { firstPyramidLevel: s5, blockBoundary: a7 } = this.rasterInfo.storageInfo, n8 = 0 === e3 ? 0 : e3 - (s5 - 1), { _headerInfo: o7 } = this;
    if (!o7)
      return null;
    const f8 = i5 ? o7.maskIFDs[n8] : 0 === n8 ? o7 == null ? void 0 : o7.ifds[0] : o7 == null ? void 0 : o7.pyramidIFDs[n8 - 1];
    if (!f8)
      return null;
    const l7 = D(f8, o7), u7 = F(f8, "TILEOFFSETS");
    if (void 0 === u7)
      return null;
    const c11 = F(f8, "TILEBYTECOUNTS"), { minRow: p6, minCol: h9, maxRow: m7, maxCol: d7 } = a7[n8];
    if (t6 > m7 || r7 > d7 || t6 < p6 || r7 < h9)
      return null;
    const y7 = E2(f8, "IMAGEWIDTH"), T4 = E2(f8, "IMAGELENGTH"), x7 = E2(f8, "TILEWIDTH"), I3 = E2(f8, "TILELENGTH"), w3 = [];
    if (l7) {
      const { bandCount: e4 } = this.rasterInfo;
      for (let i6 = 0; i6 < e4; i6++) {
        const e5 = i6 * (m7 + 1) * (d7 + 1) + t6 * (d7 + 1) + r7;
        w3[i6] = { from: u7[e5], to: u7[e5] + c11[e5] - 1 };
      }
    } else {
      const e4 = t6 * (d7 + 1) + r7;
      w3.push({ from: u7[e4], to: u7[e4] + c11[e4] - 1 });
    }
    for (let g5 = 0; g5 < w3.length; g5++)
      if (null == w3[g5].from || !w3[g5].to)
        return null;
    return { ranges: w3, ifd: f8, actualTileWidth: r7 === d7 && y7 % x7 || x7, actualTileHeight: t6 === m7 && T4 % I3 || I3 };
  }
  async _fetchAuxiliaryMetaData(e3) {
    try {
      const { data: t6 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3 == null ? void 0 : e3.signal });
      return p5(t6);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e3) {
    try {
      const { data: t6 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e3 == null ? void 0 : e3.signal }), r7 = r6.parse(t6);
      return (r7 == null ? void 0 : r7.recordSet) ? d2.fromJSON(r7.recordSet) : null;
    } catch {
      return null;
    }
  }
};
e([y()], S2.prototype, "_files", void 0), e([y()], S2.prototype, "_headerInfo", void 0), e([y()], S2.prototype, "_bufferSize", void 0), e([y({ type: String, json: { write: true } })], S2.prototype, "datasetFormat", void 0), S2 = e([a("esri.layers.support.rasterDatasets.TIFFRaster")], S2);
var v4 = S2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var c10 = /* @__PURE__ */ new Map();
c10.set("CRF", { desc: "Cloud Raster Format", constructor: S }), c10.set("MRF", { desc: "Meta Raster Format", constructor: I2 }), c10.set("TIFF", { desc: "GeoTIFF", constructor: v4 }), c10.set("RasterTileServer", { desc: "Raster Tile Server", constructor: v3 }), c10.set("JPG", { desc: "JPG Raster Format", constructor: d6 }), c10.set("PNG", { desc: "PNG Raster Format", constructor: d6 }), c10.set("GIF", { desc: "GIF Raster Format", constructor: d6 }), c10.set("BMP", { desc: "BMP Raster Format", constructor: d6 });
var n7 = class {
  static get supportedFormats() {
    const t6 = /* @__PURE__ */ new Set();
    return c10.forEach((e3, r7) => t6.add(r7)), t6;
  }
  static async open(e3) {
    const { url: r7, ioConfig: s5, sourceJSON: o7 } = e3;
    let a7 = e3.datasetFormat;
    null == a7 && r7.lastIndexOf(".") && (a7 = r7.slice(r7.lastIndexOf(".") + 1).toUpperCase()), "OVR" === a7 || "TIF" === a7 ? a7 = "TIFF" : "JPG" !== a7 && "JPEG" !== a7 && "JFIF" !== a7 || (a7 = "JPG"), r7.toLowerCase().includes("/imageserver") && !r7.toLowerCase().includes("/wcsserver") && (a7 = "RasterTileServer");
    const n8 = { url: r7, sourceJSON: o7, datasetFormat: a7, ioConfig: s5 ?? { bandIds: null, sampling: null } };
    let l7, i5;
    if (a7 && this.supportedFormats.has(a7)) {
      if ("CRF" === a7 && !(s5 == null ? void 0 : s5.enableCRF))
        throw new s2("rasterfactory:open", `cannot open raster: ${r7}`);
      return l7 = c10.get(a7).constructor, i5 = new l7(n8), await i5.open({ signal: e3.signal }), i5;
    }
    if (a7)
      throw new s2("rasterfactory:open", "not a supported format " + a7);
    const u7 = Array.from(c10.keys());
    let F2 = 0;
    const m7 = () => (a7 = u7[F2++], a7 && ("CRF" !== a7 || (s5 == null ? void 0 : s5.enableCRF)) ? (l7 = c10.get(a7).constructor, i5 = new l7(n8), i5.open({ signal: e3.signal }).then(() => i5).catch(() => m7())) : null);
    return m7();
  }
  static register(t6, e3, r7) {
    c10.has(t6.toUpperCase()) || c10.set(t6.toUpperCase(), { desc: e3, constructor: r7 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var _3 = class extends a2(t(c3(j3(o3(V3(a3(l4(p(O(b)))))))))) {
  constructor(...e3) {
    super(...e3), this._primaryRasters = [], this.bandIds = null, this.interpolation = null, this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null;
  }
  normalizeCtorArgs(e3, r7) {
    return "string" == typeof e3 ? { url: e3, ...r7 } : e3;
  }
  load(e3) {
    const r7 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e3).catch(f).then(() => this._openRaster(r7))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a;
    const e3 = [new y2({ name: "Raster.ServicePixelValue", alias: "Pixel Value", domain: null, editable: false, length: 50, type: "string" }), new y2({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Pixel Value", domain: null, editable: false, length: 50, type: "string" })], { rasterInfo: r7 } = this, t6 = r7 == null ? void 0 : r7.attributeTable, s5 = null != t6 ? t6.fields : null, i5 = "Raster.";
    if (s5) {
      const r8 = s5.filter((e4) => "oid" !== e4.type && "value" !== e4.name.toLowerCase()).map((e4) => {
        const r9 = e4.clone();
        return r9.name = i5 + e4.name, r9;
      });
      e3.push(...r8);
    }
    const o7 = r7 == null ? void 0 : r7.dataType, a7 = r7 == null ? void 0 : r7.multidimensionalInfo;
    if (("vector-magdir" === o7 || "vector-uv" === o7) && null != a7) {
      const r8 = (_a = a7.variables[0].unit) == null ? void 0 : _a.trim(), t7 = "Magnitude" + (r8 ? ` (${r8})` : "");
      e3.push(new y2({ name: "Raster.Magnitude", alias: t7, domain: null, editable: false, type: "double" })), e3.push(new y2({ name: "Raster.Direction", alias: "Direction (°)", domain: null, editable: false, type: "double" }));
    }
    return e3;
  }
  createPopupTemplate(e3) {
    const { rasterFields: r7 } = this, t6 = new Set(r7.map(({ name: e4 }) => e4).filter((e4) => "raster.servicepixelvalue.raw" !== e4.toLowerCase()));
    return p3({ fields: r7, title: this.title }, { ...e3, visibleFieldNames: t6 });
  }
  async generateRasterInfo(e3, r7) {
    var _a;
    if (!(e3 = v(N2, e3)))
      return this.rasterInfo;
    try {
      const t6 = { raster: this._primaryRasters[0] };
      this._primaryRasters.length > 1 && this._primaryRasters.forEach((e4) => t6[e4.url] = e4);
      const s5 = _(((_a = e3.functionDefinition) == null ? void 0 : _a.toJSON()) ?? e3.toJSON(), t6), i5 = new c7({ rasterFunction: s5 });
      return await i5.open(r7), i5.rasterInfo;
    } catch (s5) {
      if (s5 instanceof s2)
        throw s5;
      throw new s2("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  write(e3, r7) {
    const s5 = this._primaryRasters[0] ?? this.raster;
    if (this.loaded ? "RasterTileServer" === s5.datasetFormat && ("Raster" === s5.tileType || "Map" === s5.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url))
      return super.write(e3, r7);
    if (r7 && r7.messages) {
      const e4 = `${r7.origin}/${r7.layerContainerType || "operational-layers"}`;
      r7.messages.push(new s2("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e4}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e3) {
    var _a;
    let r7 = false;
    if (this.raster)
      this.raster.rasterInfo || await this.raster.open(), "Function" === this.raster.datasetFormat ? (r7 = true, this._primaryRasters = this.raster.primaryRasters.rasters) : this._primaryRasters = [this.raster], this.url = this.raster.url;
    else {
      const { rasterFunction: r8 } = this, i6 = [this.url];
      r8 && h2(r8.toJSON(), i6);
      const a7 = await Promise.all(i6.map((r9) => n7.open({ url: r9, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: e3 }))), n8 = a7.findIndex((e4) => null == e4);
      if (n8 > -1)
        throw new s2("imagery-tile-layer:open", `cannot open raster: ${i6[n8]}`);
      if (this._primaryRasters = a7, r8) {
        const e4 = { raster: this._primaryRasters[0] };
        this._primaryRasters.length > 1 && this._primaryRasters.forEach((r9) => e4[r9.url] = r9);
        const i7 = _(((_a = r8.functionDefinition) == null ? void 0 : _a.toJSON()) ?? r8.toJSON(), e4), n9 = new c7({ rasterFunction: i7 });
        try {
          await n9.open(), this.raster = n9;
        } catch (o7) {
          const e5 = s.getLogger(this);
          o7 instanceof s2 && e5.error("imagery-tile-layer:open", o7.message), e5.warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = a7[0];
        }
      } else
        this.raster = a7[0];
    }
    const i5 = this.raster.rasterInfo;
    if (!i5)
      throw new s2("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("rasterInfo", r7 ? i5 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", i5.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e4 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e4, { origin: "service" });
    } else
      this.read({ tileInfo: this.rasterInfo.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(l2(() => this.customParameters, (e4) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e4);
    }));
  }
};
e([y()], _3.prototype, "_primaryRasters", void 0), e([y({ type: [T], json: { write: { overridePolicy() {
  var _a;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== ((_a = this.bandIds) == null ? void 0 : _a.join(",")) };
} } } })], _3.prototype, "bandIds", void 0), e([y({ json: { write: { overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
} } } }), o2(a4)], _3.prototype, "interpolation", void 0), e([y(c2)], _3.prototype, "legendEnabled", void 0), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], _3.prototype, "isReference", void 0), e([y({ type: ["show", "hide"] })], _3.prototype, "listMode", void 0), e([y({ json: { read: true, write: true } })], _3.prototype, "blendMode", void 0), e([y()], _3.prototype, "sourceJSON", void 0), e([y({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], _3.prototype, "version", void 0), e([y({ readOnly: true, json: { read: false } })], _3.prototype, "type", void 0), e([y({ type: ["ArcGISTiledImageServiceLayer"] })], _3.prototype, "operationalLayerType", void 0), e([y({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, r7) => !r7.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e3, r7, t6) {
  r7[t6] = !e3;
} } } })], _3.prototype, "popupEnabled", void 0), e([y({ type: k3, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], _3.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], _3.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, type: [y2] })], _3.prototype, "fields", void 0), e([y({ readOnly: true, type: [y2] })], _3.prototype, "rasterFields", null), _3 = e([a("esri.layers.ImageryTileLayer")], _3);
var J2 = _3;
export {
  J2 as default
};
//# sourceMappingURL=ImageryTileLayer-ELB7F2AD.js.map
