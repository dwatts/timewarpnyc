import {
  i as i2,
  o as o2
} from "./chunk-AEMRJSQ4.js";
import "./chunk-7DIOPW5T.js";
import "./chunk-3W7W7IYY.js";
import {
  l2,
  u
} from "./chunk-G5CIXSEF.js";
import "./chunk-VIDC736D.js";
import {
  a as a4
} from "./chunk-S2L2EMCY.js";
import {
  m as m3
} from "./chunk-KGLSZSEH.js";
import {
  i,
  n,
  r
} from "./chunk-7VM4SGAK.js";
import {
  m as m2
} from "./chunk-RMQ3PJIC.js";
import "./chunk-6OVHX5ZO.js";
import "./chunk-3LR4MDXK.js";
import {
  ee
} from "./chunk-V7IVNH7O.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-O2Q4W74O.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-PVUG2RDQ.js";
import "./chunk-J3HE7QNA.js";
import "./chunk-GRB6LNZN.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-HSZYWTXA.js";
import "./chunk-YZ24SAPZ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-A47VN5MA.js";
import "./chunk-6YRYWMPZ.js";
import {
  N
} from "./chunk-KKDPZLGI.js";
import "./chunk-XTOI3E3Y.js";
import "./chunk-RSPVLZNN.js";
import "./chunk-MXVQCJ4K.js";
import "./chunk-G4LSNP77.js";
import "./chunk-S5RIUWET.js";
import "./chunk-MNDNZJD5.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-CUZNACFZ.js";
import "./chunk-ZHUFARKQ.js";
import {
  rt
} from "./chunk-ICEO3WMK.js";
import "./chunk-WTKN55TU.js";
import {
  t
} from "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-L3FCQBVC.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-BFZI4PK4.js";
import "./chunk-OHH3UAUS.js";
import "./chunk-E2PV5YTZ.js";
import "./chunk-GLVTFP5O.js";
import {
  Cn,
  Rn,
  nn
} from "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-WIQR3T32.js";
import "./chunk-C2EHS6UI.js";
import {
  d
} from "./chunk-DR3XNW4L.js";
import {
  a as a3
} from "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-ZUBHLDU6.js";
import "./chunk-C3PCK5WU.js";
import "./chunk-HE256ZWN.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-3ESTI2X4.js";
import "./chunk-YK2WEG7V.js";
import "./chunk-W3WHCGIQ.js";
import {
  a as a2,
  h,
  l
} from "./chunk-HPWZ2OON.js";
import "./chunk-5HSVWQOA.js";
import "./chunk-C2BBLDPU.js";
import "./chunk-GWA3PLGA.js";
import "./chunk-FXWSVUF2.js";
import "./chunk-CNS4YGGN.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import {
  o
} from "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-UNJDKTFU.js";
import "./chunk-DH42JQZX.js";
import "./chunk-674HAVOZ.js";
import "./chunk-MHGDFNBE.js";
import "./chunk-J2V5CZSS.js";
import "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import {
  j
} from "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  m,
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  P,
  p2 as p,
  s2 as s
} from "./chunk-UYRCWUYQ.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  z
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var I = "graphics-collections";
var O = class extends a3(m) {
  get updating() {
    return this.updatingHandles.updating;
  }
  get _hasZ() {
    const e2 = this.view;
    return null != e2 && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e2 } = this, { layer: t2 } = this.layerSource, s2 = null != e2 && "3d" === e2.type;
    if (!s2 || "map-notes" === t2.type)
      return i();
    const o3 = async (s3, o4) => (await p(e2.whenLayerView(t2), o4)).elevationAlignPointsInFeatures(s3, o4);
    return i(s2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: o3, spatialReference: e2.spatialReference });
  }
  get _snappingElevationFilter() {
    const { view: e2 } = this, t2 = null != e2 && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
    return r(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e2 } = this, { layer: t2 } = this.layerSource, s2 = null != e2 && "3d" === e2.type, o3 = this._extrudedPolygonSymbolsCount > 0;
    return s2 && "map-notes" !== t2.type && o3 ? n(o3, async (s3, o4) => {
      const r2 = await e2.whenLayerView(t2);
      return s(o4), r2.queryForSymbologySnapping({ candidates: s3, spatialReference: e2.spatialReference }, o4);
    }) : n();
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0;
  }
  destroy() {
    for (const e2 of this._pendingAdds)
      e2.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e2) => this._destroySource(e2));
  }
  initialize() {
    this.updatingHandles.add(() => this.getGraphicsLayers(), (e3) => {
      this.updatingHandles.removeHandles(I);
      for (const t3 of e3)
        this._addMany(t3.graphics.toArray()), this.handles.add([t3.on("graphic-update", (e4) => this._onGraphicUpdate(e4)), this.updatingHandles.addOnCollectionChange(() => t3.graphics, (e4) => this._onGraphicsChanged(e4))], I);
    }, h);
    const { view: e2 } = this, { layer: t2 } = this.layerSource;
    null != e2 && "3d" === e2.type && "map-notes" !== t2.type && this.addHandles([e2.elevationProvider.on("elevation-change", ({ context: e3 }) => {
      m3(e3, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), l(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), h), a2(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e2, t2) {
    const { point: s2 } = e2, o3 = await P(this._mapSources((s3) => this._fetchCandidatesForSource(s3, e2, t2)));
    s(t2);
    const r2 = this._getGroundElevation, a5 = o3.flat().map((e3) => i2(e3, r2));
    return u(s2, a5), a5;
  }
  get _getGroundElevation() {
    return o2(this.view);
  }
  async _fetchCandidatesForSource(e2, t2, s2) {
    var _a;
    const o3 = l2(t2, ((_a = this.view) == null ? void 0 : _a.type) ?? "2d"), r2 = await e2.queryEngine.executeQueryForSnapping(o3, s2);
    s(s2);
    const i3 = await this._snappingElevationAligner.alignCandidates(r2.candidates, s2);
    s(s2);
    const a5 = await this._symbologySnappingFetcher.fetch(i3, s2);
    s(s2);
    const l3 = 0 === a5.length ? i3 : [...i3, ...a5];
    return this._snappingElevationFilter.filter(o3, l3);
  }
  refresh() {
  }
  _onGraphicUpdate(e2) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e2.graphic)))
      switch (e2.property) {
        case "geometry":
        case "visible":
          this._remove(e2.graphic), this._addMany([e2.graphic]);
      }
  }
  _onGraphicsChanged(e2) {
    for (const t2 of e2.removed)
      this._remove(t2);
    this._addMany(e2.added);
  }
  _addMany(e2) {
    const t2 = [], s2 = /* @__PURE__ */ new Map();
    for (const o3 of e2)
      null != o3.geometry && (this._needsInitializeProjection(o3.geometry.spatialReference) ? (t2.push(o3.geometry.spatialReference), s2.set(o3.uid, o3)) : this._add(o3));
    this._createPendingAdd(t2, s2);
  }
  _createPendingAdd(e2, t2) {
    if (!e2.length)
      return;
    const r2 = d(async (s2) => {
      await Rn(e2.map((e3) => ({ source: e3, dest: this.spatialReference })), { signal: s2 }), this._markLoadedSpatialReferences(e2);
      for (const [, e3] of t2)
        this._add(e3);
    });
    this.updatingHandles.addPromise(r2.promise);
    const i3 = { task: r2, graphics: t2 }, n2 = () => z(this._pendingAdds, i3);
    r2.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e2) {
    for (const t2 of e2)
      null != t2.wkid && this._loadedWkids.add(t2.wkid), null != t2.wkt && this._loadedWkts.add(t2.wkt);
  }
  _add(e2) {
    if (null == e2.geometry || !e2.visible)
      return;
    let t2 = e2.geometry;
    if ("mesh" === t2.type)
      return;
    "extent" === t2.type && (t2 = j.fromExtent(t2));
    const s2 = this._ensureSource(t2.type);
    if (null == s2)
      return;
    const o3 = this._createOptimizedFeature(e2.uid, t2);
    null != o3 && (s2.featureStore.add(o3), N(e2.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e2) {
    return (null == e2.wkid || !this._loadedWkids.has(e2.wkid)) && ((null == e2.wkt || !this._loadedWkts.has(e2.wkt)) && !Cn(e2, this.spatialReference));
  }
  _createOptimizedFeature(e2, t2) {
    const s2 = nn(a4(t2), this.spatialReference);
    if (!s2)
      return null;
    const o3 = this._ensureGeometryHasZ(s2), r2 = rt(o3, this._hasZ, false);
    return new t(r2, { [U]: e2 }, null, e2);
  }
  _ensureGeometryHasZ(e2) {
    if (!this._hasZ)
      return e2;
    const t2 = (e3) => {
      for (; e3.length < 3; )
        e3.push(0);
    }, s2 = e2.clone();
    switch (s2.hasZ = true, s2.type) {
      case "point":
        s2.z = s2.z ?? 0;
        break;
      case "multipoint":
        s2.points.forEach(t2);
        break;
      case "polyline":
        s2.paths.forEach((e3) => e3.forEach(t2));
        break;
      case "polygon":
        s2.rings.forEach((e3) => e3.forEach(t2));
    }
    return s2;
  }
  _ensureSource(e2) {
    const t2 = this._sources[e2];
    if (null != t2)
      return t2;
    const s2 = this._createSource(e2);
    return this._sources[e2] = s2, s2;
  }
  _createSource(e2) {
    const t2 = o.toJSON(e2), s2 = this._hasZ, o3 = new m2({ geometryType: t2, hasZ: s2, hasM: false });
    return { featureStore: o3, queryEngine: new ee({ featureStore: o3, fields: [{ name: U, type: "esriFieldTypeOID", alias: U }], geometryType: t2, hasM: false, hasZ: s2, objectIdField: U, spatialReference: this.spatialReference, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e2 };
  }
  _remove(e2) {
    this._mapSources((t2) => this._removeFromSource(t2, e2));
    for (const t2 of this._pendingAdds)
      t2.graphics.delete(e2.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e2, t2) {
    const s2 = t2.uid;
    e2.featureStore.has(s2) && (e2.featureStore.removeById(t2.uid), N(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e2) {
    e2.queryEngine.destroy(), this._sources[e2.type] = null;
  }
  _mapSources(e2) {
    const { point: t2, polygon: s2, polyline: o3, multipoint: r2 } = this._sources, i3 = [];
    return null != t2 && i3.push(e2(t2)), null != s2 && i3.push(e2(s2)), null != o3 && i3.push(e2(o3)), null != r2 && i3.push(e2(r2)), i3;
  }
};
e([y()], O.prototype, "getGraphicsLayers", void 0), e([y({ constructOnly: true })], O.prototype, "layerSource", void 0), e([y({ constructOnly: true })], O.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], O.prototype, "view", void 0), e([y({ readOnly: true })], O.prototype, "updating", null), e([y({ readOnly: true })], O.prototype, "availability", void 0), e([y()], O.prototype, "_hasZ", null), e([y()], O.prototype, "_snappingElevationAligner", null), e([y()], O.prototype, "_snappingElevationFilter", null), e([y()], O.prototype, "_symbologySnappingFetcher", null), e([y()], O.prototype, "_extrudedPolygonSymbolsCount", void 0), e([y()], O.prototype, "_getGroundElevation", null), O = e([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O);
var U = "OBJECTID";
export {
  O as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-KR7TV4SN.js.map
