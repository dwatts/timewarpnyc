import {
  i
} from "./chunk-V3CNLYUD.js";
import {
  M,
  f as f2,
  p as p2
} from "./chunk-T35GN7EL.js";
import {
  f,
  g,
  p,
  x2 as x
} from "./chunk-7U6V6KY2.js";
import {
  r
} from "./chunk-NFY4EX6G.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  s
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t(t4) {
  const n2 = [];
  for (t4.reset(); t4.nextPath(); ) {
    const e4 = [];
    for (; t4.nextPoint(); )
      e4.push([t4.x, t4.y]);
    n2.push(e4);
  }
  return t4.reset(), n2;
}
function n(t4) {
  const n2 = [];
  for (; t4.nextPoint(); )
    n2.push([t4.x, t4.y]);
  return t4.seekPathStart(), n2;
}

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function r2(t4, n2) {
  const e4 = n2[0] - t4[0], r5 = n2[1] - t4[1];
  if (t4.length > 2 && n2.length > 2) {
    const i5 = t4[2] - n2[2];
    return Math.sqrt(e4 * e4 + r5 * r5 + i5 * i5);
  }
  return Math.sqrt(e4 * e4 + r5 * r5);
}
function i2(t4, n2, e4) {
  const r5 = t4[0] + e4 * (n2[0] - t4[0]), i5 = t4[1] + e4 * (n2[1] - t4[1]);
  return t4.length > 2 && n2.length > 2 ? [r5, i5, t4[2] + e4 * (n2[2] - t4[2])] : [r5, i5];
}
function o(t4, n2, e4, r5) {
  const [i5, o5] = n2, [s6, f7] = e4[r5], [l5, u5] = e4[r5 + 1], c5 = l5 - s6, h6 = u5 - f7, a6 = c5 * c5 + h6 * h6, p3 = (i5 - s6) * c5 + (o5 - f7) * h6, y4 = Math.min(1, Math.max(0, p3 / a6));
  return t4[0] = s6 + c5 * y4, t4[1] = f7 + h6 * y4, t4;
}
function s2(t4, n2, e4) {
  let r5, i5, o5, s6, l5 = false, u5 = 1 / 0;
  for (e4.reset(); e4.nextPath(); )
    if (e4.nextPoint())
      for (r5 = e4.x, i5 = e4.y; e4.nextPoint(); )
        o5 = e4.x, s6 = e4.y, i5 > n2 != s6 > n2 && t4 < (o5 - r5) * (n2 - i5) / (s6 - i5) + r5 && (l5 = !l5), u5 = Math.min(u5, f3(t4, n2, r5, i5, o5, s6)), r5 = o5, i5 = s6;
  return 0 === u5 ? 0 : (l5 ? 1 : -1) * Math.sqrt(u5);
}
function f3(t4, n2, e4, r5, i5, o5) {
  let s6 = e4, f7 = r5, l5 = i5 - s6, u5 = o5 - f7;
  if (0 !== l5 || 0 !== u5) {
    const e5 = ((t4 - s6) * l5 + (n2 - f7) * u5) / (l5 * l5 + u5 * u5);
    e5 > 1 ? (s6 = i5, f7 = o5) : e5 > 0 && (s6 += l5 * e5, f7 += u5 * e5);
  }
  return l5 = t4 - s6, u5 = n2 - f7, l5 * l5 + u5 * u5;
}
function l(t4, n2) {
  return i2(t4, n2, 0.5);
}
function u(t4) {
  const n2 = t4.length;
  let e4 = 0;
  for (let i5 = 0; i5 < n2 - 1; ++i5)
    e4 += r2(t4[i5], t4[i5 + 1]);
  return e4;
}
function c(t4, n2) {
  if (n2 <= 0)
    return t4[0];
  const e4 = t4.length;
  let o5 = 0;
  for (let s6 = 0; s6 < e4 - 1; ++s6) {
    const e5 = r2(t4[s6], t4[s6 + 1]);
    if (n2 - o5 < e5) {
      const r5 = (n2 - o5) / e5;
      return i2(t4[s6], t4[s6 + 1], r5);
    }
    o5 += e5;
  }
  return t4[e4 - 1];
}
function h(t4, n2, e4) {
  const r5 = t4.length;
  let i5 = 0, o5 = 0, s6 = 0;
  for (let f7 = 0; f7 < r5; f7++) {
    const l5 = t4[f7], u5 = t4[(f7 + 1) % r5];
    let c5 = 2;
    i5 += l5[0] * u5[1] - u5[0] * l5[1], l5.length > 2 && u5.length > 2 && e4 && (o5 += l5[0] * u5[2] - u5[0] * l5[2], c5 = 3), l5.length > c5 && u5.length > c5 && n2 && (s6 += l5[0] * u5[c5] - u5[0] * l5[c5]);
  }
  return i5 <= 0 && o5 <= 0 && s6 <= 0;
}
function a3(n2) {
  const e4 = n2.length;
  return e4 > 2 && s(n2[0], n2[e4 - 1]);
}
function y2(t4) {
  if ("rings" in t4)
    for (const n2 of t4.rings)
      a3(n2) || n2.push(n2[0].slice());
}
function M2(t4) {
  if (!t4 || t4.length < 3)
    return 0;
  let n2 = 0;
  const e4 = t4.length - 1;
  for (let r5 = 0; r5 < e4; r5++)
    n2 += (t4[r5][0] - t4[r5 + 1][0]) * (t4[r5][1] + t4[r5 + 1][1]);
  return n2 += (t4[e4][0] - t4[0][0]) * (t4[e4][1] + t4[0][1]), -0.5 * n2;
}
function P(t4) {
  if (!t4 || t4.numPoints < 3)
    return 0;
  let n2, e4, r5 = 0;
  if (t4.seekPathStart(), !t4.nextPoint())
    return 0;
  n2 = t4.x, e4 = t4.y;
  const i5 = n2, o5 = e4;
  for (; t4.nextPoint(); )
    r5 += (n2 - t4.x) * (e4 + t4.y), n2 = t4.x, e4 = t4.y;
  return r5 += (n2 - i5) * (e4 + o5), -0.5 * r5;
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function l2(t4) {
  return t4 ? t4.hasZ ? [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2, t4.zmax - t4.zmin / 2] : [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2] : null;
}
function o2(t4) {
  return t4 ? u2(t4.rings, t4.hasZ ?? false) : null;
}
function u2(t4, n2) {
  if (!t4 || !t4.length)
    return null;
  const e4 = [], r5 = [], l5 = n2 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o5 = 0, u5 = t4.length; o5 < u5; o5++) {
    const e5 = s3(t4[o5], n2, l5);
    e5 && r5.push(e5);
  }
  if (r5.sort((t5, e5) => {
    let r6 = t5[2] - e5[2];
    return 0 === r6 && n2 && (r6 = t5[4] - e5[4]), r6;
  }), r5.length && (e4[0] = r5[0][0], e4[1] = r5[0][1], n2 && (e4[2] = r5[0][3]), (e4[0] < l5[0] || e4[0] > l5[1] || e4[1] < l5[2] || e4[1] > l5[3] || n2 && (e4[2] < l5[4] || e4[2] > l5[5])) && (e4.length = 0)), !e4.length) {
    const r6 = t4[0] && t4[0].length ? I(t4[0], n2) : null;
    if (!r6)
      return null;
    e4[0] = r6[0], e4[1] = r6[1], n2 && r6.length > 2 && (e4[2] = r6[2]);
  }
  return e4;
}
function s3(t4, n2, e4) {
  let r5 = 0, l5 = 0, o5 = 0, u5 = 0, s6 = 0;
  const I2 = t4.length ? t4[0][0] : 0, i5 = t4.length ? t4[0][1] : 0, h6 = t4.length && n2 ? t4[0][2] : 0;
  for (let N2 = 0; N2 < t4.length; N2++) {
    const c6 = t4[N2], f7 = t4[(N2 + 1) % t4.length], [m4, x5, g3] = c6, P2 = m4 - I2, T = x5 - i5, [a6, E, y4] = f7, b = a6 - I2, F = E - i5, V = P2 * F - b * T;
    if (u5 += V, r5 += (P2 + b) * V, l5 += (T + F) * V, n2 && c6.length > 2 && f7.length > 2) {
      const t5 = g3 - h6, n3 = y4 - h6, e5 = P2 * n3 - b * t5;
      o5 += (t5 + n3) * e5, s6 += e5;
    }
    m4 < e4[0] && (e4[0] = m4), m4 > e4[1] && (e4[1] = m4), x5 < e4[2] && (e4[2] = x5), x5 > e4[3] && (e4[3] = x5), n2 && (g3 < e4[4] && (e4[4] = g3), g3 > e4[5] && (e4[5] = g3));
  }
  if (u5 > 0 && (u5 *= -1), s6 > 0 && (s6 *= -1), !u5)
    return null;
  u5 *= 0.5, s6 *= 0.5;
  const c5 = [r5 / (6 * u5) + I2, l5 / (6 * u5) + i5, u5];
  return n2 && (e4[4] === e4[5] || 0 === s6 ? (c5[3] = (e4[4] + e4[5]) / 2, c5[4] = 0) : (c5[3] = o5 / (6 * s6) + h6, c5[4] = s6)), c5;
}
function I(t4, r5) {
  const l5 = r5 ? [0, 0, 0] : [0, 0], o5 = r5 ? [0, 0, 0] : [0, 0];
  let u5 = 0, s6 = 0, I2 = 0, i5 = 0;
  for (let h6 = 0, c5 = t4.length; h6 < c5 - 1; h6++) {
    const c6 = t4[h6], N2 = t4[h6 + 1];
    if (c6 && N2) {
      l5[0] = c6[0], l5[1] = c6[1], o5[0] = N2[0], o5[1] = N2[1], r5 && c6.length > 2 && N2.length > 2 && (l5[2] = c6[2], o5[2] = N2[2]);
      const t5 = r2(l5, o5);
      if (t5) {
        u5 += t5;
        const n2 = l(c6, N2);
        s6 += t5 * n2[0], I2 += t5 * n2[1], r5 && n2.length > 2 && (i5 += t5 * n2[2]);
      }
    }
  }
  return u5 > 0 ? r5 ? [s6 / u5, I2 / u5, i5 / u5] : [s6 / u5, I2 / u5] : t4.length ? t4[0] : null;
}
function i3(n2) {
  const { hasZ: e4, numPaths: r5 } = n2;
  if (0 === r5)
    return null;
  const l5 = [], o5 = [], u5 = e4 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n2.reset(); n2.nextPath(); ) {
    const e5 = s3(n(n2), n2.hasZ, u5);
    e5 && o5.push(e5);
  }
  if (o5.sort((t4, n3) => {
    let r6 = t4[2] - n3[2];
    return 0 === r6 && e4 && (r6 = t4[4] - n3[4]), r6;
  }), o5.length && (l5[0] = o5[0][0], l5[1] = o5[0][1], e4 && (l5[2] = o5[0][3]), (l5[0] < u5[0] || l5[0] > u5[1] || l5[1] < u5[2] || l5[1] > u5[3] || e4 && (l5[2] < u5[4] || l5[2] > u5[5])) && (l5.length = 0)), !l5.length) {
    n2.reset(), n2.nextPath();
    const t4 = n2.numPoints ? h2(n2) : null;
    if (!t4)
      return null;
    l5[0] = t4[0], l5[1] = t4[1], e4 && t4.length > 2 && (l5[2] = t4[2]);
  }
  return l5;
}
function h2(t4) {
  const { hasZ: r5 } = t4, l5 = r5 ? [0, 0, 0] : [0, 0], o5 = r5 ? [0, 0, 0] : [0, 0];
  let u5 = 0, s6 = 0, I2 = 0, i5 = 0;
  if (t4.nextPoint()) {
    let h6 = t4.x, c5 = t4.y, N2 = t4.z;
    for (; t4.nextPoint(); ) {
      const f7 = t4.x, m4 = t4.y, x5 = t4.z;
      l5[0] = h6, l5[1] = c5, o5[0] = f7, o5[1] = m4, r5 && (l5[2] = N2, o5[2] = x5);
      const g3 = r2(l5, o5);
      if (g3) {
        u5 += g3;
        const t5 = l(l5, o5);
        s6 += g3 * t5[0], I2 += g3 * t5[1], r5 && t5.length > 2 && (i5 += g3 * t5[2]);
      }
      h6 = f7, c5 = m4, N2 = x5;
    }
  }
  return u5 > 0 ? r5 ? [s6 / u5, I2 / u5, i5 / u5] : [s6 / u5, I2 / u5] : t4.numPoints ? (t4.seekPathStart(), t4.nextPoint(), [t4.x, t4.y]) : null;
}
var c2 = 1e-6;
function N(t4) {
  let n2 = 0;
  for (t4.reset(); t4.nextPath(); )
    n2 += P(t4);
  if (n2 < c2) {
    const n3 = i3(t4);
    return n3 ? [n3[0], n3[1]] : null;
  }
  const e4 = [0, 0];
  if (t4.reset(), !t4.nextPath() || !t4.nextPoint())
    return null;
  const l5 = [t4.x, t4.y];
  for (t4.reset(); t4.nextPath(); )
    m(e4, l5, t4);
  return e4[0] *= 1 / n2, e4[1] *= 1 / n2, e4[0] += l5[0], e4[1] += l5[1], e4;
}
var f4 = 1 / 3;
function m(t4, n2, e4) {
  if (!t4 || !e4 || e4.numPoints < 3)
    return null;
  e4.nextPoint();
  const l5 = e4.x, o5 = e4.y;
  e4.nextPoint();
  let u5, s6 = e4.x - l5, I2 = e4.y - o5, i5 = 0, h6 = 0;
  for (; e4.nextPoint(); )
    i5 = e4.x - l5, h6 = e4.y - o5, u5 = 0.5 * f4 * (i5 * I2 - h6 * s6), t4[0] += u5 * (s6 + i5), t4[1] += u5 * (I2 + h6), s6 = i5, I2 = h6;
  const c5 = P(e4), N2 = [l5, o5];
  return N2[0] -= n2[0], N2[1] -= n2[1], N2[0] *= c5, N2[1] *= c5, t4[0] += N2[0], t4[1] += N2[1], t4;
}

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function t2(n2) {
  return void 0 !== n2.xmin && void 0 !== n2.ymin && void 0 !== n2.xmax && void 0 !== n2.ymax;
}
function i4(n2) {
  return void 0 !== n2.points;
}
function o3(n2) {
  return void 0 !== n2.x && void 0 !== n2.y;
}
function e2(n2) {
  return void 0 !== n2.paths;
}
function r3(n2) {
  return void 0 !== n2.rings;
}
function u3(n2) {
  function t4(t5, i5) {
    return null == t5 ? i5 : null == i5 ? t5 : n2(t5, i5);
  }
  return t4;
}
var l3 = u3(Math.min);
var h3 = u3(Math.max);
function a4(n2, u5) {
  return e2(u5) ? x2(n2, u5.paths, false, false) : r3(u5) ? x2(n2, u5.rings, false, false) : i4(u5) ? g2(n2, u5.points, false, false, false, false) : t2(u5) ? s4(n2, u5) : (o3(u5) && (n2[0] = u5.x, n2[1] = u5.y, n2[2] = u5.x, n2[3] = u5.y), n2);
}
function c3(t4) {
  let i5, o5, e4, r5;
  for (t4.reset(), i5 = e4 = 1 / 0, o5 = r5 = -1 / 0; t4.nextPath(); ) {
    const n2 = f5(t4);
    i5 = Math.min(n2[0], i5), e4 = Math.min(n2[1], e4), o5 = Math.max(n2[2], o5), r5 = Math.max(n2[3], r5);
  }
  return i([i5, e4, o5, r5]);
}
function f5(t4) {
  let i5, o5, e4, r5;
  for (i5 = e4 = 1 / 0, o5 = r5 = -1 / 0; t4.nextPoint(); )
    i5 = Math.min(t4.x, i5), e4 = Math.min(t4.y, e4), o5 = Math.max(t4.x, o5), r5 = Math.max(t4.y, r5);
  return i([i5, e4, o5, r5]);
}
function m2(n2, u5) {
  return e2(u5) ? x2(n2, u5.paths, true, false) : r3(u5) ? x2(n2, u5.rings, true, false) : i4(u5) ? g2(n2, u5.points, true, false, true, false) : t2(u5) ? s4(n2, u5, true, false, true, false) : (o3(u5) && (n2[0] = u5.x, n2[1] = u5.y, n2[2] = u5.z, n2[3] = u5.x, n2[4] = u5.y, n2[5] = u5.z), n2);
}
function x2(n2, t4, i5, o5) {
  const e4 = i5 ? 3 : 2;
  if (!t4.length || !t4[0].length)
    return null;
  let r5, u5, a6, c5, [f7, m4] = t4[0][0], [x5, s6] = t4[0][0];
  for (let g3 = 0; g3 < t4.length; g3++) {
    const n3 = t4[g3];
    for (let t5 = 0; t5 < n3.length; t5++) {
      const g4 = n3[t5], [y4, d4] = g4;
      if (f7 = l3(f7, y4), m4 = l3(m4, d4), x5 = h3(x5, y4), s6 = h3(s6, d4), i5 && g4.length > 2) {
        const n4 = g4[2];
        r5 = l3(r5, n4), u5 = h3(u5, n4);
      }
      if (o5 && g4.length > e4) {
        const n4 = g4[e4];
        a6 = l3(r5, n4), c5 = h3(u5, n4);
      }
    }
  }
  return i5 ? o5 ? (n2[0] = f7, n2[1] = m4, n2[2] = r5, n2[3] = a6, n2[4] = x5, n2[5] = s6, n2[6] = u5, n2[7] = c5, n2.length = 8, n2) : (n2[0] = f7, n2[1] = m4, n2[2] = r5, n2[3] = x5, n2[4] = s6, n2[5] = u5, n2.length = 6, n2) : o5 ? (n2[0] = f7, n2[1] = m4, n2[2] = a6, n2[3] = x5, n2[4] = s6, n2[5] = c5, n2.length = 6, n2) : (n2[0] = f7, n2[1] = m4, n2[2] = x5, n2[3] = s6, n2.length = 4, n2);
}
function s4(n2, t4, i5, o5, e4, r5) {
  const u5 = t4.xmin, l5 = t4.xmax, h6 = t4.ymin, a6 = t4.ymax;
  let c5 = t4.zmin, f7 = t4.zmax, m4 = t4.mmin, x5 = t4.mmax;
  return e4 ? (c5 = c5 || 0, f7 = f7 || 0, r5 ? (m4 = m4 || 0, x5 = x5 || 0, n2[0] = u5, n2[1] = h6, n2[2] = c5, n2[3] = m4, n2[4] = l5, n2[5] = a6, n2[6] = f7, n2[7] = x5, n2) : (n2[0] = u5, n2[1] = h6, n2[2] = c5, n2[3] = l5, n2[4] = a6, n2[5] = f7, n2)) : r5 ? (m4 = m4 || 0, x5 = x5 || 0, n2[0] = u5, n2[1] = h6, n2[2] = m4, n2[3] = l5, n2[4] = a6, n2[5] = x5, n2) : (n2[0] = u5, n2[1] = h6, n2[2] = l5, n2[3] = a6, n2);
}
function g2(n2, t4, i5, o5, e4, r5) {
  const u5 = i5 ? 3 : 2, a6 = o5 && r5, c5 = i5 && e4;
  if (!t4.length || !t4[0].length)
    return null;
  let f7, m4, x5, s6, [g3, y4] = t4[0], [d4, M3] = t4[0];
  for (let v2 = 0; v2 < t4.length; v2++) {
    const n3 = t4[v2], [i6, o6] = n3;
    if (g3 = l3(g3, i6), y4 = l3(y4, o6), d4 = h3(d4, i6), M3 = h3(M3, o6), c5 && n3.length > 2) {
      const t5 = n3[2];
      f7 = l3(f7, t5), m4 = h3(m4, t5);
    }
    if (a6 && n3.length > u5) {
      const t5 = n3[u5];
      x5 = l3(f7, t5), s6 = h3(m4, t5);
    }
  }
  return e4 ? (f7 = f7 || 0, m4 = m4 || 0, r5 ? (x5 = x5 || 0, s6 = s6 || 0, n2[0] = g3, n2[1] = y4, n2[2] = f7, n2[3] = x5, n2[4] = d4, n2[5] = M3, n2[6] = m4, n2[7] = s6, n2) : (n2[0] = g3, n2[1] = y4, n2[2] = f7, n2[3] = d4, n2[4] = M3, n2[5] = m4, n2)) : r5 ? (x5 = x5 || 0, s6 = s6 || 0, n2[0] = g3, n2[1] = y4, n2[2] = x5, n2[3] = d4, n2[4] = M3, n2[5] = s6, n2) : (n2[0] = g3, n2[1] = y4, n2[2] = d4, n2[3] = M3, n2);
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n2) {
  return void 0 !== n2.xmin && void 0 !== n2.ymin && void 0 !== n2.xmax && void 0 !== n2.ymax;
}
function u4(n2) {
  return void 0 !== n2.points;
}
function m3(n2) {
  return void 0 !== n2.x && void 0 !== n2.y;
}
function o4(n2) {
  return void 0 !== n2.paths;
}
function r4(n2) {
  return void 0 !== n2.rings;
}
var x3 = [];
function a5(n2, i5, t4, u5) {
  return { xmin: n2, ymin: i5, xmax: t4, ymax: u5 };
}
function c4(n2, i5, t4, u5, m4, o5) {
  return { xmin: n2, ymin: i5, zmin: t4, xmax: u5, ymax: m4, zmax: o5 };
}
function s5(n2, i5, t4, u5, m4, o5) {
  return { xmin: n2, ymin: i5, mmin: t4, xmax: u5, ymax: m4, mmax: o5 };
}
function e3(n2, i5, t4, u5, m4, o5, r5, x5) {
  return { xmin: n2, ymin: i5, zmin: t4, mmin: u5, xmax: m4, ymax: o5, zmax: r5, mmax: x5 };
}
function f6(n2, i5 = false, t4 = false) {
  return i5 ? t4 ? e3(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5], n2[6], n2[7]) : c4(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : t4 ? s5(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : a5(n2[0], n2[1], n2[2], n2[3]);
}
function l4(n2) {
  return n2 ? t3(n2) ? n2 : m3(n2) ? d2(n2) : r4(n2) ? v(n2) : o4(n2) ? h4(n2) : u4(n2) ? y3(n2) : null : null;
}
function y3(i5) {
  const { hasZ: t4, hasM: u5, points: m4 } = i5;
  return f6(g2(x3, m4, t4 ?? false, u5 ?? false), t4, u5);
}
function d2(n2) {
  const { x: i5, y: t4, z: u5, m: m4 } = n2, o5 = null != m4;
  return null != u5 ? o5 ? e3(i5, t4, u5, m4, i5, t4, u5, m4) : c4(i5, t4, u5, i5, t4, u5) : o5 ? s5(i5, t4, m4, i5, t4, m4) : a5(i5, t4, i5, t4);
}
function v(n2) {
  const { hasZ: t4, hasM: u5, rings: m4 } = n2, o5 = x2(x3, m4, t4 ?? false, u5 ?? false);
  return o5 ? f6(o5, t4, u5) : null;
}
function h4(n2) {
  const { hasZ: t4, hasM: u5, paths: m4 } = n2, o5 = x2(x3, m4, t4 ?? false, u5 ?? false);
  return o5 ? f6(o5, t4, u5) : null;
}

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h5(h6, a6, s6 = false) {
  let { hasM: t4, hasZ: e4 } = h6;
  Array.isArray(a6) ? 4 !== a6.length || t4 || e4 ? 3 === a6.length && s6 && !t4 ? (e4 = true, t4 = false) : 3 === a6.length && t4 && e4 && (t4 = false, e4 = false) : (t4 = true, e4 = true) : (e4 = !e4 && a6.hasZ && (!t4 || a6.hasM), t4 = !t4 && a6.hasM && (!e4 || a6.hasZ)), h6.hasZ = e4, h6.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var d3;
function R(t4) {
  return !Array.isArray(t4[0]);
}
var x4 = d3 = class extends p {
  static fromExtent(t4) {
    const e4 = t4.clone().normalize(), r5 = t4.spatialReference;
    let s6 = false, n2 = false;
    for (const o5 of e4)
      o5.hasZ && (s6 = true), o5.hasM && (n2 = true);
    const i5 = { rings: e4.map((t5) => {
      const e5 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s6 && t5.hasZ) {
        const r6 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < e5.length; t6++)
          e5[t6].push(r6);
      }
      if (n2 && t5.hasM) {
        const r6 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < e5.length; t6++)
          e5[t6].push(r6);
      }
      return e5;
    }), spatialReference: r5 };
    return s6 && (i5.hasZ = true), n2 && (i5.hasM = true), new d3(i5);
  }
  constructor(...t4) {
    super(...t4), this.rings = [], this.type = "polygon";
  }
  normalizeCtorArgs(t4, e4) {
    let r5, s6, n2 = null, i5 = null;
    return t4 && !Array.isArray(t4) ? (n2 = t4.rings ?? null, e4 || (t4.spatialReference ? e4 = t4.spatialReference : t4.rings || (e4 = t4)), r5 = t4.hasZ, s6 = t4.hasM) : n2 = t4, n2 = n2 || [], e4 = e4 || f.WGS84, n2.length && n2[0] && null != n2[0][0] && "number" == typeof n2[0][0] && (n2 = [n2]), i5 = n2[0] && n2[0][0], i5 && (void 0 === r5 && void 0 === s6 ? (r5 = i5.length > 2, s6 = i5.length > 3) : void 0 === r5 ? r5 = s6 ? i5.length > 3 : i5.length > 2 : void 0 === s6 && (s6 = r5 ? i5.length > 3 : i5.length > 2)), { rings: n2, spatialReference: e4, hasZ: r5, hasM: s6 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t4 = o2(this);
    if (!t4 || isNaN(t4[0]) || isNaN(t4[1]) || this.hasZ && isNaN(t4[2]))
      return null;
    const e4 = new x();
    return e4.x = t4[0], e4.y = t4[1], e4.spatialReference = this.spatialReference, this.hasZ && (e4.z = t4[2]), e4;
  }
  get extent() {
    const { spatialReference: t4 } = this, e4 = v(this);
    if (!e4)
      return null;
    const r5 = new M(e4);
    return r5.spatialReference = t4, r5;
  }
  get isSelfIntersecting() {
    return p2(this.rings);
  }
  writeRings(t4, e4) {
    e4.rings = a(this.rings);
  }
  addRing(t4) {
    if (!t4)
      return;
    const e4 = this.rings, r5 = e4.length;
    if (R(t4)) {
      const s6 = [];
      for (let e5 = 0, r6 = t4.length; e5 < r6; e5++)
        s6[e5] = t4[e5].toArray();
      e4[r5] = s6;
    } else
      e4[r5] = t4.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new d3();
    return t4.spatialReference = this.spatialReference, t4.rings = a(this.rings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4)
      return true;
    if (null == t4)
      return false;
    const r5 = this.spatialReference, s6 = t4.spatialReference;
    if (null != r5 != (null != s6))
      return false;
    if (null != r5 && null != s6 && !r5.equals(s6))
      return false;
    if (this.rings.length !== t4.rings.length)
      return false;
    const n2 = ([t5, e4, r6, s7], [n3, i5, o5, a6]) => t5 === n3 && e4 === i5 && (null == r6 && null == o5 || r6 === o5) && (null == s7 && null == a6 || s7 === a6);
    for (let i5 = 0; i5 < this.rings.length; i5++) {
      const r6 = this.rings[i5], s7 = t4.rings[i5];
      if (!s(r6, s7, n2))
        return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4)
      return false;
    const e4 = g(t4, this.spatialReference);
    return f2(this, null != e4 ? e4 : t4);
  }
  isClockwise(t4) {
    let e4;
    return e4 = R(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4, h(e4, this.hasM, this.hasZ);
  }
  getPoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const r5 = this.rings[t4][e4], s6 = this.hasZ, n2 = this.hasM;
    return s6 && !n2 ? new x(r5[0], r5[1], r5[2], void 0, this.spatialReference) : n2 && !s6 ? new x(r5[0], r5[1], void 0, r5[2], this.spatialReference) : s6 && n2 ? new x(r5[0], r5[1], r5[2], r5[3], this.spatialReference) : new x(r5[0], r5[1], this.spatialReference);
  }
  insertPoint(t4, e4, r5) {
    return this._validateInputs(t4, e4, true) ? (h5(this, r5), Array.isArray(r5) || (r5 = r5.toArray()), this.rings[t4].splice(e4, 0, r5), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const r5 = new x(this.rings[t4].splice(e4, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), r5;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e4 = this.rings.splice(t4, 1)[0], r5 = this.spatialReference, s6 = e4.map((t5) => new x(t5, r5));
    return this.notifyChange("rings"), s6;
  }
  setPoint(t4, e4, r5) {
    return this._validateInputs(t4, e4) ? (h5(this, r5), Array.isArray(r5) || (r5 = r5.toArray()), this.rings[t4][e4] = r5, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, e4, r5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length)
      return false;
    if (null != e4) {
      const s6 = this.rings[t4];
      if (r5 && (e4 < 0 || e4 > s6.length))
        return false;
      if (!r5 && (e4 < 0 || e4 >= s6.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], x4.prototype, "cache", null), e([y({ readOnly: true })], x4.prototype, "centroid", null), e([y({ readOnly: true })], x4.prototype, "extent", null), e([y({ readOnly: true })], x4.prototype, "isSelfIntersecting", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], x4.prototype, "rings", void 0), e([r("rings")], x4.prototype, "writeRings", null), x4 = d3 = e([a2("esri.geometry.Polygon")], x4), x4.prototype.toJSON.isDefaultToJSON = true;
var j = x4;

export {
  t,
  n,
  o,
  s2 as s,
  u,
  c,
  h,
  y2 as y,
  M2 as M,
  l2 as l,
  o2,
  u2,
  s3 as s2,
  i3 as i,
  N,
  a4 as a,
  c3 as c2,
  f5 as f,
  m2 as m,
  g2 as g,
  l4 as l2,
  v,
  h4 as h2,
  h5 as h3,
  j
};
//# sourceMappingURL=chunk-FXYPEAR7.js.map
