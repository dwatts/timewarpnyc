import {
  o
} from "./chunk-Q2M27J4W.js";
import {
  S as S3
} from "./chunk-4H2EAPOS.js";
import {
  X,
  Y,
  b as b3
} from "./chunk-H4E57LVR.js";
import {
  W as W2,
  c as c4,
  e as e3,
  f as f5,
  i as i4,
  n as n5,
  s as s8,
  u as u2,
  u2 as u3
} from "./chunk-LDJZGB4X.js";
import {
  h as h2,
  l as l2
} from "./chunk-5ARHJ4BH.js";
import "./chunk-A4HFWKMU.js";
import "./chunk-YRFMBPVS.js";
import {
  o as o2
} from "./chunk-I26BSZGI.js";
import {
  I,
  I2,
  a as a5,
  i as i5,
  r as r3,
  t as t7,
  u as u4
} from "./chunk-C4NVJBAG.js";
import {
  t as t6
} from "./chunk-PM77FW2O.js";
import "./chunk-AHKW4ZTY.js";
import {
  f as f4,
  m as m4
} from "./chunk-5RQTPWCM.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-QSO5MBMS.js";
import {
  b as b2,
  h
} from "./chunk-FP4CFXG6.js";
import {
  n as n4
} from "./chunk-V5N62ACA.js";
import {
  Q,
  R as R2,
  S as S2,
  V,
  W,
  c as c3,
  t as t5
} from "./chunk-ZS33I7QE.js";
import "./chunk-LNX43VM5.js";
import {
  ee
} from "./chunk-V7IVNH7O.js";
import "./chunk-LLQHB2ZB.js";
import {
  f as f3,
  g as g2
} from "./chunk-O2Q4W74O.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-PVUG2RDQ.js";
import "./chunk-J3HE7QNA.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-HSZYWTXA.js";
import "./chunk-YZ24SAPZ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-YAWND7HF.js";
import "./chunk-FJYIB7HF.js";
import {
  e as e4
} from "./chunk-6M3QJVKB.js";
import "./chunk-PH45YSDU.js";
import "./chunk-S5RIUWET.js";
import "./chunk-MNDNZJD5.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-CUZNACFZ.js";
import "./chunk-ZHUFARKQ.js";
import {
  It,
  K,
  L,
  M as M2,
  N,
  Nt,
  at,
  et,
  ht,
  it,
  nt,
  st,
  tt,
  yt
} from "./chunk-ICEO3WMK.js";
import "./chunk-WTKN55TU.js";
import {
  e as e2,
  s as s6,
  t as t3
} from "./chunk-TDPKDZC3.js";
import {
  t as t4
} from "./chunk-M5UHI5WR.js";
import {
  m as m3
} from "./chunk-L3FCQBVC.js";
import "./chunk-FF5LS3YE.js";
import {
  U
} from "./chunk-HLBPEADQ.js";
import {
  j as j5
} from "./chunk-JPAY3V43.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-MD5VUVM5.js";
import {
  a as a4,
  b
} from "./chunk-CF43FEIV.js";
import "./chunk-GNESNC4Q.js";
import {
  a as a3,
  p,
  s as s7
} from "./chunk-VYG5A4VI.js";
import "./chunk-CGJNVOU3.js";
import {
  r as r2
} from "./chunk-BFZI4PK4.js";
import {
  h as h3
} from "./chunk-IHCIS6PT.js";
import "./chunk-OHH3UAUS.js";
import "./chunk-EIQYIBNS.js";
import "./chunk-E2PV5YTZ.js";
import "./chunk-GLVTFP5O.js";
import "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import {
  w
} from "./chunk-2TWR6EVF.js";
import {
  c
} from "./chunk-IR32DXLL.js";
import "./chunk-WIQR3T32.js";
import "./chunk-C2EHS6UI.js";
import {
  d as d3
} from "./chunk-ZEMUATMN.js";
import {
  c as c2
} from "./chunk-RG2YRACH.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-3ESTI2X4.js";
import "./chunk-YK2WEG7V.js";
import "./chunk-GVQH342Z.js";
import "./chunk-W3WHCGIQ.js";
import {
  f as f2,
  j as j3,
  l
} from "./chunk-HPWZ2OON.js";
import "./chunk-GWA3PLGA.js";
import {
  i as i3
} from "./chunk-CNS4YGGN.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-GAARA5JM.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import {
  n as n3
} from "./chunk-J2V5CZSS.js";
import {
  j as j4
} from "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import {
  j as j2
} from "./chunk-FXYPEAR7.js";
import {
  i as i2
} from "./chunk-V3CNLYUD.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import {
  M
} from "./chunk-T35GN7EL.js";
import {
  f
} from "./chunk-7U6V6KY2.js";
import {
  S2 as S,
  d as d2
} from "./chunk-NFY4EX6G.js";
import {
  s as s5
} from "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  m as m2,
  y
} from "./chunk-453UIKKW.js";
import {
  a2
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import {
  n
} from "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import {
  t as t2
} from "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  C,
  P,
  a,
  d,
  g,
  j,
  m,
  n as n2,
  r,
  s as s2,
  s2 as s4,
  u,
  y as y2
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R,
  has,
  t
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors.js
function o3(o7) {
  return "heatmap" === o7 ? import("./HeatmapProcessor-GBIAFDMW.js") : import("./SymbolProcessor-7DP2MY7I.js");
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
function d4({ coords: t9, lengths: e5 }) {
  let r8 = 0;
  for (const s11 of e5) {
    for (let e6 = 1; e6 < s11; e6++)
      t9[2 * (r8 + e6)] += t9[2 * (r8 + e6) - 2], t9[2 * (r8 + e6) + 1] += t9[2 * (r8 + e6) - 1];
    r8 += s11;
  }
}
var h4 = class _h extends I {
  static fromFeatures(e5, r8) {
    const { objectIdField: s11, geometryType: i7 } = r8, n12 = et([], e5, i7, false, false, s11);
    for (let t9 = 0; t9 < n12.length; t9++)
      n12[t9].displayId = e5[t9].displayId;
    return _h.fromOptimizedFeatures(n12, r8);
  }
  static fromFeatureSet(t9, r8) {
    const s11 = it(t9, r8.objectIdField);
    return _h.fromOptimizedFeatureSet(s11, r8);
  }
  static fromOptimizedFeatureSet(t9, e5) {
    const { features: r8 } = t9, s11 = _h.fromOptimizedFeatures(r8, e5);
    return s11._exceededTransferLimit = t9.exceededTransferLimit, s11._transform = t9.transform, s11._fieldsIndex = new r2(e5.fields), s11;
  }
  static fromOptimizedFeatures(t9, e5, r8) {
    const s11 = I.createInstance(), i7 = new _h(s11, t9, e5);
    return i7._fieldsIndex = new r2(e5.fields), i7._transform = r8, i7;
  }
  constructor(t9, e5, r8) {
    super(t9, r8), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = r8 == null ? void 0 : r8.geometryType, this._features = e5;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  removeIds(t9) {
    const e5 = new Set(t9);
    this._features = this._features.filter((t10) => !(null != t10.objectId && e5.has(t10.objectId)));
  }
  append(t9) {
    for (const e5 of t9)
      this._features.push(e5);
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getQuantizationTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let t9 = "";
    for (const e5 in this._current.attributes)
      t9 += this._current.attributes[e5];
    return t9;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(t9) {
    this._featureIndex = t9;
  }
  getObjectId() {
    var _a;
    return (_a = this._current) == null ? void 0 : _a.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t9) {
    this._current.displayId = t9;
  }
  getGroupId() {
    return this._current.groupId;
  }
  setGroupId(t9) {
    this._current.groupId = t9;
  }
  copy() {
    const t9 = new _h(this.instance, this._features, this.fullSchema());
    return this.copyInto(t9), t9;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); )
      ;
    return this._featureIndex < this._features.length;
  }
  readLegacyFeature() {
    return nt(this._current, this.geometryType, this.hasZ, this.hasM);
  }
  readOptimizedFeature() {
    return this._current;
  }
  readLegacyPointGeometry() {
    return this.readGeometry() ? { x: this.getX(), y: this.getY() } : null;
  }
  readLegacyGeometry() {
    const t9 = this.readUnquantizedGeometry();
    return st(t9, this.geometryType, this.hasZ, this.hasM);
  }
  readLegacyCentroid() {
    const t9 = this.readCentroid();
    return null == t9 ? null : { x: t9.coords[0] * this._sx + this._tx, y: t9.coords[1] * this._sy + this._ty };
  }
  readGeometryArea() {
    return s6(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  readUnquantizedGeometry() {
    const t9 = this.readGeometry();
    if ("esriGeometryPoint" === this.geometryType || !t9)
      return t9;
    const e5 = t9.clone();
    return d4(e5), e5;
  }
  readHydratedGeometry() {
    const t9 = this._current.geometry;
    if (null == t9)
      return null;
    const e5 = t9.clone();
    return null != this._transform && It(e5, e5, this.hasZ, this.hasM, this._transform), e5;
  }
  getXHydrated() {
    if (!s6(this._current))
      return 0;
    const t9 = this._current.geometry.coords[0], e5 = this.getQuantizationTransform();
    return null == e5 ? t9 : t9 * e5.scale[0] + e5.translate[0];
  }
  getYHydrated() {
    if (!s6(this._current))
      return 0;
    const t9 = this._current.geometry.coords[1], e5 = this.getQuantizationTransform();
    return null == e5 ? t9 : e5.translate[1] - t9 * e5.scale[1];
  }
  getX() {
    return s6(this._current) ? this._current.geometry.coords[0] * this._sx + this._tx : 0;
  }
  getY() {
    return s6(this._current) ? this._current.geometry.coords[1] * this._sy + this._ty : 0;
  }
  readGeometry() {
    if (!s6(this._current)) {
      if (null != this._current.centroid) {
        const [t10, e6] = this._current.centroid.coords;
        return this.createQuantizedExtrudedQuad(t10, e6);
      }
      return null;
    }
    const t9 = this._current.geometry.clone();
    if (t9.isPoint)
      return t9.coords[0] = t9.coords[0] * this._sx + this._tx, t9.coords[1] = t9.coords[1] * this._sy + this._ty, t9;
    let e5 = 0;
    for (const r8 of t9.lengths)
      t9.coords[2 * e5] = t9.coords[2 * e5] * this._sx + this._tx, t9.coords[2 * e5 + 1] = t9.coords[2 * e5 + 1] * this._sy + this._ty, e5 += r8;
    return t9;
  }
  readCentroid() {
    return s6(this._current) ? this._computeCentroid() : this._current.centroid;
  }
  _readAttribute(t9, e5) {
    var _a;
    const r8 = this._fieldsIndex.get(t9);
    if (!r8)
      return;
    let s11 = this._current.attributes[r8.name];
    return null == s11 ? s11 : ("esriFieldTypeTimestampOffset" === ((_a = this.fields.get(t9)) == null ? void 0 : _a.type) && (s11 = this.parseTimestampOffset(s11)), e5 && this.fields.isDateField(t9) ? new Date(s11) : s11);
  }
  copyInto(t9) {
    super.copyInto(t9), t9._featureIndex = this._featureIndex, t9._transform = this._transform, t9._fieldsIndex = this._fieldsIndex;
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n6 = 268435455;
var o4 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a6(a9, i7, c10 = false) {
  var _a;
  const f9 = 1, d9 = 3, u9 = 9, g5 = 12, l9 = 13, p6 = 15, h9 = a9.asUnsafe(), b4 = h9.pos(), w4 = new o4();
  let m9 = 0, y6 = 0;
  const k3 = 1, x3 = 2, I6 = 4, L5 = 3;
  let A3 = null, F4 = null, C2 = null, S7 = false;
  const j7 = [];
  for (; h9.next(); )
    switch (h9.tag()) {
      case f9:
        A3 = h9.getString();
        break;
      case d9:
        F4 = h9.getString();
        break;
      case g5:
        C2 = h9.processMessage(h);
        break;
      case u9:
        if (w4.exceededTransferLimit = h9.getBool(), w4.exceededTransferLimit) {
          w4.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w4.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
          for (let e5 = 0; e5 < w4.centroid.length; e5++)
            w4.centroid[e5] = n6;
        }
        break;
      case l9: {
        const e5 = h9.processMessage(b2);
        e5.index = m9++, j7.push(e5);
        break;
      }
      case p6: {
        const e5 = h9.getLength(), t9 = h9.pos() + e5;
        if (!w4.exceededTransferLimit) {
          const e6 = w4.offsets.geometry, t10 = w4.centroid;
          e6.push(0), t10.push(n6), t10.push(n6);
        }
        !S7 && w4.exceededTransferLimit && (S7 = true, w4.offsets.attributes = c10 ? new Float64Array(8e3 * m9) : new Uint32Array(8e3 * m9));
        let s11 = y6 * m9;
        for (; h9.pos() < t9 && h9.next(); )
          switch (h9.tag()) {
            case k3: {
              if (S7)
                w4.offsets.attributes[s11++] = h9.pos();
              else {
                w4.offsets.attributes.push(h9.pos());
              }
              const e6 = h9.getLength();
              h9.skipLen(e6);
              break;
            }
            case x3:
              if (i7) {
                const e6 = h9.getLength(), t10 = h9.pos() + e6;
                for (; h9.pos() < t10 && h9.next(); )
                  switch (h9.tag()) {
                    case L5: {
                      h9.getUInt32();
                      const e7 = h9.getSInt64(), t11 = h9.getSInt64();
                      w4.centroid[2 * y6] = e7, w4.centroid[2 * y6 + 1] = t11;
                      break;
                    }
                    default:
                      h9.skip();
                  }
              } else {
                w4.offsets.geometry[y6] = h9.pos();
                const e6 = h9.getLength();
                w4.vertexCount += e6, h9.skipLen(e6);
              }
              break;
            case I6: {
              const e6 = h9.getLength(), t10 = h9.pos() + e6;
              for (; h9.pos() < t10 && h9.next(); )
                switch (h9.tag()) {
                  case L5: {
                    h9.getUInt32();
                    const e7 = h9.getSInt64(), t11 = h9.getSInt64();
                    w4.centroid[2 * y6] = e7, w4.centroid[2 * y6 + 1] = t11;
                    break;
                  }
                  default:
                    h9.skip();
                }
              break;
            }
            default:
              h9.skip();
          }
        y6++, w4.hasFeatures = true;
        break;
      }
      default:
        h9.skip();
    }
  const U3 = A3 || F4;
  if (!U3)
    throw new s3("FeatureSet has no objectId or globalId field name");
  return w4.fields = new r2(j7), w4.featureCount = y6, w4.fieldCount = m9, w4.objectIdFieldIndex = (_a = w4.fields.get(U3)) == null ? void 0 : _a.index, w4.transform = C2, w4.displayIds = new Uint32Array(w4.featureCount), w4.groupIds = new Uint16Array(w4.featureCount), h9.move(b4), w4;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var u5 = true;
var c5 = 268435455;
var g3 = 128;
var l3 = 128e3;
var _ = { small: { delta: new Int32Array(g3), decoded: new Int32Array(g3) }, large: { delta: new Int32Array(l3), decoded: new Int32Array(l3) } };
function f6(e5) {
  return e5 <= _.small.delta.length ? _.small : (e5 <= _.large.delta.length || (_.large.delta = new Int32Array(Math.round(1.25 * e5)), _.large.decoded = new Int32Array(Math.round(1.25 * e5))), _.large);
}
function y3(r8) {
  try {
    const e5 = 2, t9 = new n4(new Uint8Array(r8), new DataView(r8));
    for (; t9.next(); ) {
      if (t9.tag() === e5)
        return I3(t9.getMessage());
      t9.skip();
    }
  } catch (i7) {
    const r9 = new s3("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: i7 });
    s.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r9);
  }
  return null;
}
function I3(e5) {
  const t9 = 1;
  for (; e5.next(); ) {
    if (e5.tag() === t9)
      return e5.getMessage();
    e5.skip();
  }
  return null;
}
function p2(e5) {
  const t9 = 1, r8 = 2, s11 = 3, i7 = 4, n12 = 5, a9 = 6, h9 = 7, o7 = 8, d9 = 9, u9 = e5.getLength(), c10 = e5.pos() + u9;
  for (; e5.pos() < c10 && e5.next(); )
    switch (e5.tag()) {
      case t9:
        return e5.getString();
      case r8:
        return e5.getFloat();
      case s11:
        return e5.getDouble();
      case i7:
        return e5.getSInt32();
      case n12:
        return e5.getUInt32();
      case a9:
        return e5.getInt64();
      case h9:
        return e5.getUInt64();
      case o7:
        return e5.getSInt64();
      case d9:
        return e5.getBool();
      default:
        return e5.skip(), null;
    }
  return null;
}
function m5(e5, t9, r8, s11, i7, n12) {
  return 0.5 * Math.abs(e5 * s11 + r8 * n12 + i7 * t9 - e5 * n12 - r8 * t9 - i7 * s11);
}
function x(e5, t9, r8, s11) {
  return 0 === e5 * s11 - r8 * t9 && e5 * r8 + t9 * s11 > 0;
}
var S4 = class _S extends I {
  static fromBuffer(e5, t9, r8 = false) {
    const s11 = t9.geometryType, i7 = y3(e5), n12 = a6(i7, "esriGeometryPoint" === s11, r8), a9 = I.createInstance();
    return new _S(a9, i7, n12, t9);
  }
  constructor(e5, t9, r8, s11) {
    super(e5, s11), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._geometryType = s11.geometryType, this._reader = t9, this._header = r8, this._hasNext = r8.hasFeatures, this._isPoints = "esriGeometryPoint" === s11.geometryType;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get stride() {
    return 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getQuantizationTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e5) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e5;
  }
  getAttributeHash() {
    let e5 = "";
    for (const t9 of this._header.fields.fields)
      e5 += this._readAttributeAtIndex(t9.index) + ".";
    return e5;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e5) {
    this._header.displayIds[this._featureIndex] = e5;
  }
  getGroupId() {
    return this._header.groupIds[this._featureIndex];
  }
  setGroupId(e5) {
    this._header.groupIds[this._featureIndex] = e5;
  }
  readLegacyFeature() {
    if (void 0 === this._cache.legacyFeature) {
      const e5 = this.readCentroid(), t9 = { attributes: this.readAttributes(), geometry: this._isPoints ? this.readLegacyPointGeometry() : this.readLegacyGeometry(), centroid: (e5 && { x: e5.coords[0], y: e5.coords[1] }) ?? null };
      return this._cache.legacyFeature = t9, t9;
    }
    return this._cache.legacyFeature;
  }
  readOptimizedFeature() {
    if (void 0 === this._cache.optFeature) {
      const e5 = new t3(this.readGeometry(), this.readAttributes(), this.readCentroid());
      return e5.objectId = this.getObjectId(), e5.displayId = this.getDisplayId(), this._cache.optFeature = e5, e5;
    }
    return this._cache.optFeature;
  }
  getXHydrated() {
    const e5 = this._header.centroid[2 * this._featureIndex], t9 = this.getQuantizationTransform();
    return null == t9 ? e5 : e5 * t9.scale[0] + t9.translate[0];
  }
  getYHydrated() {
    const e5 = this._header.centroid[2 * this._featureIndex + 1], t9 = this.getQuantizationTransform();
    return null == t9 ? e5 : t9.translate[1] - e5 * t9.scale[1];
  }
  getX() {
    return this._header.centroid[2 * this._featureIndex] * this._sx + this._tx;
  }
  getY() {
    return this._header.centroid[2 * this._featureIndex + 1] * this._sy + this._ty;
  }
  readLegacyPointGeometry() {
    return { x: this.getX(), y: this.getY() };
  }
  readLegacyGeometry(e5) {
    const t9 = this.readUnquantizedGeometry(e5);
    return st(t9, this.geometryType, false, false);
  }
  readLegacyCentroid() {
    const e5 = this.readCentroid();
    if (!e5)
      return null;
    const [t9, r8] = e5.coords;
    return { x: t9, y: r8 };
  }
  readGeometryArea() {
    return this._cache.area || this.readGeometry(true), this._cache.area;
  }
  readUnquantizedGeometry(e5 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t9 = this.readGeometry(e5);
      if (!t9)
        return this._cache.unquantGeometry = void 0, null;
      const r8 = f6(t9.coords.length).decoded, s11 = t9.clone(r8), i7 = s11.coords;
      let n12 = 0;
      for (const e6 of s11.lengths) {
        for (let t10 = 1; t10 < e6; t10++) {
          const e7 = 2 * (n12 + t10), r9 = 2 * (n12 + t10 - 1);
          i7[e7] += i7[r9], i7[e7 + 1] += i7[r9 + 1];
        }
        n12 += e6;
      }
      return this._cache.unquantGeometry = s11, s11;
    }
    return this._cache.unquantGeometry;
  }
  readHydratedGeometry() {
    if (this._isPoints) {
      if (this._header.centroid[2 * this._featureIndex] === c5)
        return null;
      const e6 = this.getXHydrated(), t10 = this.getYHydrated();
      return new t4([], [e6, t10]);
    }
    const e5 = this.readGeometry();
    if (!e5)
      return null;
    const t9 = e5.clone(), r8 = this.getQuantizationTransform();
    return null != r8 && It(t9, t9, this.hasZ, this.hasM, r8), t9;
  }
  readGeometry(e5 = false) {
    if (void 0 === this._cache.geometry) {
      let r8 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === c5)
          return null;
        const e6 = this.getX(), t9 = this.getY();
        r8 = new t4([], [e6, t9]);
      } else {
        const s11 = this._header.offsets.geometry[this._featureIndex], i7 = this._reader;
        if (0 === s11) {
          const e6 = this._readServerCentroid();
          if (!e6)
            return null;
          const [t9, r9] = e6.coords;
          return this.createQuantizedExtrudedQuad(t9, r9);
        }
        i7.move(s11);
        try {
          if (r8 = e5 ? this._parseGeometryForDisplay(i7) : this._parseGeometry(i7), null === r8) {
            const e6 = this._readServerCentroid();
            if (!e6)
              return null;
            const [t9, r9] = e6.coords;
            return this.createQuantizedExtrudedQuad(t9, r9);
          }
        } catch (t9) {
          return console.error("Failed to parse geometry!", t9), null;
        }
      }
      return this._cache.geometry = r8, r8;
    }
    return this._cache.geometry;
  }
  readCentroid() {
    if (void 0 === this._cache.centroid) {
      let e5;
      return e5 = this._computeCentroid(), e5 || (e5 = this._readServerCentroid()), this._cache.centroid = e5 ?? void 0, e5 ?? null;
    }
    return this._cache.centroid;
  }
  copy() {
    const e5 = this._reader.clone(), t9 = new _S(this.instance, e5, this._header, this.fullSchema());
    return this.copyInto(t9), t9;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); )
      ;
    return this._featureIndex < this._size;
  }
  _readAttribute(e5, t9) {
    var _a;
    const r8 = this._header.fields.get(e5);
    if (null == r8)
      return;
    let s11 = this._readAttributeAtIndex(r8.index);
    "esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e5)) == null ? void 0 : _a.type) && (s11 = this.parseTimestampOffset(s11));
    const i7 = this._header.fields.isDateField(r8.name);
    return t9 ? null == s11 ? s11 : i7 ? new Date(s11) : s11 : s11;
  }
  _readAttributes() {
    const e5 = {};
    for (const t9 of this._header.fields.fields)
      e5[t9.name] = this._readAttributeAtIndex(t9.index);
    return e5;
  }
  copyInto(e5) {
    super.copyInto(e5), e5._featureIndex = this._featureIndex, e5._featureOffset = this._featureOffset, e5._hasNext = this._hasNext;
  }
  _readAttributeAtIndex(e5) {
    const t9 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e5], r8 = this._reader;
    return r8.move(t9), p2(r8);
  }
  _readServerCentroid() {
    const e5 = this._header.centroid[2 * this._featureIndex] + this._tx, t9 = this._header.centroid[2 * this._featureIndex + 1] + this._ty;
    return e5 === c5 ? null : new t4([], [e5, t9]);
  }
  _parseGeometry(e5) {
    const t9 = 2, r8 = 3, s11 = e5.asUnsafe(), i7 = s11.getLength(), n12 = s11.pos() + i7, a9 = [], o7 = [];
    for (; s11.pos() < n12 && s11.next(); )
      switch (s11.tag()) {
        case t9: {
          const e6 = s11.getUInt32(), t10 = s11.pos() + e6;
          for (; s11.pos() < t10; )
            o7.push(s11.getUInt32());
          break;
        }
        case r8: {
          const e6 = s11.getUInt32(), t10 = s11.pos() + e6;
          for (a9.push(s11.getSInt32() + this._tx), a9.push(s11.getSInt32() + this._ty), this.hasZ && s11.getSInt32(), this.hasM && s11.getSInt32(); s11.pos() < t10; )
            a9.push(s11.getSInt32()), a9.push(s11.getSInt32()), this.hasZ && s11.getSInt32(), this.hasM && s11.getSInt32();
          break;
        }
        default:
          s11.skip();
      }
    return new t4(o7, a9);
  }
  _parseGeometryForDisplay(e5) {
    const t9 = 2, s11 = 3, i7 = e5.asUnsafe(), n12 = i7.getLength(), a9 = i7.pos() + n12, o7 = [], d9 = [];
    let c10 = 0, g5 = 0, l9 = null, _3 = 0;
    const y6 = "esriGeometryPolygon" === this.geometryType;
    for (; i7.pos() < a9 && i7.next(); )
      switch (i7.tag()) {
        case t9: {
          const e6 = i7.getUInt32(), t10 = i7.pos() + e6;
          for (; i7.pos() < t10; ) {
            const e7 = i7.getUInt32();
            o7.push(e7), c10 += e7;
          }
          l9 = f6(2 * c10).delta;
          break;
        }
        case s11: {
          i7.getUInt32();
          const e6 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
          r(l9);
          for (const t10 of o7)
            if (g5 + e6 * t10 > l9.length)
              for (let e7 = 0; e7 < t10; e7++)
                i7.getSInt32(), i7.getSInt32(), this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32();
            else if (y6 && u5) {
              const e7 = this.getAreaSimplificationThreshold(t10, this._header.vertexCount);
              let r8 = 2, s12 = 1;
              const n13 = false;
              let a10 = i7.getSInt32(), h9 = i7.getSInt32();
              l9[g5++] = a10, l9[g5++] = h9, this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32();
              let o8 = i7.getSInt32(), u9 = i7.getSInt32();
              for (this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32(); r8 < t10; ) {
                let t11 = i7.getSInt32(), n14 = i7.getSInt32();
                this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32();
                const d10 = a10 + o8, c11 = h9 + u9;
                m5(a10, h9, d10, c11, d10 + t11, c11 + n14) >= e7 ? (_3 += -0.5 * (d10 - a10) * (c11 + h9), s12 > 1 && x(l9[g5 - 2], l9[g5 - 1], o8, u9) ? (l9[g5 - 2] += o8, l9[g5 - 1] += u9) : (l9[g5++] = o8, l9[g5++] = u9, s12++), a10 = d10, h9 = c11) : (t11 += o8, n14 += u9), o8 = t11, u9 = n14, r8++;
              }
              s12 < 3 || n13 ? g5 -= 2 * s12 : (_3 += -0.5 * (a10 + o8 - a10) * (h9 + u9 + h9), x(l9[g5 - 2], l9[g5 - 1], o8, u9) ? (l9[g5 - 2] += o8, l9[g5 - 1] += u9, d9.push(s12)) : (l9[g5++] = o8, l9[g5++] = u9, d9.push(++s12)));
            } else {
              let e7 = 0, r8 = i7.getSInt32(), s12 = i7.getSInt32();
              this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32(), l9[g5++] = r8, l9[g5++] = s12, e7 += 1;
              for (let n13 = 1; n13 < t10; n13++) {
                const t11 = i7.getSInt32(), a10 = i7.getSInt32(), h9 = r8 + t11, o8 = s12 + a10;
                _3 += -0.5 * (h9 - r8) * (o8 + s12), this.hasZ && i7.getSInt32(), this.hasM && i7.getSInt32(), n13 > 2 && x(l9[g5 - 2], l9[g5 - 1], t11, a10) ? (l9[g5 - 2] += t11, l9[g5 - 1] += a10) : (l9[g5++] = t11, l9[g5++] = a10, e7 += 1), r8 = h9, s12 = o8;
              }
              d9.push(e7);
            }
          break;
        }
        default:
          i7.skip();
      }
    if (this._cache.area = _3, !d9.length)
      return null;
    if (this._tx || this._ty) {
      let e6 = 0;
      r(l9);
      for (const t10 of d9)
        l9[2 * e6] += this._tx, l9[2 * e6 + 1] += this._ty, e6 += t10;
    }
    return new t4(d9, l9);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/support/sourceAdapters.js
var c6 = class {
  constructor(e5) {
    this.service = e5;
  }
  destroy() {
  }
};
function m6(e5) {
  return Array.isArray(e5.source);
}
function p3(e5) {
  return "ogc-source" === (e5 == null ? void 0 : e5.type);
}
function l4(e5) {
  const { capabilities: t9 } = e5;
  return p3(e5.source) ? new v(e5) : m6(e5) ? new y4(e5) : t9.query.supportsFormatPBF && has("featurelayer-pbf") ? new h5(e5) : new d5(e5);
}
async function f7(t9) {
  const r8 = new h3();
  return await r8.open(t9, {}), r8;
}
var y4 = class extends c6 {
  constructor(e5) {
    super(e5), this._portsOpen = f7(e5.source).then((e6) => this.client = e6);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(e5, t9) {
    await this._portsOpen;
    const r8 = await this.client.invoke("queryFeatures", e5.toJSON(), t9);
    return h4.fromFeatureSet(r8, this.service);
  }
};
var h5 = class extends c6 {
  async executeQuery(e5, t9) {
    const { data: r8 } = await f4(this.service.source, e5, t9), s11 = !e5.quantizationParameters;
    return S4.fromBuffer(r8, this.service, s11);
  }
};
var d5 = class extends c6 {
  async executeQuery(e5, i7) {
    var _a;
    const { source: a9, capabilities: u9, spatialReference: c10, objectIdField: m9, geometryType: p6 } = this.service;
    if (null != e5.quantizationParameters && !u9.query.supportsQuantization) {
      const u10 = e5.clone(), p7 = m3(u10.quantizationParameters);
      u10.quantizationParameters = null;
      const { data: l10 } = await m4(a9, u10, c10, i7), f9 = it(l10, m9);
      return at(p7, f9), h4.fromOptimizedFeatureSet(f9, this.service);
    }
    const { data: l9 } = await m4(a9, e5, this.service.spatialReference, i7);
    return "esriGeometryPoint" === p6 && (l9.features = (_a = l9.features) == null ? void 0 : _a.filter((e6) => {
      if (null != e6.geometry) {
        const t9 = e6.geometry;
        return Number.isFinite(t9.x) && Number.isFinite(t9.y);
      }
      return true;
    })), h4.fromFeatureSet(l9, this.service);
  }
};
var v = class extends c6 {
  async executeQuery(e5, r8) {
    const { capabilities: a9 } = this.service;
    if (e5.quantizationParameters && !a9.query.supportsQuantization) {
      const a10 = e5.clone(), o8 = m3(a10.quantizationParameters);
      a10.quantizationParameters = null;
      const u9 = await S3(this.service.source, e5, r8);
      return at(o8, u9), h4.fromOptimizedFeatureSet(u9, this.service);
    }
    const o7 = await S3(this.service.source, e5, r8);
    return h4.fromOptimizedFeatureSet(o7, this.service);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/UpdateToken.js
var t8 = class _t {
  constructor() {
    this.version = 0, this.source = false, this.targets = { feature: false, aggregate: false }, this.storage = { filters: false, data: false }, this.mesh = false, this.queryFilter = false, this.why = { mesh: [], source: [] };
  }
  static create(e5) {
    const s11 = new _t();
    let r8;
    for (r8 in e5) {
      const t9 = e5[r8];
      if ("object" == typeof t9)
        for (const e6 in t9) {
          const a9 = e6, i7 = t9[a9];
          s11[r8][a9] = i7;
        }
      s11[r8] = t9;
    }
    return s11;
  }
  static empty() {
    return _t.create({});
  }
  static all() {
    return _t.create({ source: true, targets: { feature: true, aggregate: true }, storage: { filters: true, data: true }, mesh: true });
  }
  unset(t9) {
    this.version = t9.version, t9.source && (this.source = false), t9.targets.feature && (this.targets.feature = false), t9.targets.aggregate && (this.targets.aggregate = false), t9.storage.filters && (this.storage.filters = false), t9.storage.data && (this.storage.data = false), t9.mesh && (this.mesh = false), t9.queryFilter && (this.queryFilter = false);
  }
  any() {
    return this.source || this.mesh || this.storage.filters || this.storage.data || this.targets.feature || this.targets.aggregate || this.queryFilter;
  }
  describe() {
    let t9 = 0, e5 = "";
    if (this.mesh) {
      t9 += 20, e5 += "-> (20) Mesh needs update\n";
      for (const t10 of this.why.mesh)
        e5 += `    + ${t10}
`;
    }
    if (this.source) {
      t9 += 10, e5 += "-> (10) The source needs update\n";
      for (const t10 of this.why.source)
        e5 += `    + ${t10}
`;
    }
    this.targets.feature && (t9 += 5, e5 += "-> (5) Feature target parameters changed\n"), this.storage.filters && (t9 += 5, e5 += "-> (5) Feature filter parameters changed\n"), this.targets.aggregate && (t9 += 4, e5 += "-> (4) Aggregate target parameters changed\n"), this.storage.data && (t9 += 1, e5 += "-> (1) Texture storage parameters changed");
    const s11 = t9 < 5 ? "Fastest" : t9 < 10 ? "Fast" : t9 < 15 ? "Moderate" : t9 < 20 ? "Slow" : "Very Slow";
    console.debug(`Applying ${s11} update of cost ${t9}/45 `), console.debug(e5);
  }
  toJSON() {
    return { queryFilter: this.queryFilter, source: this.source, targets: this.targets, storage: this.storage, mesh: this.mesh };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSubscription.js
var d6 = class {
  constructor(e5, r8) {
    this.requests = { done: new Array(), stream: new t6(10) }, this._edits = null, this._abortController = new AbortController(), this._version = 0, this._resolver = C(), this._isDone = false, this.didSend = false, this.tile = e5, this._version = r8;
  }
  get signal() {
    return this._abortController.signal;
  }
  get options() {
    return { signal: this._abortController.signal };
  }
  get empty() {
    return !this.requests.done.length && null == this.edits;
  }
  get edits() {
    return this._edits;
  }
  get done() {
    return this._resolver.promise;
  }
  get isDone() {
    return this._isDone;
  }
  resolve() {
    this._isDone = true, this._resolver.resolve();
  }
  clear() {
    this.requests.done = [];
  }
  applyUpdate(e5) {
    this.requests.done.forEach((s11) => s11.message.status.unset(e5)), this._version = e5.version, null != this._edits && this._edits.status.unset(e5);
  }
  add(e5) {
    e5.message.status = e5.message.status ?? t8.empty(), e5.message.status.version = this._version, has("esri-2d-update-debug") && console.debug(this.tile.id, "DataTileSubscription:add", this._version), e5.message.end && (this.requests.done.forEach((e6) => {
      null != e6.message && e6.message.end && (e6.message.end = false);
    }), this._resolver.resolve(), this._isDone = true), this.requests.done.push(e5);
  }
  edit(s11, t9) {
    const d9 = s11.getQuantizationTransform(), o7 = s11.fullSchema(), a9 = Array.from(s11.features()).filter(R), n12 = [...t9, ...a9.map((e5) => e5.objectId)];
    if (this.removeIds(n12), this._invalidate(), null == this._edits)
      return void (this._edits = { type: "append", addOrUpdate: h4.fromOptimizedFeatures(a9, o7, d9), id: this.tile.id, status: t8.empty(), end: true });
    this.requests.done.forEach((e5) => e5.message.end = false);
    this._edits.addOrUpdate.append(s11.features());
  }
  *readers() {
    for (const { message: e5 } of this.requests.done)
      null != e5.addOrUpdate && (yield e5.addOrUpdate);
    null != this._edits && null != this._edits.addOrUpdate && (yield this._edits.addOrUpdate);
  }
  _invalidate() {
    for (const e5 of this.requests.done)
      e5.message.status = t8.empty();
    null != this._edits && (this._edits.status = t8.empty());
  }
  removeIds(e5) {
    this._invalidate();
    for (const { message: s11 } of this.requests.done) {
      const t9 = s11.addOrUpdate;
      null != t9 && (t9.removeIds(e5), t9.isEmpty && (has("esri-2d-update-debug") && console.debug("Removing FeatureSetReader"), s11.addOrUpdate = null));
    }
    null != this._edits && null != this._edits.addOrUpdate && this._edits.addOrUpdate.removeIds(e5), this.requests.done = this.requests.done.filter((e6) => e6.message.addOrUpdate || e6.message.end);
  }
  abort() {
    this._abortController.abort(), this._resolver.reject();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSource.js
function p4(e5, s11) {
  const t9 = /* @__PURE__ */ new Set();
  return e5 && e5.forEach((e6) => t9.add(e6)), s11 && s11.forEach((e6) => t9.add(e6)), t9.has("*") ? ["*"] : Array.from(t9);
}
var m7 = class {
  constructor(e5) {
    this.updatingHandles = new c2(), this.events = new n3(), this._resolver = C(), this._didEdit = false, this._subscriptions = /* @__PURE__ */ new Map(), this._outSR = e5.outSR, this._serviceInfo = e5.serviceInfo, this._onTileUpdateMessage = e5.onMessage;
  }
  destroy() {
    for (const e5 of this._subscriptions.values())
      e5.abort();
    this.updatingHandles.destroy();
  }
  get subscriptions() {
    return this._subscriptions.values();
  }
  async _onMessage(e5) {
    const s11 = this._subscriptions.get(e5.id);
    if (!s11)
      return;
    const t9 = { ...e5, remove: e5.remove ?? [], status: e5.status ?? t8.empty() };
    return y2(this._onTileUpdateMessage(t9, s11.options));
  }
  update(s11, t9) {
    var _a;
    const i7 = t9.fields.length;
    t9.outFields = p4((_a = this._schema) == null ? void 0 : _a.outFields, t9.outFields), t9.outFields = t9.outFields.length >= 0.75 * i7 ? ["*"] : t9.outFields, t9.outFields.sort();
    const r8 = a3(this._schema, t9);
    if (!r8)
      return;
    has("esri-2d-update-debug") && console.debug("Applying Update - Source:", r8);
    const o7 = "orderByFields" in this._serviceInfo && this._serviceInfo.orderByFields ? this._serviceInfo.orderByFields : this._serviceInfo.objectIdField + " ASC", a9 = { returnCentroid: "esriGeometryPolygon" === this._serviceInfo.geometryType, returnGeometry: true, timeReferenceUnknownClient: "stream" !== this._serviceInfo.type && this._serviceInfo.timeReferenceUnknownClient, outFields: t9.outFields, outSpatialReference: this._outSR, orderByFields: [o7], where: t9.definitionExpression || "1=1", gdbVersion: t9.gdbVersion, historicMoment: t9.historicMoment, timeExtent: t9.timeExtent ? c.fromJSON(t9.timeExtent) : null }, d9 = this._schema && s7(r8, "outFields");
    this._schema && p(r8, ["timeExtent", "definitionExpression", "gdbVersion", "historicMoment", "customParameters"]) && (s11.why.mesh.push("Layer filter and/or custom parameters changed"), s11.why.source.push("Layer filter and/or custom parameters changed"), s11.mesh = true, s11.source = true, s11.queryFilter = true), d9 && (s11.why.source.push("Layer required fields changed"), s11.source = true), a3(a9, this._queryInfo) && (this._queryInfo = a9), this._schema = t9, this._resolver.resolve();
  }
  whenInitialized() {
    return this._resolver.promise;
  }
  async applyUpdate(e5) {
    if (e5.queryFilter || e5.source && this._didEdit)
      return this.refresh(e5.version), void (this._didEdit = false);
    this._subscriptions.forEach((s11) => s11.applyUpdate(e5)), await this.resend();
  }
  refresh(e5, s11) {
    for (const t9 of this._tiles())
      this.unsubscribe(t9), this.subscribe(t9, e5);
  }
  subscribe(e5, s11) {
    const t9 = new d6(e5, s11);
    this._subscriptions.set(e5.id, t9), this.updatingHandles.addPromise(t9.done);
  }
  unsubscribe(e5) {
    const s11 = this.getSubscription(e5.id);
    null != s11 && s11.abort(), this._subscriptions.delete(e5.id);
  }
  createQuery(e5 = {}) {
    const s11 = this._queryInfo.historicMoment ? new Date(this._queryInfo.historicMoment) : null;
    return new b({ ...this._queryInfo, historicMoment: s11, ...e5 });
  }
  getSubscription(e5) {
    return this._subscriptions.has(e5) ? this._subscriptions.get(e5) : null;
  }
  async queryLastEditDate() {
    throw new Error("Service does not support query type");
  }
  async query(e5, s11) {
    throw new Error("Service does not support query");
  }
  *_tiles() {
    const e5 = Array.from(this._subscriptions.values());
    for (const s11 of e5)
      yield s11.tile;
  }
  async edit(e5, s11) {
    const t9 = Array.from(this._subscriptions.values()), i7 = t9.map(({ tile: e6 }) => e6);
    for (const r8 of t9)
      r8.removeIds(s11);
    if (e5.length) {
      const t10 = i7.map((s12) => {
        const t11 = this.createTileQuery(s12);
        return t11.objectIds = e5, { tile: s12, query: t11 };
      }).map(async ({ tile: e6, query: s12 }) => ({ tile: e6, result: await this.query(s12, { query: { tile: has("esri-tiles-debug") ? e6.id.replaceAll("/", ".") : void 0 } }), query: s12 })), n12 = (await P(t10)).map(async ({ tile: t11, result: i8 }) => {
        if (!i8.hasFeatures && !s11.length && !e5.length)
          return;
        const r8 = this._subscriptions.get(t11.key.id);
        r8 && r8.edit(i8, e5);
      });
      await j(n12);
    }
    this._didEdit = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/BaseFeatureSource.js
var u6 = 4;
var c7 = class extends m7 {
  constructor(e5) {
    super(e5), this.type = "feature", this.mode = "on-demand", this._adapter = l4(e5.serviceInfo), this._queue = new u3({ concurrency: 8, process: async (e6) => {
      var _a, _b;
      if (s4(e6), null != e6.tile) {
        const t9 = e6.tile.key.id, { signal: r8 } = e6, s11 = has("esri-tiles-debug") ? { tile: t9.replaceAll("/", "."), depth: e6.depth } : void 0, i7 = await this._adapter.executeQuery(e6.query, { signal: r8, query: { ...s11, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
        return i7.level = e6.tile.key.level, i7;
      }
      return this._adapter.executeQuery(e6.query, { ...e6, query: (_b = this._schema) == null ? void 0 : _b.customParameters });
    } }), this._patchQueue = new u3({ concurrency: 8, process: async (e6) => {
      var _a, _b;
      if (s4(e6), null != e6.tile) {
        const t9 = e6.tile.key.id, { signal: r8 } = e6, s11 = has("esri-tiles-debug") ? { tile: t9.replaceAll("/", "."), depth: e6.depth } : void 0, i7 = await this._adapter.executeQuery(e6.query, { signal: r8, query: { ...s11, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
        return i7.level = e6.tile.key.level, i7;
      }
      return this._adapter.executeQuery(e6.query, { ...e6, query: (_b = this._schema) == null ? void 0 : _b.customParameters });
    } });
  }
  destroy() {
    super.destroy(), this._adapter.destroy(), this._queue.destroy(), this._patchQueue.destroy();
  }
  enqueueQuery(e5, t9) {
    return this.updatingHandles.addPromise(this._queue.push(e5, t9));
  }
  enqueuePatchQuery(e5, t9) {
    return this.updatingHandles.addPromise(this._patchQueue.push(e5, t9));
  }
  get maxRecordCountFactor() {
    const { query: e5 } = this._serviceInfo.capabilities;
    return e5.supportsMaxRecordCountFactor ? u6 : null;
  }
  get maxPageSize() {
    const { query: e5 } = this._serviceInfo.capabilities;
    return (e5.maxRecordCount ?? 8e3) * (this.maxRecordCountFactor ?? 1);
  }
  get pageSize() {
    return Math.min(8e3, this.maxPageSize);
  }
  enableEvent(e5, t9) {
  }
  subscribe(e5, s11) {
    super.subscribe(e5, s11), this._fetchDataTile(e5).catch((s12) => {
      d(s12) || s.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource").error(new s3("mapview-query-error", "Encountered error when fetching tile", { tile: e5, error: s12 }));
    });
  }
  unsubscribe(e5) {
    super.unsubscribe(e5);
  }
  readers(e5) {
    return this._subscriptions.get(e5).readers();
  }
  async query(e5, t9 = {}) {
    var _a;
    const r8 = t9.query ?? {};
    return this._adapter.executeQuery(e5, { ...t9, query: { ...r8, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
  }
  async queryLastEditDate() {
    const t9 = this._serviceInfo.source, r8 = { ...t9.query, f: "json" };
    return (await j4(t9.path, { query: r8, responseType: "json" })).data.editingInfo.lastEditDate;
  }
  createTileQuery(e5, t9 = {}) {
    const r8 = this._serviceInfo.geometryType, s11 = this.createQuery(t9);
    s11.quantizationParameters = t9.quantizationParameters ?? e5.getQuantizationParameters(), s11.resultType = "tile", s11.geometry = e5.extent, this._serviceInfo.capabilities.query.supportsQuantization ? "esriGeometryPolyline" === r8 && (s11.maxAllowableOffset = e5.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== r8 && "esriGeometryPolygon" !== r8 || (s11.maxAllowableOffset = e5.resolution, "esriGeometryPolyline" === r8 && (s11.maxAllowableOffset *= has("feature-polyline-generalization-factor")));
    const i7 = this._serviceInfo.capabilities.query;
    return s11.defaultSpatialReferenceEnabled = i7.supportsDefaultSpatialReference, s11.compactGeometryEnabled = i7.supportsCompactGeometry, s11;
  }
  async _executePatchQuery(e5, t9, r8, s11) {
    const i7 = t9.clone();
    i7.outFields = [this._serviceInfo.objectIdField, ...r8], i7.returnCentroid = false, i7.returnGeometry = false;
    const a9 = null != i7.start ? i7.start / 8e3 : 0, o7 = s11.signal;
    return await this.enqueuePatchQuery({ tile: e5, query: i7, signal: o7, depth: a9 });
  }
  async _resend(e5, t9) {
    const { query: r8, message: i7 } = e5, a9 = null != r8.outFields ? r8.outFields : [], o7 = this._queryInfo.outFields, n12 = o7.filter((e6) => !a9.includes(e6));
    if (null != i7.addOrUpdate)
      if (n12.length)
        try {
          const e6 = this._subscriptions.get(i7.id).tile, a10 = await this._executePatchQuery(e6, r8, n12, t9);
          s4(t9), r8.outFields = o7, i7.addOrUpdate.joinAttributes(a10), this._onMessage({ ...i7, end: i7.end, type: "append" });
        } catch (u9) {
        }
      else
        this._onMessage({ ...i7, type: "append" });
    else
      this._onMessage({ ...i7, type: "append" });
  }
  async _resendSubscription(e5) {
    if (has("esri-2d-update-debug") && console.debug(e5.tile.id, "Resend Subscription"), e5.empty)
      return this._onMessage({ id: e5.tile.id, addOrUpdate: null, end: false, type: "append" });
    const t9 = e5.signal;
    for (const r8 of e5.requests.done)
      await this._resend(r8, { signal: t9 });
    return null != e5.edits ? this._onMessage(e5.edits) : void 0;
  }
  async resend() {
    const e5 = Array.from(this._subscriptions.values());
    await Promise.all(e5.map((e6) => this._resendSubscription(e6)));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DrillDownFeatureSource.js
var s9 = has("esri-mobile");
var i6 = { maxDrillLevel: s9 ? 1 : 4, maxRecordCountFactor: s9 ? 1 : 3 };
var a7 = class extends c7 {
  constructor(e5) {
    super(e5);
  }
  async _fetchDataTile(r8) {
    const s11 = this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor, a9 = this._subscriptions.get(r8.key.id), o7 = a9.signal, n12 = r8.getQuantizationParameters();
    let c10 = 0;
    const d9 = async (u9, l9) => {
      const m9 = this._queryInfo, p6 = this.createTileQuery(u9, { maxRecordCountFactor: s11 ? i6.maxRecordCountFactor : void 0, returnExceededLimitFeatures: false, quantizationParameters: n12 });
      c10++;
      try {
        const t9 = await this.enqueueQuery({ tile: r8, query: p6, signal: o7, depth: l9 });
        if (c10--, s4(o7), !t9)
          return;
        if (m9 !== this._queryInfo)
          return void d9(u9, l9);
        if (t9.exceededTransferLimit && l9 < i6.maxDrillLevel) {
          for (const e5 of u9.createChildTiles())
            d9(e5, l9 + 1);
          return;
        }
        const s12 = { id: r8.id, addOrUpdate: t9, end: 0 === c10, type: "append" };
        a9.add({ query: p6, message: s12 }), this._onMessage(s12);
      } catch (f9) {
        if (!d(f9)) {
          const e5 = { id: r8.id, addOrUpdate: null, end: true, type: "append" };
          a9.add({ query: p6, message: e5 }), this._onMessage(e5);
        }
      }
    };
    d9(r8, 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/PagedFeatureSource.js
var o5 = class extends c7 {
  constructor(e5) {
    super(e5);
  }
  async _fetchDataTile(s11) {
    const i7 = 6, o7 = 20, n12 = this._subscriptions.get(s11.key.id);
    let d9 = false, c10 = 0, u9 = 0;
    const h9 = (e5, t9) => {
      u9--, s4(n12);
      const r8 = s11.id, i8 = e5.reader, o8 = e5.query;
      if (!i8.exceededTransferLimit) {
        if (d9 = true, 0 !== t9 && !i8.hasFeatures) {
          const e7 = { id: r8, addOrUpdate: i8, end: 0 === u9, type: "append" };
          return n12.add({ message: e7, query: o8 }), void this._onMessage(e7);
        }
        const e6 = { id: r8, addOrUpdate: i8, end: 0 === u9, type: "append" };
        return n12.add({ message: e6, query: o8 }), void this._onMessage(e6);
      }
      const c11 = { id: r8, addOrUpdate: i8, end: d9 && 0 === u9, type: "append" };
      n12.add({ message: c11, query: o8 }), this._onMessage(c11);
    };
    let m9 = 0, p6 = 0;
    for (; !d9 && p6++ < o7; ) {
      let o8;
      for (let a9 = 0; a9 < m9 + 1; a9++) {
        const a10 = c10++;
        u9++, o8 = this._fetchDataTilePage(s11, a10, n12).then((e5) => e5 && h9(e5, a10)).catch((a11) => {
          if (d9 = true, !d(a11)) {
            s.getLogger("esri.views.2d.layers.features.sources.PagedFeatureSource").error(new s3("mapview-query-error", "Encountered error when fetching tile", { tile: s11, error: a11 }));
            const r8 = { id: s11.id, addOrUpdate: null, end: d9, type: "append" }, i8 = { start: this.pageSize * c10, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: s11.getQuantizationParameters() };
            null != this.maxRecordCountFactor && (i8.maxRecordCountFactor = this.maxRecordCountFactor);
            const o9 = this.createTileQuery(s11, i8);
            n12.add({ message: r8, query: o9 }), this._onMessage(r8);
          }
        });
      }
      await o8, s4(n12), m9 = Math.min(m9 + 2, i7);
    }
  }
  async _fetchDataTilePage(e5, t9, r8) {
    s4(r8);
    const i7 = this._queryInfo, o7 = { start: this.pageSize * t9, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: e5.getQuantizationParameters() };
    null != this.maxRecordCountFactor && (o7.maxRecordCountFactor = this.maxRecordCountFactor);
    const n12 = this.createTileQuery(e5, o7);
    try {
      const s11 = r8.signal, o8 = await this.enqueueQuery({ tile: e5, query: n12, signal: s11, depth: t9 });
      return s4(r8), o8 ? i7 !== this._queryInfo ? this._fetchDataTilePage(e5, t9, r8) : { reader: o8, query: n12 } : null;
    } catch (d9) {
      return m(d9), null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/SnapshotFeatureSource.js
function l5(e5, t9, s11) {
  const r8 = e5.getXHydrated(), o7 = e5.getYHydrated(), n12 = t9.getColumnForX(r8), a9 = Math.floor(t9.normalizeCol(n12));
  return `${s11}/${Math.floor(t9.getRowForY(o7))}/${a9}`;
}
function h6(e5, t9) {
  if (null == e5)
    return null;
  const s11 = t9.transform, r8 = e5.getQuantizationTransform();
  if (null == r8) {
    const [t10, r9] = s11.scale, [o8, n13] = s11.translate, a10 = -o8 / t10, i8 = 1 / t10, d10 = n13 / r9, u10 = 1 / -r9;
    return e5.transform(a10, d10, i8, u10);
  }
  const [o7, n12] = r8.scale, [a9, i7] = r8.translate, [d9, u9] = s11.scale, [l9, h9] = s11.translate, c10 = o7 / d9, g5 = (a9 - l9) / d9, p6 = n12 / u9, _3 = (-i7 + h9) / u9;
  return e5.transform(g5, _3, c10, p6);
}
var c8 = class extends c7 {
  constructor(e5) {
    super(e5), this.mode = "snapshot", this._loading = true, this._controller = new AbortController(), this._downloadPromise = null, this._didSendEnd = false, this._queries = new Array(), this._invalidated = false, this._hasAggregates = false, this._random = new t(1e3), this._store = e5.store, this._markedIdsBufId = this._store.storage.createBitset();
  }
  destroy() {
    super.destroy(), this._controller.abort();
  }
  get loading() {
    return this._loading;
  }
  get _signal() {
    return this._controller.signal;
  }
  update(e5, t9) {
    var _a;
    super.update(e5, t9), null == this._featureCount && (this._featureCount = t9.initialFeatureCount), null != t9.changedFeatureCount && (this._featureCount = t9.changedFeatureCount), this._hasAggregates = !!((_a = e5.targets) == null ? void 0 : _a.aggregate);
  }
  async resend(e5 = false) {
    if (await this._downloadPromise, this._invalidated || e5) {
      const e6 = u(this._featureCount, "Expected featureCount to be defined");
      return this._invalidated = false, this._subscriptions.forEach((e7) => e7.clear()), this._downloadPromise = this._download(e6), void await this._downloadPromise;
    }
    const t9 = this._queries.map(({ query: e6, reader: t10 }) => this._sendPatchQuery(e6, t10));
    await Promise.all(t9), this._subscriptions.forEach((e6) => {
      e6.requests.done.forEach((e7) => this._onMessage(e7.message));
    });
  }
  async refresh(e5, t9) {
    t9 && (this._featureCount = t9.featureCount), await this.resend(true);
  }
  async _sendPatchQuery(e5, t9) {
    const s11 = null != e5.outFields ? e5.outFields : [], o7 = this._queryInfo.outFields, n12 = o7.filter((e6) => !s11.includes(e6));
    if (!n12.length)
      return;
    const a9 = e5.clone(), i7 = this._signal;
    a9.returnGeometry = false, a9.returnCentroid = false, a9.outFields = n12, e5.outFields = o7;
    const d9 = await this.enqueueQuery({ query: a9, depth: 0, signal: i7 });
    s4({ signal: i7 }), t9.joinAttributes(d9);
  }
  async _fetchDataTile(e5) {
    if (!this._downloadPromise) {
      const e6 = u(this._featureCount, "Expected featureCount to be defined");
      this._downloadPromise = this._download(e6);
    }
    const t9 = this._store.search(e5), r8 = this._subscriptions.get(e5.key.id), n12 = t9.length - 1;
    for (let s11 = 0; s11 < n12; s11++) {
      const n13 = h6(t9[s11], e5), a10 = { type: "append", id: e5.id, addOrUpdate: n13, end: false, status: t8.empty() };
      r8.add({ query: null, message: a10 }), this._hasAggregates || await g(1), this._onMessage(a10);
    }
    const a9 = h6(n12 >= 0 ? t9[n12] : null, e5), i7 = this._didSendEnd, d9 = { type: "append", id: e5.id, addOrUpdate: a9, end: i7, status: t8.empty() };
    r8.add({ query: null, message: d9 }), this._onMessage(d9);
  }
  async _download(e5) {
    try {
      await this.whenInitialized();
      const t9 = this._store.storage.getBitset(this._markedIdsBufId), s11 = /* @__PURE__ */ new Set();
      t9.clear();
      const r8 = Math.ceil(e5 / this.pageSize), o7 = Array.from({ length: r8 }, (e6, t10) => t10).sort((e6, t10) => this._random.getInt() - this._random.getInt()).map((e6) => this._downloadPage(e6, t9, s11));
      await Promise.all(o7), this._store.sweepFeatures(t9, this._store.storage), this._store.sweepFeatureSets(s11);
    } catch (s11) {
      s.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource").error("mapview-snapshot-source", "Encountered and error when downloading feature snapshot", s11);
    }
    this._sendEnd(), this._loading = false;
  }
  async _downloadPage(e5, t9, s11) {
    const o7 = this.pageSize, n12 = { start: e5 * o7, num: o7, cacheHint: true };
    null != this.maxRecordCountFactor && (n12.maxRecordCountFactor = this.maxRecordCountFactor);
    const a9 = this.createQuery(n12), i7 = this._signal, d9 = await this.enqueueQuery({ query: a9, depth: e5, signal: i7 });
    s4({ signal: i7 }), this._queries.push({ query: a9, reader: d9 }), this._store.insert(d9), s11.add(d9.instance);
    const u9 = d9.getCursor();
    for (; u9.next(); )
      t9.set(u9.getDisplayId());
    this._send(d9);
  }
  _send(e5) {
    if (!this._subscriptions.size)
      return;
    let t9 = null;
    const s11 = /* @__PURE__ */ new Map(), r8 = /* @__PURE__ */ new Set(), o7 = /* @__PURE__ */ new Map();
    this._subscriptions.forEach((e6) => {
      const n12 = e6.tile;
      s11.set(n12.key.id, null), t9 = n12.tileInfoView, r8.add(n12.level);
      const { row: a9, col: i7 } = n12.key, d9 = `${n12.level}/${a9}/${i7}`, u9 = o7.get(d9) ?? [];
      u9.push(e6), o7.set(d9, u9);
    });
    for (const n12 of r8) {
      const r9 = t9.getLODInfoAt(n12), a9 = e5.getCursor();
      for (; a9.next(); ) {
        const e6 = l5(a9, r9, n12), t10 = a9.getIndex();
        if (o7.has(e6))
          for (const r10 of o7.get(e6)) {
            const e7 = r10.tile.id;
            let o8 = s11.get(e7);
            null == o8 && (o8 = [], s11.set(e7, o8)), o8.push(t10);
          }
      }
    }
    s11.forEach((t10, s12) => {
      if (null != t10) {
        const r9 = this._subscriptions.get(s12), o8 = { type: "append", id: s12, addOrUpdate: h6(r3.from(e5, t10), r9.tile), end: false, status: t8.empty() };
        r9.add({ query: null, message: o8 }), this._onMessage(o8);
      }
    });
  }
  _sendEnd() {
    this._subscriptions.forEach((e5) => {
      const t9 = { type: "append", id: e5.tile.id, addOrUpdate: null, end: true, status: t8.empty() };
      e5.add({ query: null, message: t9 }), this._onMessage(t9);
    }), this._didSendEnd = true;
  }
};
c8 = e([a2("esri.view.2d.layers.features.sources.SnapshotFeatureSource")], c8);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s10 = class extends m2 {
  constructor(r8) {
    super(r8);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
e([y()], s10.prototype, "connection", void 0), e([y()], s10.prototype, "connectionStatus", null), e([y()], s10.prototype, "errorString", null), s10 = e([a2("esri.views.2d.layers.features.sources.StreamConnectionState")], s10);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamSource.js
var p5 = 2500;
function _2(e5, t9) {
  const s11 = e5.weakClone();
  if (null != e5.geometry) {
    const i7 = M2(t9, e5.geometry.coords[0]), a9 = N(t9, e5.geometry.coords[1]);
    s11.geometry = new t4([], [i7, a9]);
  }
  return s11;
}
function m8(e5) {
  return "esriGeometryPoint" === e5 ? _2 : (t9, s11) => {
    const n12 = t9.weakClone(), r8 = new t4(), a9 = false, d9 = false, c10 = ht(r8, t9.geometry, a9, d9, e5, s11, false, false);
    return n12.geometry = c10, n12;
  };
}
function g4(e5) {
  return "esriGeometryPoint" === e5 ? (e6) => null != e6.geometry ? { minX: e6.geometry.coords[0], minY: e6.geometry.coords[1], maxX: e6.geometry.coords[0], maxY: e6.geometry.coords[1] } : { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } : (e6) => {
    let t9 = 1 / 0, s11 = 1 / 0, i7 = -1 / 0, n12 = -1 / 0;
    return null != e6.geometry && e6.geometry.forEachVertex((e7, r8) => {
      t9 = Math.min(t9, e7), s11 = Math.min(s11, r8), i7 = Math.max(i7, e7), n12 = Math.max(n12, r8);
    }), { minX: t9, minY: s11, maxX: i7, maxY: n12 };
  };
}
function y5(e5, s11) {
  const i7 = i5(9, g4(s11));
  return i7.load(e5), i7;
}
function f8(e5, t9) {
  return e5.search({ minX: t9.bounds[0], minY: t9.bounds[1], maxX: t9.bounds[2], maxY: t9.bounds[3] });
}
var v2 = class {
  constructor(e5, t9) {
    this.onUpdate = e5, this._geometryType = t9, this._objectIdToFeature = /* @__PURE__ */ new Map(), this._index = null;
  }
  get _features() {
    const e5 = [];
    return this._objectIdToFeature.forEach((t9) => e5.push(t9)), e5;
  }
  add(e5) {
    this._objectIdToFeature.set(e5.objectId, e5), this._index = null;
  }
  get(e5) {
    return this._objectIdToFeature.has(e5) ? this._objectIdToFeature.get(e5) : null;
  }
  forEach(e5) {
    this._objectIdToFeature.forEach(e5);
  }
  search(e5) {
    return this._index || (this._index = y5(this._features, this._geometryType)), f8(this._index, e5);
  }
  clear() {
    this._index = null, this._objectIdToFeature.clear();
  }
  removeById(e5) {
    const t9 = this._objectIdToFeature.get(e5);
    return t9 ? (this._objectIdToFeature.delete(e5), this._index = null, t9) : null;
  }
  update(e5, t9) {
    this.onUpdate(e5, t9);
  }
  get size() {
    return this._objectIdToFeature.size;
  }
};
var I4 = class extends m7 {
  constructor(t9) {
    super(t9), this.type = "stream", this._updateIntervalId = 0, this._level = 0, this._isPaused = false, this._updateInfo = { websocket: 0, client: 0 }, this._inUpdate = false;
    const { outSR: s11 } = t9, { geometryType: i7, objectIdField: n12, timeInfo: r8, purgeOptions: o7, source: c10, spatialReference: u9, serviceFilter: l9, maxReconnectionAttempts: _3, maxReconnectionInterval: g5, updateInterval: y6, customParameters: f9, enabledEventTypes: I6 } = t9.serviceInfo, b4 = new v2(this._onUpdate.bind(this), i7), T4 = new o(b4, n12, r8, o7), j7 = o2(c10, u9, s11, i7, l9, _3, g5, f9 ?? {});
    this._connectionState = new s10({ connection: j7 }), this._store = b4, this._manager = T4, this._connection = j7, this._quantize = m8(i7), this._enabledEventTypes = new Set(I6), this._handlesGroup = n([this._connection.on("data-received", (e5) => this._onFeature(e5)), this._connection.on("message-received", (e5) => this._onWebSocketMessage(e5))]), this._initUpdateInterval = () => {
      let e5 = performance.now();
      this._updateIntervalId = setInterval(() => {
        const s12 = performance.now(), i8 = s12 - e5;
        if (i8 > p5) {
          e5 = s12;
          const t10 = Math.round(this._updateInfo.client / (i8 / 1e3)), n13 = Math.round(this._updateInfo.websocket / (i8 / 1e3));
          this._updateInfo.client = 0, this._updateInfo.websocket = 0, this.events.emit("updateRate", { client: t10, websocket: n13 });
        }
        t9.canAcceptRequest() && !this._inUpdate && this._manager.checkForUpdates();
      }, y6);
    }, this._isPaused = t9.serviceInfo.isPaused, this._isPaused || this._initUpdateInterval();
  }
  destroy() {
    var _a;
    super.destroy(), this._clearUpdateInterval(), this._connection.destroy(), (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  _fetchDataTile() {
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    return this._connectionState.errorString;
  }
  updateCustomParameters(e5) {
    this._connection.updateCustomParameters(e5);
  }
  pauseStream() {
    this._isPaused || (this._isPaused = true, this._clearUpdateInterval());
  }
  resumeStream() {
    this._isPaused && (this._isPaused = false, this._initUpdateInterval());
  }
  sendMessageToSocket(e5) {
    this._connection.sendMessageToSocket(e5);
  }
  sendMessageToClient(e5) {
    this._isPaused && "type" in e5 && "clear" === e5.type ? (this._store.clear(), this._subscriptions.forEach((e6, t9) => {
      e6.didSend && e6.tile.level === this._level && this._onMessage({ type: "append", id: t9, addOrUpdate: null, clear: true, end: true });
    })) : this._connection.sendMessageToClient(e5);
  }
  enableEvent(e5, t9) {
    t9 ? this._enabledEventTypes.add(e5) : this._enabledEventTypes.delete(e5);
  }
  subscribe(e5, t9) {
    super.subscribe(e5, t9);
    const s11 = this._subscriptions.get(e5.id);
    s11.resolve(), this._level = e5.level;
    const i7 = this._getTileFeatures(e5);
    this._onMessage({ type: "append", id: e5.key.id, addOrUpdate: i7, end: true }), s11.didSend = true;
  }
  unsubscribe(e5) {
    super.unsubscribe(e5);
  }
  *readers(e5) {
    const t9 = this._subscriptions.get(e5), { tile: s11 } = t9;
    yield this._getTileFeatures(s11);
  }
  createTileQuery(e5) {
    throw new Error("Service does not support tile  queries");
  }
  async resend() {
    this._subscriptions.forEach((e5) => {
      const { tile: t9 } = e5, s11 = { type: "append", id: t9.id, addOrUpdate: this._getTileFeatures(t9), end: true };
      this._onMessage(s11);
    });
  }
  _getTileFeatures(e5) {
    const t9 = this._store.search(e5).map((t10) => this._quantize(t10, e5.transform));
    return h4.fromOptimizedFeatures(t9, this._serviceInfo, e5.transform);
  }
  _onWebSocketMessage(e5) {
    if (this._enabledEventTypes.has("message-received") && this.events.emit("message-received", e5), "type" in e5)
      switch (e5.type) {
        case "delete":
          if (e5.objectIds)
            for (const t9 of e5.objectIds)
              this._manager.removeById(t9);
          if (e5.trackIds)
            for (const t9 of e5.trackIds)
              this._manager.removeByTrackId(t9);
          break;
        case "clear":
          this._store.forEach((e6) => this._manager.removeById(e6.objectId));
      }
  }
  _onFeature(e5) {
    this._updateInfo.websocket++;
    try {
      this._enabledEventTypes.has("data-received") && this.events.emit("data-received", e5);
      const t9 = tt(e5, this._serviceInfo.geometryType, false, false, this._serviceInfo.objectIdField);
      this._manager.add(t9);
    } catch (t9) {
    }
  }
  _clearUpdateInterval() {
    clearInterval(this._updateIntervalId), this._updateIntervalId = 0;
  }
  async _onUpdate(e5, t9) {
    this._inUpdate = true;
    try {
      null != e5 && (this._updateInfo.client += e5.length), this._subscriptions.forEach((e6, t11) => {
        e6.didSend && e6.tile.level === this._level && this._onMessage({ type: "append", id: t11, addOrUpdate: null, clear: true, end: false });
      });
      const t10 = [];
      this._subscriptions.forEach((e6, s11) => {
        if (!e6.didSend || e6.tile.level !== this._level)
          return;
        const i7 = e6.tile, n12 = { type: "append", id: s11, addOrUpdate: this._getTileFeatures(i7), remove: [], end: false, status: t8.empty() };
        e6.requests.stream.enqueue(n12), t10.push(this._onMessage(n12));
      }), await Promise.all(t10), this._subscriptions.forEach((e6, t11) => {
        e6.didSend && e6.tile.level === this._level && this._onMessage({ type: "append", id: t11, addOrUpdate: null, end: true });
      });
    } catch {
    }
    this._inUpdate = false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/createSource.js
function n7(e5, n12, c10, u9, i7, p6) {
  const f9 = a8(e5, n12, c10, u9, i7, p6);
  switch (f9.type) {
    case "feature":
      switch (f9.origin) {
        case "hosted":
        case "local":
          return new o5(f9);
        case "snapshot":
          return new c8(f9);
        default:
          return new a7(f9);
      }
    case "stream":
      return new I4(f9);
  }
}
function a8(r8, t9, o7, s11, n12, a9) {
  switch (r8.type) {
    case "snapshot":
      return { type: "feature", origin: "snapshot", featureCount: r8.featureCount ?? 0, serviceInfo: r8, onMessage: s11, outSR: t9, tileInfoView: o7, canAcceptRequest: n12, store: a9 };
    case "stream":
      return { type: "stream", serviceInfo: r8, onMessage: s11, outSR: t9, canAcceptRequest: n12 };
    case "memory":
    case "on-demand":
      return { type: "feature", serviceInfo: r8, onMessage: s11, outSR: t9, origin: c10(r8.source), tileInfoView: o7, canAcceptRequest: n12 };
  }
  function c10(r9) {
    return Array.isArray(r9) ? "local" : "path" in r9 && w(r9.path) ? "hosted" : "unknown";
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/util/debug.js
var n8 = (n12, l9) => n12 && ((...n13) => l9.warn("DEBUG:", ...n13)) || (() => null);
var l6 = false;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/visualVariablesUtils.js
function l8(e5, t9) {
  if (!e5 || !t9)
    return e5;
  switch (t9) {
    case "radius":
    case "distance":
      return 2 * e5;
    case "diameter":
    case "width":
      return e5;
    case "area":
      return Math.sqrt(e5);
  }
  return e5;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
var E = s.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var k = n8(l6, E);
var D = { sharedArrayBuffer: has("esri-shared-array-buffer"), atomics: has("esri-atomics") };
function F(t9, e5) {
  return (i7) => e5(t9(i7));
}
var I5 = class {
  constructor(t9, e5, i7, s11) {
    this.size = 0, this.texelSize = 4, this.dirtyStart = 0, this.dirtyEnd = 0;
    const { pixelType: r8, layout: a9, textureOnly: n12 } = s11;
    this.textureOnly = n12 || false, this.pixelType = r8, this._ctype = e5, this.layout = a9, this._resetRange(), this._shared = t9, this.size = i7, n12 || (this.data = this._initData(r8, i7, t9, e5));
  }
  get buffer() {
    return n2(this.data, (t9) => t9.buffer);
  }
  unsetComponentAllTexels(t9, e5) {
    const i7 = this.data;
    for (let s11 = 0; s11 < this.size * this.size; s11++)
      i7[s11 * this.texelSize + t9] &= ~e5;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t9, e5) {
    const i7 = this.data;
    for (let s11 = 0; s11 < this.size * this.size; s11++)
      i7[s11 * this.texelSize + t9] |= 255 & e5;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t9, e5, i7) {
    const s11 = this.data;
    for (const r8 of i7)
      s11[r8 * this.texelSize + t9] |= e5, this.dirtyStart = Math.min(this.dirtyStart, r8), this.dirtyEnd = Math.max(this.dirtyEnd, r8);
  }
  setComponentTexel(t9, e5, i7) {
    this.data[i7 * this.texelSize + t9] |= e5, this.dirtyStart = Math.min(this.dirtyStart, i7), this.dirtyEnd = Math.max(this.dirtyEnd, i7);
  }
  unsetComponentTexel(t9, e5, i7) {
    this.data[i7 * this.texelSize + t9] &= ~e5, this.dirtyStart = Math.min(this.dirtyStart, i7), this.dirtyEnd = Math.max(this.dirtyEnd, i7);
  }
  getData(t9, e5) {
    const i7 = f5(t9);
    return this.data[i7 * this.texelSize + e5];
  }
  setData(t9, e5, i7) {
    const s11 = f5(t9), r8 = 1 << e5;
    0 != (this.layout & r8) ? null != this.data && (this.data[s11 * this.texelSize + e5] = i7, this.dirtyStart = Math.min(this.dirtyStart, s11), this.dirtyEnd = Math.max(this.dirtyEnd, s11)) : E.error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  lock() {
    this.pixelType === U.UNSIGNED_BYTE && this._shared && D.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 1);
  }
  unlock() {
    this.pixelType === U.UNSIGNED_BYTE && this._shared && D.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 0);
  }
  expand(t9) {
    if (this.size = t9, !this.textureOnly) {
      const e5 = this._initData(this.pixelType, t9, this._shared, this._ctype), i7 = this.data;
      e5.set(i7), this.data = e5;
    }
  }
  toMessage() {
    const t9 = this.dirtyStart, e5 = this.dirtyEnd, i7 = this.texelSize;
    if (t9 > e5)
      return null;
    this._resetRange();
    const s11 = !(this._shared || "local" === this._ctype), r8 = this.pixelType, a9 = this.layout, n12 = this.data;
    return { start: t9, end: e5, data: s11 && n12.slice(t9 * i7, (e5 + 1) * i7) || null, pixelType: r8, layout: a9 };
  }
  _initData(t9, e5, i7, s11) {
    const r8 = i7 && "local" !== s11 ? SharedArrayBuffer : ArrayBuffer, a9 = W2(t9), n12 = new a9(new r8(e5 * e5 * 4 * a9.BYTES_PER_ELEMENT));
    for (let o7 = 0; o7 < n12.length; o7 += 4)
      n12[o7 + 1] = 255;
    return n12;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var B = class {
  constructor(t9, e5) {
    this._client = t9, this.config = e5, this.updatingHandles = new c2(), this._blocks = new Array(), this._filters = new Array(V), this._attributeComputeInfo = null, this._targetType = 0, this._abortController = new AbortController(), this._hasScaleExpr = false, this._size = 32, this._nextUpdate = null, this._currUpdate = null, this._idsToHighlight = /* @__PURE__ */ new Set();
    const i7 = e5.supportsTextureFloat ? U.FLOAT : U.UNSIGNED_BYTE;
    k(`Creating AttributeStore ${D.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: U.UNSIGNED_BYTE, layout: 1 }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: i7, layout: 15 }, { pixelType: i7, layout: 15 }, { pixelType: i7, layout: 15 }, { pixelType: i7, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  destroy() {
    this._abortController.abort(), this.updatingHandles.destroy();
  }
  get hasScaleExpr() {
    return this._hasScaleExpr;
  }
  get _signal() {
    return this._abortController.signal;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  isUpdating() {
    const t9 = this.updatingHandles.updating || !!this._nextUpdate;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStore: ${t9}
  -> updatingHandles ${this.updatingHandles.updating} (currUpdate: ${!!this._currUpdate})
  -> nextUpdate: ${!!this._nextUpdate}
`), t9;
  }
  update(t9, e5) {
    this.config = e5;
    const i7 = e5.schema.processors[0].storage, s11 = a3(this._schema, i7);
    if ((t9.targets.feature || t9.targets.aggregate) && (t9.storage.data = true), s11 && (has("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", s11), t9.storage.data = true, this._schema = i7, this._attributeComputeInfo = null, null != i7)) {
      switch (i7.target) {
        case "feature":
          this._targetType = u2;
          break;
        case "aggregate":
          this._targetType = c4;
      }
      if ("subtype" === i7.type) {
        this._attributeComputeInfo = { isSubtype: true, subtypeField: i7.subtypeField, map: /* @__PURE__ */ new Map() };
        for (const t10 in i7.mapping) {
          const e6 = i7.mapping[t10];
          if (null != e6 && null != e6.vvMapping)
            for (const i8 of e6.vvMapping)
              this._bindAttribute(i8, parseInt(t10, 10));
        }
      } else {
        if (this._attributeComputeInfo = { isSubtype: false, map: /* @__PURE__ */ new Map() }, null != i7.vvMapping)
          for (const t10 of i7.vvMapping)
            this._bindAttribute(t10);
        if (null != i7.attributeMapping)
          for (const t10 of i7.attributeMapping)
            this._bindAttribute(t10);
      }
    }
  }
  onTileData(t9, e5) {
    if (null == e5.addOrUpdate)
      return;
    const i7 = e5.addOrUpdate.getCursor();
    for (; i7.next(); ) {
      const t10 = i7.getDisplayId();
      this.setAttributeData(t10, i7);
    }
  }
  async setHighlight(t9, e5) {
    const i7 = 1, s11 = this._getBlock(0), r8 = e5.map((t10) => f5(t10));
    s11.lock(), s11.unsetComponentAllTexels(0, i7), s11.setComponent(0, i7, r8), s11.unlock(), this._idsToHighlight.clear();
    for (const a9 of t9)
      this._idsToHighlight.add(a9);
    await this.sendUpdates();
  }
  async updateFilters(t9, e5, i7) {
    has("esri-2d-update-debug") && console.debug("AttributeStore::updateFilters");
    const { service: s11, spatialReference: r8 } = i7, { filters: a9 } = e5, n12 = a9.map((t10, e6) => this._updateFilter(t10, e6, s11, r8)), o7 = (await Promise.all(n12)).some((t10) => t10);
    has("esri-2d-update-debug") && console.debug("AttributeStore::updateFilters - finsihed"), o7 && (t9.storage.filters = true, has("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", "Filters changed"));
  }
  setData(t9, e5, i7, s11) {
    const r8 = f5(t9);
    this._ensureSizeForTexel(r8), this._getBlock(e5).setData(t9, i7, s11);
  }
  getData(t9, e5, i7) {
    return this._getBlock(e5).getData(t9, i7);
  }
  getHighlightFlag(t9) {
    return this._idsToHighlight.has(t9) ? W : 0;
  }
  unsetAttributeData(t9) {
    const e5 = f5(t9);
    this._getBlock(0).setData(e5, 0, 0);
  }
  setAttributeData(t9, e5) {
    const s11 = f5(t9);
    if (this._ensureSizeForTexel(s11), this._getBlock(0).setData(s11, 0, this.getFilterFlags(e5)), this._targetType !== e3(t9))
      return;
    const r8 = this._attributeComputeInfo, a9 = this.config.supportsTextureFloat ? 1 : 2, n12 = 4;
    let o7 = null;
    r8 && (o7 = r8.isSubtype ? r8.map.get(e5.readAttribute(r8.subtypeField)) : r8.map, o7 && o7.size && o7.forEach((t10, r9) => {
      const o8 = r9 * a9 % n12, l9 = Math.floor(r9 * a9 / n12), h9 = this._getBlock(l9 + S2), u9 = t10(e5);
      if (this.config.supportsTextureFloat)
        h9.setData(s11, o8, u9);
      else if (u9 === t5)
        h9.setData(s11, o8, 255), h9.setData(s11, o8 + 1, 255);
      else {
        const t11 = i(Math.round(u9), -32767, 32766) + 32768, e6 = 255 & t11, r10 = (65280 & t11) >> 8;
        h9.setData(s11, o8, e6), h9.setData(s11, o8 + 1, r10);
      }
    }));
  }
  sendUpdates() {
    if (has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate"), this._nextUpdate)
      return this._nextUpdate.promise;
    if (this._currUpdate)
      return this._nextUpdate = C(), this.updatingHandles.addPromise(this._nextUpdate.promise), this._nextUpdate.promise;
    const e5 = { blocks: this._blocks.map((t9) => null != t9 ? t9.toMessage() : null) };
    return this._currUpdate = this._createResources().then(() => {
      const t9 = () => {
        if (this._currUpdate = null, this._nextUpdate) {
          const t10 = this._nextUpdate;
          this._nextUpdate = null, this.sendUpdates().then(() => t10.resolve());
        } else
          has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::No additional updates queued");
      };
      has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::client.update");
      const i7 = this.updatingHandles.addPromise(this._client.update(e5, this._signal).then(t9).catch(t9));
      return this._client.render(this._signal), i7;
    }).catch((e6) => {
      if (d(e6))
        return this._createResourcesPromise = null, this._createResources();
      E.error(new s3("mapview-attribute-store", "Encountered an error during client update", e6));
    }), this._currUpdate;
  }
  _ensureSizeForTexel(t9) {
    for (; t9 >= this._size * this._size; )
      if (this._expand())
        return;
  }
  _bindAttribute(t9, e5) {
    function i7() {
      const { normalizationField: e6 } = t9;
      return e6 ? (i8) => {
        const s12 = i8.readAttribute(e6);
        if (!s12)
          return null;
        return i8.readAttribute(t9.field) / s12;
      } : (e7) => e7.readAttribute(t9.field);
    }
    function s11() {
      return t9.normalizationField && E.warn("mapview-arcade", "Ignoring normalizationField specified with an arcade expression which is not supported."), (e6) => e6.getComputedNumericAtIndex(t9.fieldIndex);
    }
    let r8;
    if (null != t9.fieldIndex)
      r8 = s11();
    else {
      if (!t9.field)
        return;
      r8 = i7();
    }
    const { valueRepresentation: a9 } = t9;
    if (a9) {
      r8 = F(r8, (t10) => l8(t10, a9));
    }
    const n12 = (t10) => null === t10 || isNaN(t10) || t10 === 1 / 0 || t10 === -1 / 0 ? t5 : t10, o7 = this._attributeComputeInfo;
    if (o7.isSubtype) {
      const i8 = o7.map.get(e5) ?? /* @__PURE__ */ new Map();
      i8.set(t9.binding, F(r8, n12)), o7.map.set(e5, i8);
    } else
      o7.map.set(t9.binding, F(r8, n12));
  }
  _createResources() {
    if (null != this._createResourcesPromise)
      return this._createResourcesPromise;
    this._getBlock(Q), this._getBlock(R2), k("Initializing AttributeStore");
    const e5 = { shared: D.sharedArrayBuffer && !("local" === this._client.type), size: this._size, blocks: s2(this._blocks, (t9) => ({ textureOnly: t9.textureOnly, buffer: t9.buffer, pixelType: t9.pixelType })) }, i7 = this._client.initialize(e5, this._signal).catch((e6) => {
      d(e6) ? this._createResourcesPromise = null : E.error(new s3("mapview-attribute-store", "Encountered an error during client initialization", e6));
    });
    return this._createResourcesPromise = i7, i7.then(() => null == this._createResourcesPromise ? this._createResources() : void 0), i7;
  }
  _getBlock(t9) {
    const e5 = this._blocks[t9];
    if (null != e5)
      return e5;
    k(`Initializing AttributeBlock at index ${t9}`);
    const i7 = D.sharedArrayBuffer, s11 = this._client.type, r8 = new I5(i7, s11, this._size, this._blockDescriptors[t9]);
    return this._blocks[t9] = r8, this._createResourcesPromise = null, r8;
  }
  _expand() {
    if (this._size < this.config.maxTextureSize) {
      const t9 = this._size <<= 1;
      return k("Expanding block size to", t9, this._blocks), a(this._blocks, (e5) => e5.expand(t9)), this._createResourcesPromise = null, this._size = t9, 0;
    }
    return E.error(new s3("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  async _updateFilter(t9, e5, i7, s11) {
    const r8 = this._filters[e5], a9 = null != r8 && r8.hash;
    if (!r8 && !t9)
      return false;
    if (a9 === JSON.stringify(t9))
      return false;
    if (null == t9) {
      if (!r8)
        return false;
      const t10 = 1 << e5 + 1, i8 = this._getBlock(0);
      return this._filters[e5] = null, i8.setComponentAllTexels(0, t10), this.sendUpdates(), true;
    }
    const n12 = await this._getFilter(e5, i7);
    return await n12.update(t9, s11), true;
  }
  async _getFilter(t9, e5) {
    const i7 = this._filters[t9];
    if (null != i7)
      return i7;
    const { default: s11 } = await import("./FeatureFilter-RWRVAARL.js"), r8 = new s11({ geometryType: e5.geometryType, hasM: false, hasZ: false, timeInfo: e5.timeInfo, fieldsIndex: new r2(e5.fields) });
    return this._filters[t9] = r8, r8;
  }
  isVisible(t9) {
    return !!(2 & this._getBlock(0).getData(t9, 0));
  }
  getFilterFlags(t9) {
    let e5 = 0;
    const i7 = i4(t9.getDisplayId());
    for (let r8 = 0; r8 < this._filters.length; r8++) {
      const s12 = !!(i7 & 1 << r8), a9 = this._filters[r8];
      e5 |= (!s12 || null == a9 || a9.check(t9) ? 1 : 0) << r8;
    }
    let s11 = 0;
    if (this._idsToHighlight.size) {
      const e6 = t9.getObjectId();
      s11 = this.getHighlightFlag(e6);
    }
    return e5 << 1 | s11;
  }
};

// node_modules/@arcgis/core/geohash/GeohashTree.js
var h7 = class {
  constructor(e5 = [], s11, i7 = 8096) {
    this.onRelease = (t9) => {
    }, this._nodes = 0, this._root = new c9(this, 0, 0, 0), this._statisticFields = e5, this._pool = i7 ? new t6(8096) : null, this._serviceInfo = s11;
  }
  destroy() {
    this.clear();
  }
  _acquire(t9, e5, s11) {
    this._nodes++;
    let i7 = null;
    return null != this._pool && (i7 = this._pool.dequeue()), null != i7 ? i7.realloc(t9, e5, s11) : i7 = new c9(this, t9, e5, s11), i7;
  }
  _release(t9) {
    this.onRelease(t9), this._nodes--, null != this._pool && this._pool.enqueue(t9);
  }
  get count() {
    return this._root.count;
  }
  get size() {
    return this._nodes;
  }
  get poolSize() {
    var _a;
    return ((_a = this._pool) == null ? void 0 : _a.size) ?? 0;
  }
  get depth() {
    let t9 = 0;
    return this.forEach((e5) => t9 = Math.max(t9, e5.depth)), t9;
  }
  dropLevels(t9) {
    this.forEach((e5) => {
      if (e5.depth >= t9)
        for (let t10 = 0; t10 < e5.children.length; t10++) {
          const s11 = e5.children[t10];
          s11 && this._release(s11);
        }
    }), this.forEach((e5) => {
      if (e5.depth >= t9)
        for (let t10 = 0; t10 < e5.children.length; t10++)
          e5.children[t10] = null;
    });
  }
  clear() {
    this.forEach((t9) => this._release(t9)), this._root = new c9(this, 0, 0, 0);
  }
  insert(t9, e5, s11 = 0) {
    const i7 = h4.fromOptimizedFeatures([t9], this._serviceInfo).getCursor();
    i7.next();
    const n12 = i7.readGeometry();
    if (!n12)
      return;
    const [o7, a9] = n12.coords, r8 = t9.geohashX, h9 = t9.geohashY;
    this.insertCursor(i7, t9.displayId, o7, a9, r8, h9, e5, s11);
  }
  insertCursor(t9, e5, s11, i7, n12, o7, a9, r8 = 0) {
    let l9 = this._root, h9 = 0, c10 = 0, u9 = 0;
    for (; null !== l9; ) {
      if (l9.depth >= r8 && (l9.count += 1, l9.xTotal += s11, l9.yTotal += i7, l9.xGeohashTotal += n12, l9.yGeohashTotal += o7, l9.referenceId = e5, this._updateStatisticsCursor(t9, l9, 1)), h9 >= a9)
        return void l9.add(e5);
      const d9 = Math.ceil((h9 + 1) / 2), f9 = Math.floor((h9 + 1) / 2), x3 = 1 - h9 % 2, m9 = 30 - (3 * d9 + 2 * f9), g5 = 30 - (2 * d9 + 3 * f9), y6 = (n12 & 7 * x3 + 3 * (1 - x3) << m9) >> m9, p6 = (o7 & 3 * x3 + 7 * (1 - x3) << g5) >> g5, _3 = y6 + p6 * (8 * x3 + 4 * (1 - x3));
      c10 = c10 << 3 * x3 + 2 * (1 - x3) | y6, u9 = u9 << 2 * x3 + 3 * (1 - x3) | p6, null == l9.children[_3] && (l9.children[_3] = this._acquire(c10, u9, h9 + 1)), h9 += 1, l9 = l9.children[_3];
    }
  }
  remove(t9, e5) {
    const s11 = h4.fromOptimizedFeatures([t9], this._serviceInfo).getCursor();
    s11.next();
    const i7 = s11.readGeometry();
    if (!i7)
      return;
    const [n12, o7] = i7.coords, a9 = t9.geohashX, r8 = t9.geohashY;
    this.removeCursor(s11, n12, o7, a9, r8, e5);
  }
  removeCursor(t9, e5, s11, i7, n12, o7) {
    let a9 = this._root, r8 = 0;
    for (; null !== a9; ) {
      if (a9.count -= 1, a9.xTotal -= e5, a9.yTotal -= s11, a9.xGeohashTotal -= i7, a9.yGeohashTotal -= n12, this._updateStatisticsCursor(t9, a9, -1), r8 >= o7)
        return void a9.remove(t9.getDisplayId());
      const l9 = Math.ceil((r8 + 1) / 2), h9 = Math.floor((r8 + 1) / 2), c10 = 1 - r8 % 2, u9 = 30 - (3 * l9 + 2 * h9), d9 = 30 - (2 * l9 + 3 * h9), f9 = ((i7 & 7 * c10 + 3 * (1 - c10) << u9) >> u9) + ((n12 & 3 * c10 + 7 * (1 - c10) << d9) >> d9) * (8 * c10 + 4 * (1 - c10)), x3 = a9.children[f9];
      1 === (x3 == null ? void 0 : x3.count) && (this._release(x3), a9.children[f9] = null), r8 += 1, a9 = x3;
    }
  }
  forEach(t9) {
    let e5 = this._root;
    for (; null !== e5; ) {
      const s11 = this._linkChildren(e5) || e5.next;
      t9(e5), e5 = s11;
    }
  }
  find(t9, e5, s11) {
    return this._root.find(t9, e5, s11, 0, 0, 0);
  }
  findIf(t9) {
    let e5 = null;
    return this.forEach((s11) => {
      t9(s11) && (e5 = s11);
    }), e5;
  }
  findAllIf(t9) {
    const e5 = [];
    return this.forEach((s11) => {
      t9(s11) && e5.push(s11);
    }), e5;
  }
  findSingleOccupancyNode(t9, e5, s11, i7, n12) {
    let o7 = this._root;
    for (; null !== o7; ) {
      const a9 = o7.depth, r8 = o7.xNode, l9 = o7.yNode, h9 = 1 - a9 % 2, c10 = o7.xGeohashTotal / o7.count, u9 = o7.yGeohashTotal / o7.count;
      if (1 === o7.count && t9 < c10 && c10 <= s11 && e5 < u9 && u9 <= i7)
        return o7;
      if (a9 >= n12) {
        o7 = o7.next;
        continue;
      }
      const d9 = Math.ceil((a9 + 1) / 2), f9 = Math.floor((a9 + 1) / 2), x3 = 30 - (3 * d9 + 2 * f9), m9 = 30 - (2 * d9 + 3 * f9), g5 = ~((1 << x3) - 1), y6 = ~((1 << m9) - 1), p6 = (t9 & g5) >> x3, _3 = (e5 & y6) >> m9, v3 = (s11 & g5) >> x3, M3 = (i7 & y6) >> m9, T4 = r8 << 3 * h9 + 2 * (1 - h9), b4 = l9 << 2 * h9 + 3 * (1 - h9), k3 = T4 + 8 * h9 + 4 * (1 - h9), N2 = b4 + 4 * h9 + 8 * (1 - h9), I6 = Math.max(T4, p6), C2 = Math.max(b4, _3), G2 = Math.min(k3, v3), L5 = Math.min(N2, M3);
      let S7 = null, w4 = null;
      for (let t10 = C2; t10 <= L5; t10++)
        for (let e6 = I6; e6 <= G2; e6++) {
          const s12 = e6 - T4 + (t10 - b4) * (8 * h9 + 4 * (1 - h9)), i8 = o7.children[s12];
          i8 && (S7 || (S7 = i8, S7.next = o7.next), w4 && (w4.next = i8), w4 = i8, i8.next = o7.next);
        }
      o7 = S7 || o7.next;
    }
    return null;
  }
  getRegionDisplayIds(t9) {
    let e5 = this._root;
    const { bounds: s11, geohashBounds: i7, level: n12 } = t9, [o7, a9, r8, l9] = s11, h9 = [];
    for (; null !== e5; ) {
      const t10 = e5.depth, s12 = e5.xNode, c10 = e5.yNode;
      if (t10 >= n12) {
        const t11 = e5.xTotal / e5.count, s13 = e5.yTotal / e5.count;
        t11 >= o7 && t11 <= r8 && s13 >= a9 && s13 <= l9 && e5.displayIds.forEach((t12) => h9.push(t12)), e5 = e5.next;
        continue;
      }
      const u9 = Math.ceil((t10 + 1) / 2), d9 = Math.floor((t10 + 1) / 2), f9 = 1 - t10 % 2, x3 = 30 - (3 * u9 + 2 * d9), m9 = 30 - (2 * u9 + 3 * d9), g5 = ~((1 << x3) - 1), y6 = ~((1 << m9) - 1), p6 = (i7.xLL & g5) >> x3, _3 = (i7.yLL & y6) >> m9, v3 = (i7.xTR & g5) >> x3, M3 = (i7.yTR & y6) >> m9, T4 = s12 << 3 * f9 + 2 * (1 - f9), b4 = c10 << 2 * f9 + 3 * (1 - f9), k3 = T4 + 8 * f9 + 4 * (1 - f9), N2 = b4 + 4 * f9 + 8 * (1 - f9), I6 = Math.max(T4, p6), C2 = Math.max(b4, _3), G2 = Math.min(k3, v3), L5 = Math.min(N2, M3);
      let S7 = null, w4 = null;
      for (let i8 = C2; i8 <= L5; i8++)
        for (let t11 = I6; t11 <= G2; t11++) {
          const s13 = t11 - T4 + (i8 - b4) * (8 * f9 + 4 * (1 - f9)), n13 = e5.children[s13];
          n13 && (S7 || (S7 = n13, S7.next = e5.next), w4 && (w4.next = n13), w4 = n13, n13.next = e5.next);
        }
      e5 = S7 || e5.next;
    }
    return h9;
  }
  getRegionStatistics(t9) {
    let e5 = this._root, s11 = 0, i7 = 0, n12 = 0;
    const o7 = {}, { bounds: a9, geohashBounds: r8, level: l9 } = t9, [h9, c10, u9, d9] = a9;
    let f9 = 0;
    for (; null !== e5; ) {
      const t10 = e5.depth, a10 = e5.xNode, x3 = e5.yNode;
      if (t10 >= l9) {
        const t11 = e5.xTotal / e5.count, a11 = e5.yTotal / e5.count;
        t11 > h9 && t11 <= u9 && a11 > c10 && a11 <= d9 && (s11 += e5.count, i7 += e5.xTotal, n12 += e5.yTotal, 1 === e5.count && (f9 = e5.referenceId), this._aggregateStatistics(o7, e5.statistics)), e5 = e5.next;
        continue;
      }
      const m9 = Math.ceil((t10 + 1) / 2), g5 = Math.floor((t10 + 1) / 2), y6 = 1 - t10 % 2, p6 = 30 - (3 * m9 + 2 * g5), _3 = 30 - (2 * m9 + 3 * g5), v3 = ~((1 << p6) - 1), M3 = ~((1 << _3) - 1), T4 = (r8.xLL & v3) >> p6, b4 = (r8.yLL & M3) >> _3, k3 = (r8.xTR & v3) >> p6, N2 = (r8.yTR & M3) >> _3, I6 = a10 << 3 * y6 + 2 * (1 - y6), C2 = x3 << 2 * y6 + 3 * (1 - y6), G2 = I6 + 8 * y6 + 4 * (1 - y6), L5 = C2 + 4 * y6 + 8 * (1 - y6), S7 = Math.max(I6, T4), w4 = Math.max(C2, b4), R5 = Math.min(G2, k3), F4 = Math.min(L5, N2);
      let z = null, j7 = null;
      for (let r9 = w4; r9 <= F4; r9++)
        for (let t11 = S7; t11 <= R5; t11++) {
          const a11 = t11 - I6 + (r9 - C2) * (8 * y6 + 4 * (1 - y6)), l10 = e5.children[a11];
          if (l10) {
            if (r9 !== w4 && r9 !== F4 && t11 !== S7 && t11 !== R5) {
              const t12 = l10.xTotal / l10.count, e6 = l10.yTotal / l10.count;
              t12 > h9 && t12 <= u9 && e6 > c10 && e6 <= d9 && (s11 += l10.count, i7 += l10.xTotal, n12 += l10.yTotal, 1 === l10.count && (f9 = l10.referenceId), this._aggregateStatistics(o7, l10.statistics));
              continue;
            }
            z || (z = l10, z.next = e5.next), j7 && (j7.next = l10), j7 = l10, l10.next = e5.next;
          }
        }
      e5 = z || e5.next;
    }
    return { count: s11, attributes: this.normalizeStatistics(o7, s11), xTotal: i7, yTotal: n12, referenceId: f9 };
  }
  getBins(t9) {
    const e5 = [], { geohashBounds: s11, level: i7 } = t9;
    let n12 = this._root;
    for (; null !== n12; ) {
      const t10 = n12.depth, o7 = n12.xNode, a9 = n12.yNode;
      if (t10 >= i7) {
        e5.push(n12), n12 = n12.next;
        continue;
      }
      const r8 = Math.ceil((t10 + 1) / 2), l9 = Math.floor((t10 + 1) / 2), h9 = 1 - t10 % 2, c10 = 30 - (3 * r8 + 2 * l9), u9 = 30 - (2 * r8 + 3 * l9), d9 = ~((1 << c10) - 1), f9 = ~((1 << u9) - 1), x3 = (s11.xLL & d9) >> c10, m9 = (s11.yLL & f9) >> u9, g5 = (s11.xTR & d9) >> c10, y6 = (s11.yTR & f9) >> u9, p6 = o7 << 3 * h9 + 2 * (1 - h9), _3 = a9 << 2 * h9 + 3 * (1 - h9), v3 = p6 + 8 * h9 + 4 * (1 - h9), M3 = _3 + 4 * h9 + 8 * (1 - h9), T4 = Math.max(p6, x3), b4 = Math.max(_3, m9), k3 = Math.min(v3, g5), N2 = Math.min(M3, y6);
      let I6 = null, C2 = null;
      for (let e6 = b4; e6 <= N2; e6++)
        for (let t11 = T4; t11 <= k3; t11++) {
          const s12 = t11 - p6 + (e6 - _3) * (8 * h9 + 4 * (1 - h9)), i8 = n12.children[s12];
          i8 && (I6 || (I6 = i8, I6.next = n12.next), C2 && (C2.next = i8), C2 = i8, i8.next = n12.next);
        }
      n12 = I6 || n12.next;
    }
    return e5;
  }
  _linkChildren(t9) {
    let e5 = null, s11 = null;
    for (let i7 = 0; i7 <= t9.children.length; i7++) {
      const n12 = t9.children[i7];
      n12 && (e5 || (e5 = n12, e5.next = t9.next), s11 && (s11.next = n12), s11 = n12, n12.next = t9.next);
    }
    return e5;
  }
  _updateStatisticsCursor(t9, e5, s11) {
    for (const i7 of this._statisticFields) {
      const n12 = i7.name, o7 = i7.inField ? t9.readAttribute(i7.inField) : t9.getComputedNumericAtIndex(i7.inFieldIndex);
      switch (i7.statisticType) {
        case "min": {
          if (isNaN(o7))
            break;
          if (!e5.statistics[n12]) {
            e5.statistics[n12] = { value: o7 };
            break;
          }
          const t10 = e5.statistics[n12].value;
          e5.statistics[n12].value = Math.min(t10, o7);
          break;
        }
        case "max": {
          if (isNaN(o7))
            break;
          if (!e5.statistics[n12]) {
            e5.statistics[n12] = { value: o7 };
            break;
          }
          const t10 = e5.statistics[n12].value;
          e5.statistics[n12].value = Math.max(t10, o7);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg": {
          e5.statistics[n12] || (e5.statistics[n12] = { value: 0, nanCount: 0 });
          const t10 = e5.statistics[n12].value, i8 = e5.statistics[n12].nanCount ?? 0;
          null == o7 || isNaN(o7) ? e5.statistics[n12].nanCount = i8 + s11 : e5.statistics[n12].value = t10 + s11 * o7;
          break;
        }
        case "avg_angle": {
          e5.statistics[n12] || (e5.statistics[n12] = { x: 0, y: 0, nanCount: 0 });
          const t10 = e5.statistics[n12].x, i8 = e5.statistics[n12].y, a9 = e5.statistics[n12].nanCount ?? 0, r8 = Math.PI / 180;
          null == o7 || isNaN(o7) ? e5.statistics[n12].nanCount = a9 + s11 : (e5.statistics[n12].x = t10 + s11 * Math.cos(o7 * r8), e5.statistics[n12].y = i8 + s11 * Math.sin(o7 * r8));
          break;
        }
        case "mode": {
          e5.statistics[n12] || (e5.statistics[n12] = {});
          const t10 = e5.statistics[n12][o7] || 0;
          e5.statistics[n12][o7] = t10 + s11;
          break;
        }
      }
    }
  }
  _aggregateStatistics(t9, e5) {
    for (const s11 of this._statisticFields) {
      const i7 = s11.name;
      switch (s11.statisticType) {
        case "min": {
          if (!t9[i7]) {
            t9[i7] = { value: e5[i7].value };
            break;
          }
          const s12 = t9[i7].value;
          t9[i7].value = Math.min(s12, e5[i7].value);
          break;
        }
        case "max": {
          if (!t9[i7]) {
            t9[i7] = { value: e5[i7].value };
            break;
          }
          const s12 = t9[i7].value;
          t9[i7].value = Math.max(s12, e5[i7].value);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg":
        case "avg_angle":
        case "mode":
          t9[i7] || (t9[i7] = {});
          for (const s12 in e5[i7]) {
            const n12 = t9[i7][s12] || 0;
            t9[i7][s12] = n12 + e5[i7][s12];
          }
      }
    }
  }
  normalizeStatistics(t9, e5) {
    const s11 = {};
    for (const i7 of this._statisticFields) {
      const n12 = i7.name;
      switch (i7.statisticType) {
        case "min":
        case "max": {
          const i8 = t9[n12];
          if (!e5 || !i8)
            break;
          s11[n12] = i8.value;
          break;
        }
        case "count":
          if (!e5)
            break;
          s11[n12] = e5;
          break;
        case "sum": {
          if (!e5)
            break;
          const { value: i8, nanCount: o7 } = t9[n12];
          if (!(e5 - o7))
            break;
          s11[n12] = i8;
          break;
        }
        case "avg": {
          if (!e5)
            break;
          const { value: i8, nanCount: o7 } = t9[n12];
          if (!(e5 - o7))
            break;
          s11[n12] = i8 / (e5 - o7);
          break;
        }
        case "avg_angle": {
          if (!e5)
            break;
          const { x: i8, y: o7, nanCount: a9 } = t9[n12];
          if (!(e5 - a9))
            break;
          const r8 = i8 / (e5 - a9), l9 = o7 / (e5 - a9), h9 = 180 / Math.PI, c10 = Math.atan2(l9, r8) * h9;
          s11[n12] = c10;
          break;
        }
        case "mode": {
          const e6 = t9[n12];
          let i8 = 0, o7 = 0, a9 = null;
          for (const t10 in e6) {
            const s12 = e6[t10];
            s12 === i8 ? o7 += 1 : s12 > i8 && (i8 = s12, o7 = 1, a9 = t10);
          }
          s11[n12] = "null" === a9 || o7 > 1 ? null : a9;
          break;
        }
      }
    }
    return s11;
  }
};
var c9 = class {
  constructor(t9, e5, s11, i7) {
    this.count = 0, this.xTotal = 0, this.yTotal = 0, this.statistics = {}, this.displayId = 0, this.referenceId = 0, this.displayIds = /* @__PURE__ */ new Set(), this.next = null, this.depth = 0, this.xNode = 0, this.yNode = 0, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this._tree = t9, this.children = new Array(32);
    for (let n12 = 0; n12 < this.children.length; n12++)
      this.children[n12] = null;
    this.xNode = e5, this.yNode = s11, this.depth = i7;
  }
  realloc(t9, e5, s11) {
    for (let i7 = 0; i7 < this.children.length; i7++)
      this.children[i7] = null;
    return this.xNode = t9, this.yNode = e5, this.depth = s11, this.next = null, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this.displayId = 0, this.referenceId = 0, this.xTotal = 0, this.yTotal = 0, this.count = 0, this.statistics = {}, this.displayIds.clear(), this;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  add(t9) {
    this.displayIds.add(t9);
  }
  remove(t9) {
    this.displayIds.delete(t9);
  }
  getAttributes() {
    const t9 = this._tree.normalizeStatistics(this.statistics, this.count);
    return t9.referenceId = null, t9.aggregateId = this.id, t9.aggregateCount = this.count, t9;
  }
  getGeometry(t9, e5) {
    const o7 = this.getLngLatBounds(), [l9, h9, c10, u9] = o7, d9 = g2({ rings: [[[l9, h9], [l9, u9], [c10, u9], [c10, h9], [l9, h9]]] }, f.WGS84, t9), f9 = K(new t4(), d9, false, false);
    if (null != e5) {
      return ht(new t4(), f9, false, false, "esriGeometryPolygon", e5, false, false);
    }
    return f9;
  }
  getGeometryCentroid(t9, e5) {
    const i7 = this.getLngLatBounds(), [l9, h9, c10, u9] = i7, d9 = g2({ x: (l9 + c10) / 2, y: (h9 + u9) / 2 }, f.WGS84, t9), f9 = L(new t4(), d9);
    if (null != e5) {
      return ht(new t4(), f9, false, false, "esriGeometryPoint", e5, false, false);
    }
    return f9;
  }
  getLngLatBounds() {
    const t9 = this.depth, s11 = Math.ceil(t9 / 2), i7 = Math.floor(t9 / 2), n12 = 30 - (3 * s11 + 2 * i7), o7 = 30 - (2 * s11 + 3 * i7), a9 = this.xNode << n12, r8 = this.yNode << o7;
    return X({ geohashX: a9, geohashY: r8 }, this.depth);
  }
  find(t9, e5, s11, i7, n12, o7) {
    if (i7 >= s11)
      return this;
    const a9 = 1 - i7 % 2, r8 = 3 * a9 + 2 * (1 - a9), l9 = 2 * a9 + 3 * (1 - a9), h9 = 30 - n12 - r8, c10 = 30 - o7 - l9, u9 = ((t9 & 7 * a9 + 3 * (1 - a9) << h9) >> h9) + ((e5 & 3 * a9 + 7 * (1 - a9) << c10) >> c10) * (8 * a9 + 4 * (1 - a9)), d9 = this.children[u9];
    return null == d9 ? null : d9.find(t9, e5, s11, i7 + 1, n12 + r8, o7 + l9);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/BinStore.js
var S5 = s.getLogger("esri.view.2d.layers.features.support.BinStore");
var F2 = 12;
var G = 64;
var R3 = i3();
var L3 = 5;
function T(e5) {
  return 57.29577951308232 * e5;
}
var A = class extends a5 {
  constructor(t9, s11, r8, i7) {
    super(t9, r8), this.type = "bin", this.events = new n3(), this.objectIdField = "aggregateId", this.featureAdapter = I2, this._geohashLevel = L3, this._geohashBuf = [], this._serviceInfo = i7, this.geometryInfo = t9.geometryInfo, this._spatialReference = s11, this._projectionSupportCheck = f3(s11, f.WGS84), this._bitsets.geohash = r8.getBitset(r8.createBitset()), this._bitsets.inserted = r8.getBitset(r8.createBitset());
  }
  destroy() {
    this._tree && this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e5, t9) {
    const s11 = this._schema;
    try {
      await super.updateSchema(e5, t9), await this._projectionSupportCheck;
    } catch (h9) {
    }
    this._fields = this._schema.params.fields;
    const a9 = a3(s11, t9);
    t9 && (null != a9 || e5.source || e5.storage.filters) ? ((s7(a9, "params.fields") || s7(a9, "params") || !this._tree || e5.source) && (this._tree && this._tree.destroy(), this._tree = new h7(this._statisticFields, this._serviceInfo), this._tree.onRelease = (e6) => e6.displayId && this._storage.releaseDisplayId(e6.displayId), this._geohashLevel = this._schema.params.fixedBinLevel, this._rebuildTree(), has("esri-2d-update-debug") && S5.info("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && S5.info("Aggregate mesh needs update due to tree changing"), e5.targets[t9.name] = true, e5.mesh = false) : s11 && (e5.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e5, t9) {
    this._bitsets.inserted.forEachSet((s11) => {
      if (!e5.has(s11)) {
        const e6 = t9.lookupByDisplayIdUnsafe(s11);
        this._remove(e6);
      }
    });
  }
  sweepAggregates(e5, t9, s11) {
  }
  onTileData(e5, t9, s11, r8, i7 = true) {
    if (!this._schema || null == t9.addOrUpdate)
      return t9;
    this.events.emit("changed");
    const o7 = this._getTransforms(e5, this._spatialReference);
    {
      const e6 = t9.addOrUpdate.getCursor();
      for (; e6.next(); )
        this._update(e6, r8);
    }
    if (t9.status.mesh || !i7)
      return t9;
    const a9 = new Array();
    this._getBinsForTile(a9, e5, o7, s11), t9.addOrUpdate = h4.fromOptimizedFeatures(a9, { fields: this.fields, geometryType: "esriGeometryPolygon", objectIdField: this.objectIdField }), t9.addOrUpdate.attachStorage(s11), t9.end = true, t9.isRepush || (t9.clear = true);
    {
      const r9 = t9.addOrUpdate.getCursor();
      for (; r9.next(); ) {
        const t10 = r9.getDisplayId();
        this._bitsets.computed.unset(t10), this.setComputedAttributes(s11, r9, t10, e5.scale);
      }
    }
    return t9;
  }
  forEachBin(e5) {
    this._tree.forEach(e5);
  }
  forEach(e5) {
    this._tree.forEach((t9) => {
      if (t9.depth !== this._geohashLevel)
        return;
      const s11 = this._toFeatureJSON(t9), r8 = h4.fromFeatures([s11], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields }).getCursor();
      r8.next(), e5(r8);
    });
  }
  forEachInBounds(e5, t9) {
  }
  forEachBounds(e5, t9) {
    const { hasM: s11, hasZ: r8 } = this.geometryInfo;
    for (const i7 of e5) {
      const e6 = yt(R3, i7.readGeometry(), r8, s11);
      null != e6 && t9(e6);
    }
  }
  onTileUpdate(e5) {
  }
  getAggregate(e5) {
    const t9 = s8(e5, true), r8 = this._tree.findIf((e6) => e6.displayId === t9);
    return n2(r8, (e6) => this._toFeatureJSON(e6));
  }
  getAggregates() {
    return this._tree.findAllIf((e5) => e5.depth === this._geohashLevel).map(this._toFeatureJSON.bind(this));
  }
  getDisplayId(e5) {
    const t9 = this._tree.findIf((t10) => t10.id === e5);
    return n2(t9, (e6) => e6.displayId);
  }
  getFeatureDisplayIdsForAggregate(e5) {
    const t9 = this._tree.findIf((t10) => t10.id === e5);
    return null != t9 ? Array.from(t9.displayIds) : [];
  }
  getDisplayIdForReferenceId(e5) {
    const t9 = this._tree.findIf((t10) => 1 === t10.displayIds.size && t10.displayIds.has(e5));
    return n2(t9, (e6) => e6.displayId);
  }
  _toFeatureJSON(e5) {
    const t9 = this._spatialReference;
    return { displayId: e5.displayId, attributes: e5.getAttributes(), geometry: st(e5.getGeometry(t9), "esriGeometryPolygon", false, false), centroid: null };
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e5) {
    const t9 = e5.getDisplayId(), s11 = e5.getXHydrated(), r8 = e5.getYHydrated(), i7 = this._geohashBuf[2 * t9], o7 = this._geohashBuf[2 * t9 + 1];
    this._bitsets.inserted.has(t9) && (this._bitsets.inserted.unset(t9), this._tree.removeCursor(e5, s11, r8, i7, o7, this._geohashLevel));
  }
  _update(e5, t9) {
    const s11 = e5.getDisplayId(), r8 = this._bitsets.inserted, i7 = t9.isVisible(s11);
    if (i7 === r8.has(s11))
      return;
    if (!i7)
      return void this._remove(e5);
    const o7 = e5.getXHydrated(), a9 = e5.getYHydrated();
    if (!this._setGeohash(s11, o7, a9))
      return;
    const h9 = this._geohashBuf[2 * s11], n12 = this._geohashBuf[2 * s11 + 1];
    this._tree.insertCursor(e5, s11, o7, a9, h9, n12, this._geohashLevel), r8.set(s11);
  }
  _setGeohash(e5, t9, s11) {
    if (this._bitsets.geohash.has(e5))
      return true;
    const r8 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const i7 = T(t9 / s5.radius), o7 = i7 - 360 * Math.floor((i7 + 180) / 360), h9 = T(Math.PI / 2 - 2 * Math.atan(Math.exp(-s11 / s5.radius)));
      b3(r8, e5, h9, o7, F2);
    } else {
      const i7 = g2({ x: t9, y: s11 }, this._spatialReference, f.WGS84);
      if (!i7)
        return false;
      b3(r8, e5, i7.y, i7.x, F2);
    }
    return this._bitsets.geohash.set(e5), true;
  }
  _getBinsForTile(e5, t9, s11, r8) {
    try {
      const i7 = this._getGeohashBounds(t9), o7 = this._tree.getBins(i7);
      for (const t10 of o7) {
        t10.displayId || (t10.displayId = r8.createDisplayId(true));
        let i8 = null;
        const o8 = t10.getGeometry(this._spatialReference, s11.tile);
        o8 || (i8 = t10.getGeometryCentroid(this._spatialReference, s11.tile));
        const a9 = new t3(o8, t10.getAttributes(), i8);
        a9.objectId = t10.id, a9.displayId = t10.displayId, e5.push(a9);
      }
    } catch (i7) {
      return void S5.error("Unable to get bins for tile", t9.key.id);
    }
  }
  _getGeohash(e5, t9, s11) {
    const r8 = { geohashX: 0, geohashY: 0 };
    return Y(r8, t9, e5, s11), r8;
  }
  _getGeohashBounds(e5) {
    const t9 = this._getGeohashLevel(e5.key.level), s11 = [e5.extent.xmin, e5.extent.ymin, e5.extent.xmax, e5.extent.ymax], r8 = j2.fromExtent(M.fromBounds(s11, this._spatialReference)), i7 = g2(r8, this._spatialReference, f.WGS84, { densificationStep: e5.resolution * G }), o7 = K(new t4(), i7, false, false), a9 = o7.coords.filter((e6, t10) => !(t10 % 2)), h9 = o7.coords.filter((e6, t10) => t10 % 2), n12 = Math.min(...a9), d9 = Math.min(...h9), l9 = Math.max(...a9), g5 = Math.max(...h9), p6 = this._getGeohash(n12, d9, t9), c10 = this._getGeohash(l9, g5, t9);
    return { bounds: s11, geohashBounds: { xLL: p6.geohashX, yLL: p6.geohashY, xTR: c10.geohashX, yTR: c10.geohashY }, level: t9 };
  }
  _getGeohashLevel(e5) {
    return this._schema.params.fixedBinLevel;
  }
  _getTransforms(e5, t9) {
    const s11 = { originPosition: "upperLeft", scale: [e5.resolution, e5.resolution], translate: [e5.bounds[0], e5.bounds[3]] }, r8 = d2(t9);
    if (!r8)
      return { tile: s11, left: null, right: null };
    const [i7, o7] = r8.valid;
    return { tile: s11, left: { ...s11, translate: [o7, e5.bounds[3]] }, right: { ...s11, translate: [i7 - o7 + e5.bounds[0], e5.bounds[3]] } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ClusterStore.js
var F3 = 12;
var L4 = 64;
var B2 = 1;
var w2 = i3();
var S6 = class _S extends e2 {
  constructor(e5, t9, s11, r8, o7) {
    super(new t4([], [t9, s11]), r8, null, e5), this.geohashBoundsInfo = o7;
  }
  get count() {
    return this.attributes.cluster_count;
  }
  static create(e5, t9, s11, r8, o7, i7, a9, h9) {
    const n12 = new _S(t9, s11, r8, i7, a9);
    return n12.displayId = e5.createDisplayId(true), n12.referenceId = h9, n12.tileLevel = o7, n12;
  }
  update(e5, t9, s11, r8, o7, i7) {
    return this.geometry.coords[0] = e5, this.geometry.coords[1] = t9, this.tileLevel = s11, this.attributes = r8, this.geohashBoundsInfo = o7, this.referenceId = null, this.referenceId = i7, this;
  }
  toJSON() {
    return { attributes: { ...this.attributes, aggregateId: this.objectId, referenceId: 1 === this.attributes.cluster_count ? this.referenceId : null }, geometry: { x: this.geometry.coords[0], y: this.geometry.coords[1] } };
  }
};
function T2(e5) {
  return 57.29577951308232 * e5;
}
var V2 = class extends a5 {
  constructor(t9, s11, r8, o7) {
    super(t9, r8), this.type = "cluster", this.events = new n3(), this.objectIdField = "aggregateId", this.featureAdapter = I2, this._geohashLevel = 0, this._tileLevel = 0, this._aggregateValueRanges = {}, this._aggregateValueRangesChanged = false, this._geohashBuf = [], this._clusters = /* @__PURE__ */ new Map(), this._tiles = /* @__PURE__ */ new Map(), this._serviceInfo = o7, this.geometryInfo = t9.geometryInfo, this._spatialReference = s11, this._projectionSupportCheck = f3(s11, f.WGS84), this._bitsets.geohash = r8.getBitset(r8.createBitset()), this._bitsets.inserted = r8.getBitset(r8.createBitset());
  }
  destroy() {
    this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e5, t9) {
    const i7 = this._schema;
    try {
      await super.updateSchema(e5, t9), await this._projectionSupportCheck;
    } catch (h9) {
    }
    this._fields = [...this._schema.params.fields, { name: "referenceId", alias: "referenceId", type: "esriFieldTypeInteger" }];
    !!this._fields.some((e6) => "cluster_count" === e6.name) || this._fields.push({ name: "cluster_count", alias: "cluster_count", type: "esriFieldTypeInteger" });
    const a9 = a3(i7, t9);
    t9 && (null != a9 || e5.source || e5.storage.filters) ? ((s7(a9, "params.fields") || !this._tree || e5.source) && (this._tree && this._tree.destroy(), this._tree = new h7(this._statisticFields, this._serviceInfo), this._rebuildTree(), has("esri-2d-update-debug") && console.debug("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && console.debug("Applying Update - ClusterStore:", a9), e5.targets[t9.name] = true, e5.mesh = false, this._aggregateValueRanges = {}) : i7 && (e5.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e5, t9) {
    this._bitsets.inserted.forEachSet((s11) => {
      if (!e5.has(s11)) {
        const e6 = t9.lookupByDisplayIdUnsafe(s11);
        this._remove(e6);
      }
    });
  }
  sweepAggregates(e5, t9, s11) {
    this._clusters.forEach((r8, o7) => {
      r8 && r8.tileLevel !== s11 && (e5.releaseDisplayId(r8.displayId), t9.unsetAttributeData(r8.displayId), this._clusters.delete(o7));
    });
  }
  onTileData(e5, t9, s11, r8, o7 = true) {
    if (!this._schema || null == t9.addOrUpdate)
      return t9;
    this.events.emit("changed");
    const i7 = this._getTransforms(e5, this._spatialReference);
    {
      const e6 = t9.addOrUpdate.getCursor();
      for (; e6.next(); )
        this._update(e6, r8);
    }
    if (t9.status.mesh || !o7)
      return t9;
    const a9 = new Array(), h9 = this._schema.params.clusterRadius;
    this._getClustersForTile(a9, e5, h9, s11, i7), t9.addOrUpdate = h4.fromOptimizedFeatures(a9, { fields: this.fields, geometryType: "esriGeometryPoint", objectIdField: this.objectIdField }), t9.addOrUpdate.attachStorage(s11), t9.clear = true, t9.end = true;
    {
      const r9 = t9.addOrUpdate.getCursor();
      for (; r9.next(); ) {
        const t10 = r9.getDisplayId();
        this._bitsets.computed.unset(t10), this.setComputedAttributes(s11, r9, t10, e5.scale);
      }
    }
    return this._aggregateValueRangesChanged && t9.end && (this.events.emit("valueRangesChanged", { valueRanges: this._aggregateValueRanges }), this._aggregateValueRangesChanged = false), t9;
  }
  onTileUpdate({ added: e5, removed: t9 }) {
    if (e5.length) {
      const t10 = e5[0].level;
      this._tileLevel = t10, this._setGeohashLevel(t10);
    }
    if (!this._schema)
      return;
    const s11 = this._schema.params.clusterRadius;
    t9.forEach((e6) => {
      this._tiles.delete(e6.key.id), this._markTileClustersForDeletion(e6, s11);
    });
  }
  getAggregate(e5) {
    for (const t9 of this._clusters.values())
      if (((t9 == null ? void 0 : t9.displayId) & n5) == (e5 & n5))
        return t9.toJSON();
    return null;
  }
  getAggregates() {
    const e5 = [];
    for (const t9 of this._clusters.values())
      (t9 == null ? void 0 : t9.tileLevel) === this._tileLevel && e5.push(t9.toJSON());
    return e5;
  }
  getDisplayId(e5) {
    const t9 = this._clusters.get(e5);
    return t9 ? t9.displayId : null;
  }
  getFeatureDisplayIdsForAggregate(e5) {
    const t9 = this._clusters.get(e5);
    return t9 ? this._tree.getRegionDisplayIds(t9.geohashBoundsInfo) : [];
  }
  getDisplayIdForReferenceId(e5) {
    for (const t9 of this._clusters.values())
      if ((t9 == null ? void 0 : t9.referenceId) === e5)
        return t9.displayId;
    return null;
  }
  getAggregateValueRanges() {
    return this._aggregateValueRanges;
  }
  forEach(e5) {
    this._clusters.forEach((t9) => {
      if (!t9)
        return;
      const s11 = t9.toJSON(), r8 = h4.fromFeatures([s11], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields }).getCursor();
      r8.next(), e5(r8);
    });
  }
  forEachInBounds(e5, t9) {
  }
  forEachBounds(e5, t9) {
    const { hasM: s11, hasZ: r8 } = this.geometryInfo;
    for (const o7 of e5) {
      const e6 = yt(w2, o7.readGeometry(), r8, s11);
      null != e6 && t9(e6);
    }
  }
  size() {
    let e5 = 0;
    return this.forEach((t9) => e5++), e5;
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e5) {
    const t9 = e5.getDisplayId(), s11 = e5.getXHydrated(), r8 = e5.getYHydrated(), o7 = this._geohashBuf[2 * t9], i7 = this._geohashBuf[2 * t9 + 1];
    this._bitsets.inserted.has(t9) && (this._bitsets.inserted.unset(t9), this._tree.removeCursor(e5, s11, r8, o7, i7, this._geohashLevel));
  }
  _update(e5, t9) {
    const s11 = e5.getDisplayId(), r8 = this._bitsets.inserted, o7 = t9.isVisible(s11);
    if (o7 === r8.has(s11))
      return;
    if (!o7)
      return void this._remove(e5);
    const i7 = e5.getXHydrated(), a9 = e5.getYHydrated();
    if (!this._setGeohash(s11, i7, a9))
      return;
    const h9 = this._geohashBuf[2 * s11], n12 = this._geohashBuf[2 * s11 + 1];
    this._tree.insertCursor(e5, s11, i7, a9, h9, n12, this._geohashLevel), r8.set(s11);
  }
  _setGeohash(e5, t9, s11) {
    if (this._bitsets.geohash.has(e5))
      return true;
    const r8 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const o7 = T2(t9 / s5.radius), a9 = o7 - 360 * Math.floor((o7 + 180) / 360), h9 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-s11 / s5.radius)));
      b3(r8, e5, h9, a9, F3);
    } else {
      const o7 = g2({ x: t9, y: s11 }, this._spatialReference, f.WGS84);
      if (!o7)
        return false;
      b3(r8, e5, o7.y, o7.x, F3);
    }
    return this._bitsets.geohash.set(e5), true;
  }
  _getClustersForTile(e5, s11, r8, o7, i7, a9 = true) {
    const h9 = this._schema.params.clusterPixelBuffer, n12 = 2 * r8, l9 = Math.ceil(2 ** s11.key.level * c3 / n12) + 1, u9 = Math.ceil(h9 / n12) + 0, d9 = Math.ceil(c3 / n12), { row: f9, col: m9 } = s11.key, _3 = m9 * c3, y6 = f9 * c3, b4 = Math.floor(_3 / n12) - u9, v3 = Math.floor(y6 / n12) - u9, R5 = b4 + d9 + 2 * u9, M3 = v3 + d9 + 2 * u9, x3 = s11.tileInfoView.getLODInfoAt(s11.key.level);
    for (let I6 = b4; I6 <= R5; I6++)
      for (let r9 = v3; r9 <= M3; r9++) {
        let h10 = I6;
        x3.wrap && (h10 = I6 < 0 ? I6 + l9 : I6 % l9);
        const n13 = x3.wrap && I6 < 0, u10 = x3.wrap && I6 % l9 !== I6, d10 = this._lookupCluster(o7, x3, s11.key.level, h10, r9, s11);
        if (null != d10) {
          const s12 = n2(i7, (e6) => n13 ? e6.left : u10 ? e6.right : e6.tile);
          if (a9 && null == s12)
            continue;
          if (!d10.count)
            continue;
          if (null != s12 && a9) {
            const t9 = d10.geometry.clone();
            let r10 = d10.attributes;
            t9.coords[0] = M2(s12, t9.coords[0]), t9.coords[1] = N(s12, t9.coords[1]), 1 === d10.count && null != d10.referenceId && (r10 = { ...d10.attributes, referenceId: d10.referenceId });
            const o8 = new t3(t9, r10);
            o8.displayId = d10.displayId, e5.push(o8);
          }
        }
      }
  }
  _getGeohashLevel(e5) {
    return Math.min(Math.ceil(e5 / 2 + 2), F3);
  }
  _setGeohashLevel(e5) {
    const t9 = this._getGeohashLevel(e5), s11 = (Math.floor(t9 / B2) + 1) * B2 - 1;
    if (this._geohashLevel !== s11)
      return this._geohashLevel = s11, this._rebuildTree(), void this._bitsets.geohash.clear();
  }
  _getTransforms(e5, t9) {
    const s11 = { originPosition: "upperLeft", scale: [e5.resolution, e5.resolution], translate: [e5.bounds[0], e5.bounds[3]] }, r8 = d2(t9);
    if (!r8)
      return { tile: s11, left: null, right: null };
    const [o7, i7] = r8.valid;
    return { tile: s11, left: { ...s11, translate: [i7, e5.bounds[3]] }, right: { ...s11, translate: [o7 - i7 + e5.bounds[0], e5.bounds[3]] } };
  }
  _getClusterId(e5, t9, s11) {
    return (15 & e5) << 28 | (16383 & t9) << 14 | 16383 & s11;
  }
  _markForDeletion(e5, t9, s11) {
    const r8 = this._getClusterId(e5, t9, s11);
    this._clusters.delete(r8);
  }
  _getClusterBounds(e5, t9, s11) {
    const r8 = this._schema.params.clusterRadius, o7 = 2 * r8;
    let i7 = s11 % 2 ? t9 * o7 : t9 * o7 - r8;
    const a9 = s11 * o7;
    let h9 = i7 + o7;
    const n12 = a9 - o7, l9 = 2 ** e5.level * c3;
    e5.wrap && i7 < 0 && (i7 = 0), e5.wrap && h9 > l9 && (h9 = l9);
    const u9 = i7 / c3, g5 = a9 / c3, c10 = h9 / c3, d9 = n12 / c3;
    return [e5.getXForColumn(u9), e5.getYForRow(g5), e5.getXForColumn(c10), e5.getYForRow(d9)];
  }
  _getGeohash(e5, t9, s11) {
    const r8 = { geohashX: 0, geohashY: 0 };
    return Y(r8, t9, e5, s11), r8;
  }
  _getGeohashBounds(e5, t9) {
    const s11 = this._getGeohashLevel(e5.key.level);
    if (this._spatialReference.isWebMercator) {
      const [e6, r9, o8, i8] = t9, h10 = { x: e6, y: r9 }, l10 = { x: o8, y: i8 };
      let u10 = 0, g6 = 0, c11 = 0, d9 = 0;
      {
        const e7 = T2(h10.x / s5.radius);
        u10 = e7 - 360 * Math.floor((e7 + 180) / 360), g6 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-h10.y / s5.radius)));
      }
      {
        const e7 = T2(l10.x / s5.radius);
        c11 = e7 - 360 * Math.floor((e7 + 180) / 360), d9 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-l10.y / s5.radius)));
      }
      const f10 = { geohashX: 0, geohashY: 0 }, p7 = { geohashX: 0, geohashY: 0 };
      Y(f10, g6, u10, s11), Y(p7, d9, c11, s11);
      return { bounds: [e6, r9, o8, i8], geohashBounds: { xLL: f10.geohashX, yLL: f10.geohashY, xTR: p7.geohashX, yTR: p7.geohashY }, level: s11 };
    }
    const r8 = j2.fromExtent(M.fromBounds(t9, this._spatialReference)), o7 = g2(r8, this._spatialReference, f.WGS84, { densificationStep: e5.resolution * L4 });
    if (!o7)
      return null;
    const i7 = K(new t4(), o7, false, false), h9 = i7.coords.filter((e6, t10) => !(t10 % 2)), l9 = i7.coords.filter((e6, t10) => t10 % 2), u9 = Math.min(...h9), g5 = Math.min(...l9), c10 = Math.max(...h9), f9 = Math.max(...l9), p6 = this._getGeohash(u9, g5, s11), _3 = this._getGeohash(c10, f9, s11);
    return { bounds: t9, geohashBounds: { xLL: p6.geohashX, yLL: p6.geohashY, xTR: _3.geohashX, yTR: _3.geohashY }, level: s11 };
  }
  _lookupCluster(e5, t9, s11, r8, o7, i7) {
    const a9 = this._getClusterId(s11, r8, o7), h9 = this._clusters.get(a9), n12 = this._getClusterBounds(t9, r8, o7), l9 = this._getGeohashBounds(i7, n12);
    if (null == l9)
      return null;
    const u9 = this._tree.getRegionStatistics(l9), { count: g5, xTotal: c10, yTotal: d9, referenceId: f9 } = u9, p6 = g5 ? c10 / g5 : 0, m9 = g5 ? d9 / g5 : 0;
    if (0 === g5)
      return this._clusters.set(a9, null), null;
    const _3 = { cluster_count: g5, ...u9.attributes }, y6 = null != h9 ? h9.update(p6, m9, s11, _3, l9, f9) : S6.create(e5, a9, p6, m9, s11, _3, l9, f9);
    if (0 === g5) {
      const [e6, t10, s12, r9] = n12;
      y6.geometry.coords[0] = (e6 + s12) / 2, y6.geometry.coords[1] = (t10 + r9) / 2;
    }
    return this._clusters.set(a9, y6), this._updateAggregateValueRangeForCluster(y6, y6.tileLevel), y6;
  }
  _updateAggregateValueRangeForCluster(e5, t9) {
    const s11 = this._aggregateValueRanges[t9] || { minValue: 1 / 0, maxValue: 0 }, r8 = s11.minValue, o7 = s11.maxValue;
    s11.minValue = Math.min(r8, e5.count), s11.maxValue = Math.max(o7, e5.count), this._aggregateValueRanges[t9] = s11, r8 === s11.minValue && o7 === s11.maxValue || (this._aggregateValueRangesChanged = true);
  }
  _markTileClustersForDeletion(e5, t9) {
    const s11 = 2 * t9, r8 = Math.ceil(c3 / s11), { row: o7, col: i7 } = e5.key, a9 = i7 * c3, h9 = o7 * c3, n12 = Math.floor(a9 / s11), l9 = Math.floor(h9 / s11);
    for (let u9 = n12; u9 < n12 + r8; u9++)
      for (let t10 = l9; t10 < l9 + r8; t10++)
        this._markForDeletion(e5.key.level, u9, t10);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var r5 = class {
  constructor() {
    this._freeIds = [], this._idCounter = 1;
  }
  createId(r8 = false) {
    return s8(this._getFreeId(), r8);
  }
  releaseId(e5) {
    this._freeIds.push(e5);
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
function n9(t9, e5, s11) {
  if (!(t9.length > e5))
    for (; t9.length <= e5; )
      t9.push(s11);
}
var r6 = class {
  constructor() {
    this._numerics = [], this._strings = [], this._idGenerator = new r5(), this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [];
  }
  createBitset() {
    const e5 = this._bitsets.length;
    return this._bitsets.push(t7.create(this._allocatedSize, n5)), e5 + 1;
  }
  getBitset(t9) {
    return this._bitsets[t9 - 1];
  }
  _expand() {
    this._allocatedSize <<= 1;
    for (const t9 of this._bitsets)
      t9.resize(this._allocatedSize);
  }
  _ensureNumeric(t9, e5) {
    this._numerics[t9] || (this._numerics[t9] = []);
    n9(this._numerics[t9], e5, 0);
  }
  _ensureInstanceId(t9) {
    n9(this._instanceIds, t9, 0);
  }
  _ensureString(t9, e5) {
    this._strings[t9] || (this._strings[t9] = []);
    n9(this._strings[t9], e5, null);
  }
  createDisplayId(t9 = false) {
    const s11 = this._idGenerator.createId();
    return s11 > this._allocatedSize && this._expand(), s8(s11, t9);
  }
  releaseDisplayId(e5) {
    for (const t9 of this._bitsets)
      t9.unset(e5);
    return this._idGenerator.releaseId(e5 & n5);
  }
  getComputedNumeric(e5, s11) {
    return this.getComputedNumericAtIndex(e5 & n5, 0);
  }
  setComputedNumeric(e5, s11, i7) {
    return this.setComputedNumericAtIndex(e5 & n5, i7, 0);
  }
  getComputedString(e5, s11) {
    return this.getComputedStringAtIndex(e5 & n5, 0);
  }
  setComputedString(e5, s11, i7) {
    return this.setComputedStringAtIndex(e5 & n5, 0, i7);
  }
  getComputedNumericAtIndex(e5, s11) {
    const i7 = e5 & n5;
    return this._ensureNumeric(s11, i7), this._numerics[s11][i7];
  }
  setComputedNumericAtIndex(e5, s11, i7) {
    const n12 = e5 & n5;
    this._ensureNumeric(s11, n12), this._numerics[s11][n12] = i7;
  }
  getInstanceId(e5) {
    const s11 = e5 & n5;
    return this._ensureInstanceId(s11), this._instanceIds[s11];
  }
  setInstanceId(e5, s11) {
    const i7 = e5 & n5;
    this._ensureInstanceId(i7), this._instanceIds[i7] = s11;
  }
  getComputedStringAtIndex(e5, s11) {
    const i7 = e5 & n5;
    return this._ensureString(s11, i7), this._strings[s11][i7];
  }
  setComputedStringAtIndex(e5, s11, i7) {
    const n12 = e5 & n5;
    this._ensureString(s11, n12), this._strings[s11][n12] = i7;
  }
  getXMin(e5) {
    return this._bounds[4 * (e5 & n5)];
  }
  getYMin(e5) {
    return this._bounds[4 * (e5 & n5) + 1];
  }
  getXMax(e5) {
    return this._bounds[4 * (e5 & n5) + 2];
  }
  getYMax(e5) {
    return this._bounds[4 * (e5 & n5) + 3];
  }
  setBounds(e5, s11) {
    const i7 = s11.readHydratedGeometry();
    if (!i7 || !i7.coords.length)
      return false;
    let r8 = 1 / 0, u9 = 1 / 0, o7 = -1 / 0, h9 = -1 / 0;
    i7.forEachVertex((t9, e6) => {
      r8 = Math.min(r8, t9), u9 = Math.min(u9, e6), o7 = Math.max(o7, t9), h9 = Math.max(h9, e6);
    });
    const d9 = e5 & n5;
    return n9(this._bounds, 4 * d9 + 4, 0), this._bounds[4 * d9] = r8, this._bounds[4 * d9 + 1] = u9, this._bounds[4 * d9 + 2] = o7, this._bounds[4 * d9 + 3] = h9, true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/FeatureController2D.js
var E2 = 5e3;
var w3 = "tileRenderer.featuresView.attributeView.initialize";
var T3 = "tileRenderer.featuresView.attributeView.requestUpdate";
var j6 = "tileRenderer.featuresView.requestRender";
function k2(e5) {
  return "worker:port-closed" === e5.name;
}
function A2(e5) {
  if (!d(e5) && !k2(e5))
    throw e5;
}
function x2(e5) {
  return "feature" === e5.type && "snapshot" === e5.mode;
}
var U2 = class extends d3 {
  constructor() {
    super(...arguments), this._storage = new r6(), this._markedIdsBufId = this._storage.createBitset(), this._lastCleanup = performance.now(), this._cleanupNeeded = false, this._invalidated = false, this._tileToResolver = /* @__PURE__ */ new Map(), this._didEdit = false, this._updateVersion = 1, this.tileStore = null, this.config = null, this.processor = null, this.remoteClient = null, this.service = null;
  }
  initialize() {
    this._initStores(), this._initSource(), this._updateQueue = new u3({ concurrency: "stream" === this._source.type ? 1 : 4, process: (e5, t9) => this._onTileMessage(e5, { signal: t9 }) }), this.addHandles([this.tileStore.on("update", this.onTileUpdate.bind(this)), f2(() => !this.updating, () => this.onIdle())]);
  }
  _initSource() {
    const e5 = this.tileStore.tileScheme, t9 = () => this._updateQueue && this._updateQueue.length < 50, r8 = (e6, t10) => (this._invalidated = true, this._patchTile(e6, t10));
    this._source = n7(this.service, this.spatialReference, e5, r8, t9, this.featureStore), this._proxyEvents();
  }
  _setStreamClientProperty(e5, t9) {
    this.remoteClient.invoke("setProperty", { propertyName: e5, value: t9 }).catch(A2);
  }
  _proxyEvents() {
    if ("stream" === this._source.type) {
      const e5 = this._source.events, t9 = this._source;
      this.addHandles([l(() => t9.connectionStatus, (e6) => this._setStreamClientProperty("pipelineConnectionStatus", e6), { initial: true }), l(() => t9.errorString, (e6) => this._setStreamClientProperty("pipelineErrorString", e6), { initial: true }), e5.on("data-received", (e6) => this.remoteClient.invoke("emitEvent", { name: "data-received", event: { attributes: e6.attributes, centroid: e6.centroid, geometry: e6.geometry } }).catch(A2)), e5.on("message-received", (e6) => this.remoteClient.invoke("emitEvent", { name: "message-received", event: e6 }).catch(A2)), e5.on("updateRate", (e6) => this.remoteClient.invoke("emitEvent", { name: "update-rate", event: { ...e6 } }).catch(A2))]);
    }
  }
  _initAttributeStore(e5) {
    this.attributeStore || (this.attributeStore = new B({ type: "remote", initialize: (e6, t9) => y2(this.remoteClient.invoke(w3, e6, { signal: t9 }).catch(A2)), update: (e6, t9) => y2(this.remoteClient.invoke(T3, e6, { signal: t9 }).catch(A2)), render: (e6) => y2(this.remoteClient.invoke(j6, void 0, { signal: e6 }).catch(A2)) }, e5));
  }
  _initStores() {
    const e5 = "snapshot" === this.service.type ? "snapshot" : "on-demand", t9 = { geometryInfo: { geometryType: this.service.geometryType, hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
    this.featureStore = new u4(t9, this._storage, e5);
  }
  _initQueryEngine(e5) {
    var _a;
    const t9 = this;
    (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), this.featureQueryEngine = new ee({ definitionExpression: e5.schema.source.definitionExpression ?? void 0, fields: this.service.fields, geometryType: this.service.geometryType, objectIdField: this.service.objectIdField, hasM: false, hasZ: false, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: true, featureStore: this.featureStore, aggregateAdapter: { getFeatureObjectIds(e6) {
      if (null == t9.aggregateStore)
        return [];
      return t9.aggregateStore.getFeatureDisplayIdsForAggregate(e6).map((e7) => t9.getObjectId(e7));
    } }, timeInfo: this.service.timeInfo });
  }
  _initAggregateQueryEngine(e5, t9) {
    var _a;
    if ((_a = this.aggregateQueryEngine) == null ? void 0 : _a.destroy(), null == e5)
      return;
    const r8 = t9.targets.aggregate.params.fields.slice();
    this.aggregateQueryEngine = new ee({ definitionExpression: void 0, fields: r8, geometryType: e5.geometryInfo.geometryType, objectIdField: e5.objectIdField, hasM: e5.geometryInfo.hasM, hasZ: e5.geometryInfo.hasZ, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: false, featureStore: e5, aggregateAdapter: { getFeatureObjectIds: (e6) => [] } });
  }
  destroy() {
    var _a, _b, _c;
    this._updateQueue.destroy(), this._source.destroy(), (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), (_b = this.aggregateQueryEngine) == null ? void 0 : _b.destroy(), (_c = this.attributeStore) == null ? void 0 : _c.destroy();
    for (const e5 of this.tileStore.tiles)
      this._source.unsubscribe(e5);
    clearInterval(this._checkUpdating);
  }
  get fieldsIndex() {
    return new r2(this.service.fields);
  }
  get spatialReference() {
    return this.tileStore.tileScheme.spatialReference;
  }
  get updating() {
    return this.isUpdating();
  }
  isUpdating() {
    const e5 = this._source.updatingHandles.updating, t9 = !this.attributeStore || this.attributeStore.updatingHandles.updating, r8 = e5 || t9 || this.updatingHandles.updating;
    if (has("esri-2d-log-updating")) {
      let s11 = `Updating FeatureController2D: ${r8}
`;
      s11 += `  -> updatingSource ${e5}
`;
      for (const e6 of this._source.subscriptions)
        s11 += `     ${e6.tile.id} ${e6.isDone}
`;
      s11 += `  -> updatingAttributeStore ${t9}
`, s11 += `  -> updatingHandles ${this.updatingHandles.updating} (queue: ${this._updateQueue.length})
`, console.log(s11);
    }
    return r8;
  }
  updateCustomParameters(e5) {
    "stream" === this._source.type && this._source.updateCustomParameters(e5);
  }
  enableEvent(e5) {
    this._source.enableEvent(e5.name, e5.value);
  }
  pause() {
    this._updateQueue.pause(), this._updateQueue.clear();
  }
  resume() {
    this._updateQueue.resume();
  }
  pauseStream() {
    "stream" === this._source.type && this._source.pauseStream();
  }
  resumeStream() {
    "stream" === this._source.type && this._source.resumeStream();
  }
  sendMessageToSocket(e5) {
    "stream" === this._source.type && this._source.sendMessageToSocket(e5);
  }
  sendMessageToClient(e5) {
    "stream" === this._source.type && this._source.sendMessageToClient(e5);
  }
  _initAggregateStore(e5) {
    var _a, _b;
    const t9 = (_b = (_a = e5.schema.targets) == null ? void 0 : _a.aggregate) == null ? void 0 : _b.type, r8 = n2(this.config, (e6) => {
      var _a2, _b2;
      return (_b2 = (_a2 = e6.schema.targets) == null ? void 0 : _a2.aggregate) == null ? void 0 : _b2.type;
    });
    if (r8 !== t9 && (null != this.aggregateStore && (this.removeHandles("valueRangesChanged"), this.aggregateStore.destroy(), this.aggregateStore = null), t9)) {
      switch (t9) {
        case "cluster": {
          const e6 = { geometryInfo: { geometryType: "esriGeometryPoint", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new V2(e6, this.spatialReference, this._storage, this.service), this.addHandles(this.aggregateStore.events.on("valueRangesChanged", (e7) => {
            this.remoteClient.invoke("emitEvent", { name: "valueRangesChanged", event: { valueRanges: e7.valueRanges } }).catch(A2);
          }), "valueRangesChanged");
          break;
        }
        case "bin": {
          const e6 = { geometryInfo: { geometryType: "esriGeometryPolygon", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new A(e6, this.spatialReference, this._storage, this.service);
          break;
        }
      }
      this.aggregateStore.onTileUpdate({ added: this.tileStore.tiles, removed: [] });
    }
  }
  async update(e5, t9) {
    this._updateVersion++, has("esri-2d-update-debug") && console.debug(`FeatureController2D::update: Token version ${this._updateVersion}`), this._initQueryEngine(t9), this._initAttributeStore(t9), this.pause(), await Promise.all([this._source.update(e5, t9.schema.source), this.featureStore.updateSchema(e5, t9.schema.targets.feature), this.attributeStore.update(e5, t9), this.attributeStore.updateFilters(e5, t9, this)]), this._initAggregateStore(t9), null != this.aggregateStore && await this.aggregateStore.updateSchema(e5, t9.schema.targets.aggregate), this._initAggregateQueryEngine(this.aggregateStore, t9.schema), has("esri-2d-update-debug") && e5.describe(), this._set("config", t9);
  }
  async applyUpdate(e5) {
    e5.version = this._updateVersion, has("esri-2d-update-debug") && console.debug(`FeatureController2D::applyUpdate: Token version ${e5.version}`), e5.mesh && this.clearTiles(), this._updateQueue.resume(), await this._source.applyUpdate(e5), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Waiting for source update to finish"), this.notifyChange("updating"), await j3(() => !this.updating), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Source update finsihed"), null != this.aggregateStore && (await g(10), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Waiting for aggregate idle call"), await j3(() => !this.updating), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Aggregate idle called")), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Update finished");
  }
  async onEdits({ edits: e5 }) {
    has("esri-2d-update-debug") && console.debug("Applying Edit:", e5), this._didEdit = true;
    try {
      const t9 = e5.removed.map((e6) => e6.objectId && -1 !== e6.objectId ? e6.objectId : this._lookupObjectIdByGlobalId(e6.globalId)), r8 = e5.addOrModified.map(({ objectId: e6 }) => e6);
      this.featureStore.invalidate(), await this._source.edit(r8, t9), this.clearTiles(), this.notifyChange("updating"), null != this.aggregateStore && this.aggregateStore.clear(), await this._source.resend(), await j3(() => !this.updating);
    } catch (t9) {
    }
  }
  async refresh(e5) {
    if (!e5.dataChanged) {
      const e6 = t8.empty();
      return e6.storage.filters = true, this.applyUpdate(e6);
    }
    this.featureStore.invalidate(), this.clearTiles(), this._source.refresh(this._updateVersion, e5), this._cleanupNeeded = true, this.notifyChange("updating"), await j3(() => !this.updating);
  }
  clearTiles() {
    for (const e5 of this.tileStore.tiles)
      this.processor.onTileClear(e5, false);
  }
  onTileUpdate(e5) {
    null != this.aggregateStore && this.aggregateStore.onTileUpdate(e5);
    for (const t9 of e5.added)
      this._source.subscribe(t9, this._updateVersion), this._level = t9.level;
    for (const t9 of e5.removed)
      this._source.unsubscribe(t9), this._cleanupNeeded = true, this._tileToResolver.has(t9.id) && (this._tileToResolver.get(t9.id).resolve(), this._tileToResolver.delete(t9.id));
    this.notifyChange("updating");
  }
  async onIdle() {
    this._invalidated && (this._invalidated = false, null == this.aggregateStore && "heatmap" !== this.processor.type || await this._repushCurrentLevelTiles()), this._markAndSweep();
  }
  async querySummaryStatistics({ query: e5, params: t9 }) {
    return this.featureQueryEngine.executeQueryForSummaryStatistics(e5, t9);
  }
  async queryAggregateSummaryStatistics({ query: e5, params: t9 }) {
    return this.aggregateQueryEngine.executeQueryForSummaryStatistics(this._normalizeAggregateQuery(e5), t9);
  }
  async queryUniqueValues({ query: e5, params: t9 }) {
    return this.featureQueryEngine.executeQueryForUniqueValues(e5, t9);
  }
  async queryAggregateUniqueValues({ query: e5, params: t9 }) {
    return this.aggregateQueryEngine.executeQueryForUniqueValues(this._normalizeAggregateQuery(e5), t9);
  }
  async queryClassBreaks({ query: e5, params: t9 }) {
    return this.featureQueryEngine.executeQueryForClassBreaks(e5, t9);
  }
  async queryAggregateClassBreaks({ query: e5, params: t9 }) {
    return this.aggregateQueryEngine.executeQueryForClassBreaks(this._normalizeAggregateQuery(e5), t9);
  }
  async queryHistogram({ query: e5, params: t9 }) {
    return this.featureQueryEngine.executeQueryForHistogram(e5, t9);
  }
  async queryAggregateHistogram({ query: e5, params: t9 }) {
    return this.aggregateQueryEngine.executeQueryForHistogram(this._normalizeAggregateQuery(e5), t9);
  }
  queryExtent(e5) {
    return this.featureQueryEngine.executeQueryForExtent(e5);
  }
  queryAggregates(e5) {
    return this.aggregateQueryEngine.executeQuery(this._normalizeAggregateQuery(e5));
  }
  queryAggregateCount(e5) {
    return this.aggregateQueryEngine.executeQueryForCount(this._normalizeAggregateQuery(e5));
  }
  queryAggregateIds(e5) {
    return this.aggregateQueryEngine.executeQueryForIds(this._normalizeAggregateQuery(e5));
  }
  queryFeatures(e5) {
    return this.featureQueryEngine.executeQuery(e5);
  }
  async queryVisibleFeatures(e5) {
    const t9 = await this.featureQueryEngine.executeQuery(e5), r8 = t9.objectIdFieldName;
    return t9.features = t9.features.filter((e6) => {
      const t10 = e6.attributes[r8], i7 = this.getDisplayId(t10);
      return n2(i7, (e7) => this.attributeStore.isVisible(e7));
    }), t9;
  }
  queryFeatureCount(e5) {
    return this.featureQueryEngine.executeQueryForCount(e5);
  }
  queryLatestObservations(e5) {
    return this.featureQueryEngine.executeQueryForLatestObservations(e5);
  }
  queryObjectIds(e5) {
    return this.featureQueryEngine.executeQueryForIds(e5);
  }
  async queryStatistics() {
    return this.featureStore.storeStatistics;
  }
  getObjectId(e5) {
    return this.featureStore.lookupObjectId(e5, this._storage);
  }
  getDisplayId(e5) {
    if (null != this.aggregateStore) {
      const t9 = this.aggregateStore.getDisplayId(e5);
      if (null == t9) {
        const t10 = this.featureStore.lookupDisplayId(e5);
        return this.aggregateStore.getDisplayIdForReferenceId(t10);
      }
      return t9;
    }
    return this.featureStore.lookupDisplayId(e5);
  }
  getFeatures(e5) {
    const t9 = [], r8 = [];
    for (const s11 of e5) {
      const e6 = null != this.aggregateStore ? this.getAggregate(s11) : null;
      if (null != e6)
        if (null != e6.attributes.referenceId) {
          const r9 = this.getFeature(e6.attributes.referenceId);
          null != r9 && t9.push(r9);
        } else
          r8.push(e6);
      else {
        const e7 = this.getFeature(s11);
        null != e7 && t9.push(e7);
      }
    }
    return { features: t9, aggregates: r8 };
  }
  getFeature(e5) {
    const t9 = this.featureStore.lookupFeatureByDisplayId(e5, this._storage);
    if (null == t9)
      return null;
    const r8 = t9.readHydratedGeometry(), s11 = st(r8, t9.geometryType, t9.hasZ, t9.hasM);
    return { attributes: t9.readAttributes(), geometry: s11 };
  }
  getAggregate(e5) {
    return null == this.aggregateStore ? null : this.aggregateStore.getAggregate(e5);
  }
  getAggregates() {
    return null == this.aggregateStore ? [] : this.aggregateStore.getAggregates();
  }
  async setHighlight(e5) {
    const r8 = e5.map((e6) => this.getDisplayId(e6)).filter(R);
    return this.attributeStore.setHighlight(e5, r8);
  }
  _normalizeAggregateQuery(e5) {
    const t9 = e5.objectIds ?? [];
    for (const r8 of e5.aggregateIds ?? [])
      t9.push(r8);
    return e5.objectIds = t9, e5.aggregateIds = [], e5;
  }
  _lookupObjectIdByGlobalId(e5) {
    const t9 = this.service.globalIdField;
    if (null == t9)
      throw new Error("Expected globalIdField to be defined");
    let r8 = null;
    if (this.featureStore.forEach((s11) => {
      e5 === s11.readAttribute(t9) && (r8 = s11.getObjectId());
    }), null == r8)
      throw new Error(`Expected to find a feature with globalId ${e5}`);
    return r8;
  }
  async _repushCurrentLevelTiles() {
    const e5 = this.tileStore.tiles.filter((e6) => e6.level === this._level);
    e5.map(async (e6) => this._patchTile({ type: "append", id: e6.key.id, clear: true, addOrUpdate: null, end: false }));
    const t9 = e5.map(async (e6) => this._patchTile({ type: "append", id: e6.key.id, addOrUpdate: h4.fromOptimizedFeatures([], this.service), remove: [], end: true, isRepush: true, status: t8.empty() }));
    await Promise.all(t9);
  }
  _maybeForceCleanup() {
    performance.now() - this._lastCleanup > E2 && this._markAndSweep();
  }
  _patchTile(e5, t9) {
    const r8 = this._updateQueue.push(e5, t9).catch((e6) => {
    });
    return this.updatingHandles.addPromise(r8);
  }
  async _onTileMessage(e5, t9) {
    if (s4(t9), has("esri-2d-update-debug")) {
      const t10 = n2(e5.addOrUpdate, (e6) => e6.hasFeatures);
      console.debug(e5.id, `FeatureController:onTileMessage: [clear:${e5.clear}, end:${e5.end}, features: ${t10}]`);
    }
    const r8 = this.tileStore.get(e5.id);
    if (!r8)
      return;
    if (e5.clear)
      return this.processor.onTileClear(r8, e5.end);
    const i7 = e5.status;
    this._cleanupNeeded = true;
    const a9 = [];
    for (const s11 of e5.remove ?? []) {
      const e6 = this.featureStore.lookupDisplayId(s11);
      e6 && a9.push(e6);
    }
    e5.remove = a9;
    try {
      if (null == e5.addOrUpdate)
        return void this.processor.onTileMessage(r8, { ...e5, addOrUpdate: null }, null != this.aggregateStore, t9).catch(m);
      if (e5.addOrUpdate.setArcadeSpatialReference(this.spatialReference), this.featureStore.hasInstance(e5.addOrUpdate.instance) && i7.targets.feature || (i7.targets.feature = true, this.featureStore.onTileData(r8, e5)), !i7.storage.data || !i7.storage.filters) {
        i7.storage.data = true, i7.storage.filters = true, this.attributeStore.onTileData(r8, e5);
        "stream" === this._source.type || this._didEdit ? (await this.attributeStore.sendUpdates(), s4(t9)) : this.attributeStore.sendUpdates();
      }
      if (null != this.aggregateStore && !i7.targets.aggregate) {
        i7.targets.aggregate = true;
        const t10 = x2(this._source) && this._source.loading, s11 = !x2(this._source) || t10 || e5.end;
        if (this.aggregateStore.onTileData(r8, e5, this._storage, this.attributeStore, s11), !s11)
          return;
        i7.mesh || (this.attributeStore.onTileData(r8, e5), await this.attributeStore.sendUpdates());
      }
      if (!i7.mesh) {
        i7.mesh = true;
        const s11 = null != this.aggregateStore && "cluster" === this.aggregateStore.type;
        await this.processor.onTileMessage(r8, e5, s11, t9), s4(t9);
      }
      this._maybeForceCleanup();
    } catch (u9) {
      m(u9);
    }
  }
  _mark(e5, t9, r8) {
    const s11 = (4294901760 & this._storage.getInstanceId(e5)) >>> 16;
    e5 && (t9.add(s11), r8.set(e5));
  }
  _markAndSweep() {
    this._lastCleanup = performance.now();
    if (!(!("feature" === this._source.type && "snapshot" === this._source.mode) && ("stream" === this._source.type || this._cleanupNeeded)))
      return;
    this._cleanupNeeded = false;
    const e5 = this._storage.getBitset(this._markedIdsBufId), t9 = /* @__PURE__ */ new Set();
    e5.clear();
    for (const r8 of this.tileStore.tiles)
      for (const s11 of this._source.readers(r8.id)) {
        const r9 = s11.getCursor();
        for (; r9.next(); ) {
          let s12 = r9.getDisplayId();
          if (!s12) {
            const e6 = r9.getObjectId();
            s12 = this.featureStore.lookupDisplayId(e6);
          }
          this._mark(s12, t9, e5);
        }
      }
    "symbol" === this.processor.type && this.processor.forEachBufferId((r8) => {
      this._mark(r8, t9, e5);
    }), this._updateQueue.forEach((r8) => {
      for (const s11 of r8.remove ?? []) {
        const r9 = this.featureStore.lookupDisplayId(s11);
        this._mark(r9, t9, e5);
      }
    }), null != this.aggregateStore && (this.aggregateStore.sweepFeatures(e5, this.featureStore), "sweepAggregates" in this.aggregateStore && this.aggregateStore.sweepAggregates(this._storage, this.attributeStore, this._level)), this.featureStore.sweepFeatures(e5, this._storage, this.attributeStore), this.featureStore.sweepFeatureSets(t9);
  }
};
e([y({ constructOnly: true })], U2.prototype, "tileStore", void 0), e([y()], U2.prototype, "config", void 0), e([y({ readOnly: true })], U2.prototype, "fieldsIndex", null), e([y()], U2.prototype, "processor", void 0), e([y({ constructOnly: true })], U2.prototype, "remoteClient", void 0), e([y({ constructOnly: true })], U2.prototype, "service", void 0), e([y()], U2.prototype, "spatialReference", null), e([y()], U2.prototype, "updating", null), U2 = e([a2("esri.views.2d.layers.features.controllers.FeatureController2D")], U2);
var R4 = U2;

// node_modules/@arcgis/core/views/2d/layers/features/support/Tile.js
var n10 = class _n {
  constructor(t9, e5) {
    this.key = new e4(0, 0, 0, 0), this.bounds = i2(), this.objectIds = /* @__PURE__ */ new Set(), this.key.set(e5);
    const s11 = t9.getLODInfoAt(this.key);
    this.tileInfoView = t9, this.tileInfoView.getTileBounds(this.bounds, this.key, true), this.resolution = s11.resolution, this.scale = s11.scale, this.level = s11.level;
  }
  get id() {
    return this.key.id;
  }
  get extent() {
    return M.fromBounds(this.bounds, this.tileInfoView.tileInfo.spatialReference);
  }
  get transform() {
    return { originPosition: "upperLeft", scale: [this.resolution, this.resolution], translate: [this.bounds[0], this.bounds[3]] };
  }
  createChildTiles() {
    const e5 = this.key.getChildKeys(), i7 = t2.acquire();
    for (let t9 = 0; t9 < e5.length; t9++)
      i7[t9] = new _n(this.tileInfoView, e5[t9]);
    return i7;
  }
  getQuantizationParameters() {
    return a4.fromJSON({ mode: "view", originPosition: "upperLeft", tolerance: this.resolution, extent: { xmin: this.bounds[0], ymin: this.bounds[1], xmax: this.bounds[2], ymax: this.bounds[3], spatialReference: this.tileInfoView.tileInfo.spatialReference } });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/TileStore.js
var h8 = { added: [], removed: [] };
var n11 = /* @__PURE__ */ new Set();
var r7 = new e4(0, 0, 0, 0);
var d7 = class extends n3 {
  constructor(e5) {
    super(), this._tiles = /* @__PURE__ */ new Map(), this._index = i5(9, has("esri-csp-restrictions") ? (e6) => ({ minX: e6.bounds[0], minY: e6.bounds[1], maxX: e6.bounds[2], maxY: e6.bounds[3] }) : [".bounds[0]", ".bounds[1]", ".bounds[2]", ".bounds[3]"]), this.tiles = [], this.tileScheme = e5;
  }
  destroy() {
    this.clear();
  }
  clear() {
    this.tiles.length = 0, this._tiles.clear(), this._index.clear();
  }
  has(e5) {
    return this._tiles.has(e5);
  }
  get(e5) {
    return this._tiles.get(e5);
  }
  boundsIntersections(e5) {
    return this._index.search({ minX: e5[0], minY: e5[1], maxX: e5[2], maxY: e5[3] });
  }
  updateTiles(e5) {
    const t9 = { added: [], removed: [] };
    for (const i7 of e5.added)
      if (!this.has(i7)) {
        const e6 = new n10(this.tileScheme, i7);
        this._tiles.set(i7, e6), this._index.insert(e6), t9.added.push(e6);
      }
    for (const s11 of e5.removed)
      if (this.has(s11)) {
        const e6 = this.get(s11);
        this._tiles.delete(s11), this._index.remove(e6), t9.removed.push(e6);
      }
    this.tiles.length = 0, this._tiles.forEach((e6) => this.tiles.push(e6)), (t9.added.length || t9.removed.length) && this.emit("update", t9);
  }
  setViewState(e5) {
    const t9 = this.tileScheme.getTileCoverage(e5, 0);
    if (!t9)
      return;
    const { spans: o7, lodInfo: d9 } = t9, { level: l9 } = d9;
    if (o7.length > 0)
      for (const { row: i7, colFrom: a9, colTo: m9 } of o7)
        for (let e6 = a9; e6 <= m9; e6++) {
          const t10 = r7.set(l9, i7, d9.normalizeCol(e6), d9.getWorldForColumn(e6)).id;
          if (n11.add(t10), !this.has(t10)) {
            const e7 = new n10(this.tileScheme, t10);
            this._tiles.set(t10, e7), this._index.insert(e7), this.tiles.push(e7), h8.added.push(e7);
          }
        }
    for (let s11 = this.tiles.length - 1; s11 >= 0; s11--) {
      const e6 = this.tiles[s11];
      n11.has(e6.id) || (this._tiles.delete(e6.id), this.tiles.splice(s11, 1), this._index.remove(e6), h8.removed.push(e6));
    }
    (h8.added.length || h8.removed.length) && this.emit("update", h8), l2.pool.release(t9), n11.clear(), h8.added.length = 0, h8.removed.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/Pipeline.js
var d8 = class extends d3 {
  constructor() {
    super(...arguments), this.controller = null, this.processor = null, this.remoteClient = null, this.tileStore = null, this.service = null, this.viewState = null, this._paused = false, this._pendingTileUpdates = [];
  }
  initialize() {
    this.handles.add(l(() => this.updating, (e5) => {
      this.remoteClient.invoke("setUpdating", e5).catch((e6) => {
      });
    }));
  }
  destroy() {
    var _a, _b;
    this.stop(), (_a = this.controller) == null ? void 0 : _a.destroy(), (_b = this.processor) == null ? void 0 : _b.destroy(), this.controller = this.processor = this.tileStore = this.remoteClient = null;
  }
  get updating() {
    return !this.controller || this.controller.updating;
  }
  stop() {
    var _a, _b, _c;
    this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e5) => e5.close()), this.service.source.length = 0), (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e5) => e5.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = null, this._pendingTileUpdates.length = 0;
  }
  async startup({ service: e5, config: t9, tileInfo: r8, tiles: s11 }) {
    var _a, _b, _c;
    if (this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e6) => e6.close()), this.service.source.length = 0), this.service = e5, !this.tileStore || !S(this.tileStore.tileScheme.spatialReference, r8.spatialReference)) {
      const e6 = new h2(j5.fromJSON(r8));
      s11.added.length = s11.removed.length = 0, (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e7) => e7.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = new d7(e6), this._pendingTileUpdates.length = 0;
    }
    for (await this._createProcessorAndController(t9), await this.update({ config: t9 }), this.controller.resume(), this.tileStore.clear(), this.tileStore.updateTiles(s11), this._paused = false; this._pendingTileUpdates.length; )
      this.tileStore.updateTiles(this._pendingTileUpdates.pop());
  }
  async updateTiles(e5) {
    var _a;
    this._paused ? this._pendingTileUpdates.push(e5) : (_a = this.tileStore) == null ? void 0 : _a.updateTiles(e5);
  }
  async update({ config: e5 }) {
    const t9 = t8.empty();
    return await Promise.all([this.processor.update(t9, e5), this.controller.update(t9, e5)]), t9.toJSON();
  }
  async applyUpdate(e5) {
    return this.controller.applyUpdate(t8.create(e5));
  }
  async _createProcessorAndController(e5) {
    await Promise.all([this._handleControllerConfig(e5), this._handleProcessorConfig(e5)]), this.controller.processor = this.processor;
  }
  async _handleControllerConfig(e5) {
    return this._createController(this.service, e5);
  }
  async _handleProcessorConfig(e5) {
    return this._createProcessor(this.service, e5);
  }
  async _createController(e5, t9) {
    this.controller && this.controller.destroy();
    const { tileStore: r8, remoteClient: s11 } = this, o7 = new R4({ service: e5, tileStore: r8, remoteClient: s11 });
    return this.controller = o7, o7;
  }
  async _createProcessor(e5, t9) {
    const r8 = t9.schema.processors[0].type, s11 = (await o3(r8)).default, { remoteClient: o7, tileStore: i7 } = this, l9 = new s11({ service: e5, config: t9, tileStore: i7, remoteClient: o7 });
    return this.processor && this.processor.destroy(), this.processor = l9, l9;
  }
};
e([y()], d8.prototype, "controller", void 0), e([y()], d8.prototype, "processor", void 0), e([y()], d8.prototype, "updating", null), e([y()], d8.prototype, "viewState", void 0), d8 = e([a2("esri.views.2d.layers.features.Pipeline")], d8);
var u8 = d8;
export {
  u8 as default
};
//# sourceMappingURL=Pipeline-NP32UJ7S.js.map
