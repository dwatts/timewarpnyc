import {
  r as r4
} from "./chunk-GXIJZVS6.js";
import {
  t as t4
} from "./chunk-Z2RTGLQI.js";
import {
  a,
  l as l2,
  s as s5
} from "./chunk-77DVCCTB.js";
import {
  e as e2,
  r as r3
} from "./chunk-KHQ5TXSL.js";
import {
  o as o3
} from "./chunk-SADO52IH.js";
import {
  t as t3
} from "./chunk-JP7O2ZWE.js";
import {
  v
} from "./chunk-TLBJBU3X.js";
import {
  s as s3
} from "./chunk-4RU6WIRN.js";
import {
  t as t2,
  y as y2
} from "./chunk-BDWD2ZNU.js";
import {
  I,
  R
} from "./chunk-HLBPEADQ.js";
import {
  c as c2,
  i,
  q,
  u as u2,
  x,
  y
} from "./chunk-FIBWCATC.js";
import {
  s as s4
} from "./chunk-LLQMBVBO.js";
import {
  o as o2,
  r as r2
} from "./chunk-CW7LIPBH.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  G,
  H
} from "./chunk-7EG7BYWF.js";
import {
  A as A2,
  O,
  U,
  _,
  e,
  g,
  o,
  p,
  s as s2,
  u
} from "./chunk-TPJLFGOT.js";
import {
  n,
  r,
  t
} from "./chunk-CQX57DED.js";
import {
  l
} from "./chunk-3JQ6N63Z.js";
import {
  A,
  c2 as c,
  s2 as s
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/AttributeArray.js
function o4(o7) {
  if (o7.length < A)
    return Array.from(o7);
  if (s(o7))
    return Float64Array.from(o7);
  if (!("BYTES_PER_ELEMENT" in o7))
    return Array.from(o7);
  switch (o7.BYTES_PER_ELEMENT) {
    case 1:
      return Uint8Array.from(o7);
    case 2:
      return c(o7) ? Uint16Array.from(o7) : Int16Array.from(o7);
    case 4:
      return Float32Array.from(o7);
    default:
      return Float64Array.from(o7);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BoundingInfo.js
var o5 = class _o {
  constructor(i3, s8, o7, c6) {
    this.primitiveIndices = i3, this._numIndexPerPrimitive = s8, this.indices = o7, this.position = c6, this._children = void 0, s3(i3.length >= 1), s3(o7.length % this._numIndexPerPrimitive == 0), s3(o7.length >= i3.length * this._numIndexPerPrimitive), s3(3 === c6.size || 4 === c6.size);
    const { data: d2, size: l6 } = c6, m2 = i3.length;
    let u5 = l6 * o7[this._numIndexPerPrimitive * i3[0]];
    a2.clear(), a2.push(u5);
    const f2 = r(d2[u5], d2[u5 + 1], d2[u5 + 2]), x3 = t(f2);
    for (let t5 = 0; t5 < m2; ++t5) {
      const s9 = this._numIndexPerPrimitive * i3[t5];
      for (let i4 = 0; i4 < this._numIndexPerPrimitive; ++i4) {
        u5 = l6 * o7[s9 + i4], a2.push(u5);
        let t6 = d2[u5];
        f2[0] = Math.min(t6, f2[0]), x3[0] = Math.max(t6, x3[0]), t6 = d2[u5 + 1], f2[1] = Math.min(t6, f2[1]), x3[1] = Math.max(t6, x3[1]), t6 = d2[u5 + 2], f2[2] = Math.min(t6, f2[2]), x3[2] = Math.max(t6, x3[2]);
      }
    }
    this.bbMin = f2, this.bbMax = x3;
    const P2 = A2(n(), this.bbMin, this.bbMax, 0.5);
    this.radius = 0.5 * Math.max(Math.max(x3[0] - f2[0], x3[1] - f2[1]), x3[2] - f2[2]);
    let v3 = this.radius * this.radius;
    for (let t5 = 0; t5 < a2.length; ++t5) {
      u5 = a2.at(t5);
      const i4 = d2[u5] - P2[0], s9 = d2[u5 + 1] - P2[1], e3 = d2[u5 + 2] - P2[2], n3 = i4 * i4 + s9 * s9 + e3 * e3;
      if (n3 <= v3)
        continue;
      const r8 = Math.sqrt(n3), h2 = 0.5 * (r8 - this.radius);
      this.radius = this.radius + h2, v3 = this.radius * this.radius;
      const o8 = h2 / r8;
      P2[0] += i4 * o8, P2[1] += s9 * o8, P2[2] += e3 * o8;
    }
    this.center = P2, a2.clear();
  }
  getChildren() {
    if (this._children || p(this.bbMin, this.bbMax) <= 1)
      return this._children;
    const i3 = A2(n(), this.bbMin, this.bbMax, 0.5), e3 = this.primitiveIndices.length, n3 = new Uint8Array(e3), h2 = new Array(8);
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] = 0;
    const { data: a6, size: c6 } = this.position;
    for (let t5 = 0; t5 < e3; ++t5) {
      let s8 = 0;
      const e4 = this._numIndexPerPrimitive * this.primitiveIndices[t5];
      let r8 = c6 * this.indices[e4], o7 = a6[r8], d3 = a6[r8 + 1], l7 = a6[r8 + 2];
      for (let i4 = 1; i4 < this._numIndexPerPrimitive; ++i4) {
        r8 = c6 * this.indices[e4 + i4];
        const t6 = a6[r8], s9 = a6[r8 + 1], n4 = a6[r8 + 2];
        t6 < o7 && (o7 = t6), s9 < d3 && (d3 = s9), n4 < l7 && (l7 = n4);
      }
      o7 < i3[0] && (s8 |= 1), d3 < i3[1] && (s8 |= 2), l7 < i3[2] && (s8 |= 4), n3[t5] = s8, ++h2[s8];
    }
    let d2 = 0;
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] > 0 && ++d2;
    if (d2 < 2)
      return;
    const l6 = new Array(8);
    for (let t5 = 0; t5 < 8; ++t5)
      l6[t5] = h2[t5] > 0 ? new Uint32Array(h2[t5]) : void 0;
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] = 0;
    for (let t5 = 0; t5 < e3; ++t5) {
      const i4 = n3[t5];
      l6[i4][h2[i4]++] = this.primitiveIndices[t5];
    }
    this._children = new Array();
    for (let t5 = 0; t5 < 8; ++t5)
      void 0 !== l6[t5] && this._children.push(new _o(l6[t5], this._numIndexPerPrimitive, this.indices, this.position));
    return this._children;
  }
  static prune() {
    a2.prune();
  }
};
var a2 = new l({ deallocator: null });

// node_modules/@arcgis/core/geometry/support/triangle.js
function j(t5) {
  return t5 ? { p0: t(t5.p0), p1: t(t5.p1), p2: t(t5.p2) } : { p0: n(), p1: n(), p2: n() };
}
function S(t5, n3, e3) {
  const r8 = n3[0] - t5[0], o7 = n3[1] - t5[1], p4 = e3[0] - t5[0], c6 = e3[1] - t5[1];
  return 0.5 * Math.abs(r8 * c6 - o7 * p4);
}
function w(t5, n3, o7) {
  return e(O3, n3, t5), e(V, o7, t5), s2(_(O3, O3, V)) / 2;
}
var M2 = new s4(v);
var x2 = new s4(() => j());
var O3 = n();
var V = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/geometryDataUtils.js
function c4(r8, o7, c6) {
  if (!r8 || !o7)
    return false;
  const { size: a6, data: f2 } = r8;
  o(c6, 0, 0, 0), o(g2, 0, 0, 0);
  let m2 = 0, h2 = 0;
  for (let p4 = 0; p4 < o7.length - 2; p4 += 3) {
    const r9 = o7[p4] * a6, j2 = o7[p4 + 1] * a6, d2 = o7[p4 + 2] * a6;
    o(i2, f2[r9], f2[r9 + 1], f2[r9 + 2]), o(u3, f2[j2], f2[j2 + 1], f2[j2 + 2]), o(l3, f2[d2], f2[d2 + 1], f2[d2 + 2]);
    const z = w(i2, u3, l3);
    z ? (u(i2, i2, u3), u(i2, i2, l3), g(i2, i2, 1 / 3 * z), u(c6, c6, i2), m2 += z) : (u(g2, g2, i2), u(g2, g2, u3), u(g2, g2, l3), h2 += 3);
  }
  return (0 !== h2 || 0 !== m2) && (0 !== m2 ? (g(c6, c6, 1 / m2), true) : 0 !== h2 && (g(c6, g2, 1 / h2), true));
}
function a3(n3, r8, o7) {
  if (!n3 || !r8)
    return false;
  const { size: s8, data: c6 } = n3;
  o(o7, 0, 0, 0);
  let a6 = -1, f2 = 0;
  for (let t5 = 0; t5 < r8.length; t5++) {
    const n4 = r8[t5] * s8;
    a6 !== n4 && (o7[0] += c6[n4], o7[1] += c6[n4 + 1], o7[2] += c6[n4 + 2], f2++), a6 = n4;
  }
  return f2 > 1 && g(o7, o7, 1 / f2), f2 > 0;
}
function f(o7, s8, c6, a6) {
  if (!o7)
    return false;
  o(a6, 0, 0, 0), o(g2, 0, 0, 0);
  let f2 = 0, l6 = 0;
  const { size: m2, data: h2 } = o7, p4 = s8 ? s8.length - 1 : h2.length / m2 - 1, j2 = p4 + (c6 ? 2 : 0);
  for (let t5 = 0; t5 < j2; t5 += 2) {
    const o8 = t5 < p4 ? t5 : p4, c7 = t5 < p4 ? t5 + 1 : 0, j3 = (s8 ? s8[o8] : o8) * m2, d2 = (s8 ? s8[c7] : c7) * m2;
    i2[0] = h2[j3], i2[1] = h2[j3 + 1], i2[2] = h2[j3 + 2], u3[0] = h2[d2], u3[1] = h2[d2 + 1], u3[2] = h2[d2 + 2], g(i2, u(i2, i2, u3), 0.5);
    const z = U(i2, u3);
    z > 0 ? (u(a6, a6, g(i2, i2, z)), f2 += z) : 0 === f2 && (u(g2, g2, i2), l6++);
  }
  return 0 !== f2 ? (g(a6, a6, 1 / f2), true) : 0 !== l6 && (g(a6, g2, 1 / l6), true);
}
var i2 = n();
var u3 = n();
var l3 = n();
var g2 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/utils.js
function n2(t5, e3) {
  return null == t5 && (t5 = []), t5.push(e3), t5;
}
function r6(t5, e3) {
  if (null == t5)
    return null;
  const n3 = t5.filter((t6) => t6 !== e3);
  return 0 === n3.length ? null : n3;
}
function s6(t5, n3, r8, s8, u5) {
  l4[0] = t5.get(n3, 0), l4[1] = t5.get(n3, 1), l4[2] = t5.get(n3, 2), t4(l4, o6, 3), r8.set(u5, 0, o6[0]), s8.set(u5, 0, o6[1]), r8.set(u5, 1, o6[2]), s8.set(u5, 1, o6[3]), r8.set(u5, 2, o6[4]), s8.set(u5, 2, o6[5]);
}
var l4 = n();
var o6 = new Float32Array(6);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Geometry.js
var b = class _b extends r3 {
  constructor(t5, e3, i3 = [], r8 = null, o7 = e2.Mesh, h2 = null, a6 = -1) {
    super(), this.material = t5, this.mapPositions = r8, this.type = o7, this.objectAndLayerIdColor = h2, this.edgeIndicesLength = a6, this.visible = true, this._vertexAttributes = /* @__PURE__ */ new Map(), this._indices = /* @__PURE__ */ new Map(), this._boundingInfo = null;
    for (const [s8, n3] of e3)
      n3 && this._vertexAttributes.set(s8, { ...n3 });
    if (null == i3 || 0 === i3.length) {
      const t6 = p2(this._vertexAttributes), e4 = y2(t6);
      this.edgeIndicesLength = this.edgeIndicesLength < 0 ? t6 : this.edgeIndicesLength;
      for (const i4 of this._vertexAttributes.keys())
        this._indices.set(i4, e4);
    } else
      for (const [s8, u5] of i3)
        u5 && (this._indices.set(s8, t2(u5)), s8 === O2.POSITION && (this.edgeIndicesLength = this.edgeIndicesLength < 0 ? this._indices.get(s8).length : this.edgeIndicesLength));
  }
  instantiate(t5 = {}) {
    const e3 = new _b(t5.material || this.material, [], void 0, this.mapPositions, this.type, this.objectAndLayerIdColor, this.edgeIndicesLength);
    return this._vertexAttributes.forEach((t6, i3) => {
      t6.exclusive = false, e3._vertexAttributes.set(i3, t6);
    }), this._indices.forEach((t6, i3) => e3._indices.set(i3, t6)), e3._boundingInfo = this._boundingInfo, e3.transformation = t5.transformation || this.transformation, e3;
  }
  get vertexAttributes() {
    return this._vertexAttributes;
  }
  getMutableAttribute(t5) {
    let e3 = this._vertexAttributes.get(t5);
    return e3 && !e3.exclusive && (e3 = { ...e3, exclusive: true, data: o4(e3.data) }, this._vertexAttributes.set(t5, e3)), e3;
  }
  setAttributeData(t5, e3) {
    const i3 = this._vertexAttributes.get(t5);
    i3 && this._vertexAttributes.set(t5, { ...i3, exclusive: true, data: e3 });
  }
  get indices() {
    return this._indices;
  }
  get indexCount() {
    const t5 = this._indices.values().next().value;
    return t5 ? t5.length : 0;
  }
  get faceCount() {
    return this.indexCount / 3;
  }
  get boundingInfo() {
    return null == this._boundingInfo && (this._boundingInfo = this._calculateBoundingInfo()), this._boundingInfo;
  }
  computeAttachmentOrigin(t5) {
    return !!(this.type === e2.Mesh ? this._computeAttachmentOriginTriangles(t5) : this.type === e2.Line ? this._computeAttachmentOriginLines(t5) : this._computeAttachmentOriginPoints(t5)) && (null != this._transformation && O(t5, t5, this._transformation), true);
  }
  _computeAttachmentOriginTriangles(t5) {
    const e3 = this.indices.get(O2.POSITION), i3 = this.vertexAttributes.get(O2.POSITION);
    return c4(i3, e3, t5);
  }
  _computeAttachmentOriginLines(t5) {
    const e3 = this.vertexAttributes.get(O2.POSITION), i3 = this.indices.get(O2.POSITION);
    return f(e3, i3, i3 && v2(this.material.parameters, e3, i3), t5);
  }
  _computeAttachmentOriginPoints(t5) {
    const e3 = this.indices.get(O2.POSITION), i3 = this.vertexAttributes.get(O2.POSITION);
    return a3(i3, e3, t5);
  }
  invalidateBoundingInfo() {
    this._boundingInfo = null;
  }
  _calculateBoundingInfo() {
    const t5 = this.indices.get(O2.POSITION), e3 = this.vertexAttributes.get(O2.POSITION);
    if (!t5 || 0 === t5.length || !e3)
      return null;
    const i3 = this.type === e2.Mesh ? 3 : 1;
    s3(t5.length % i3 == 0, "Indexing error: " + t5.length + " not divisible by " + i3);
    const n3 = y2(t5.length / i3);
    return new o5(n3, i3, t5, e3);
  }
  get transformation() {
    return this._transformation ?? o2;
  }
  set transformation(i3) {
    this._transformation = i3 && i3 !== o2 ? r2(i3) : null;
  }
  get shaderTransformation() {
    return null != this._shaderTransformer ? this._shaderTransformer(this.transformation) : this.transformation;
  }
  get shaderTransformer() {
    return this._shaderTransformer;
  }
  set shaderTransformer(t5) {
    this._shaderTransformer = t5;
  }
  get hasVolatileTransformation() {
    return null != this._shaderTransformer;
  }
  addHighlight() {
    const t5 = new r4(t3.Highlight);
    return this.highlights = n2(this.highlights, t5), t5;
  }
  removeHighlight(t5) {
    this.highlights = r6(this.highlights, t5);
  }
};
function p2(t5) {
  const e3 = t5.values().next().value;
  return null == e3 ? 0 : e3.data.length / e3.size;
}
function v2(t5, e3, i3) {
  return !(!("isClosed" in t5) || !t5.isClosed) && (i3 ? i3.length > 2 : e3.data.length > 6);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/OrderIndependentTransparency.js
var c5 = l2(R.SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE_MINUS_SRC_ALPHA);
var N = s5(R.ONE, R.ONE);
var s7 = s5(R.ZERO, R.ONE_MINUS_SRC_ALPHA);
function A3(r8) {
  return r8 === o3.FrontFace ? null : r8 === o3.Alpha ? s7 : N;
}
function E(r8) {
  return r8 === o3.FrontFace ? a : null;
}
var S2 = 5e5;
var _2 = { factor: -1, units: -2 };
function a4(n3) {
  return n3 ? _2 : null;
}
function l5(r8, e3 = I.LESS) {
  return r8 === o3.NONE || r8 === o3.FrontFace ? e3 : I.LEQUAL;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/bufferWriterUtils.js
function d(e3, t5, f2, o7, r8 = 1) {
  const s8 = f2.typedBuffer, n3 = f2.typedBufferStride, i3 = e3.length;
  if (o7 *= n3, 1 === r8)
    for (let c6 = 0; c6 < i3; ++c6)
      s8[o7] = t5[e3[c6]], o7 += n3;
  else
    for (let c6 = 0; c6 < i3; ++c6) {
      const f3 = t5[e3[c6]];
      for (let e4 = 0; e4 < r8; e4++)
        s8[o7] = f3, o7 += n3;
    }
}
function u4(e3, t5, f2, o7) {
  const r8 = f2.typedBuffer, s8 = f2.typedBufferStride, n3 = e3.length;
  o7 *= s8;
  for (let i3 = 0; i3 < n3; ++i3) {
    const f3 = 2 * e3[i3];
    r8[o7] = t5[f3], r8[o7 + 1] = t5[f3 + 1], o7 += s8;
  }
}
function a5(e3, t5, f2, o7, r8) {
  const s8 = f2.typedBuffer, n3 = f2.typedBufferStride, i3 = e3.length;
  if (o7 *= n3, null == r8 || 1 === r8)
    for (let c6 = 0; c6 < i3; ++c6) {
      const f3 = 3 * e3[c6];
      s8[o7] = t5[f3], s8[o7 + 1] = t5[f3 + 1], s8[o7 + 2] = t5[f3 + 2], o7 += n3;
    }
  else
    for (let c6 = 0; c6 < i3; ++c6) {
      const f3 = 3 * e3[c6];
      for (let e4 = 0; e4 < r8; ++e4)
        s8[o7] = t5[f3], s8[o7 + 1] = t5[f3 + 1], s8[o7 + 2] = t5[f3 + 2], o7 += n3;
    }
}
function p3(e3, t5, f2, o7, r8 = 1) {
  const s8 = f2.typedBuffer, n3 = f2.typedBufferStride, i3 = e3.length;
  if (o7 *= n3, 1 === r8)
    for (let c6 = 0; c6 < i3; ++c6) {
      const f3 = 4 * e3[c6];
      s8[o7] = t5[f3], s8[o7 + 1] = t5[f3 + 1], s8[o7 + 2] = t5[f3 + 2], s8[o7 + 3] = t5[f3 + 3], o7 += n3;
    }
  else
    for (let c6 = 0; c6 < i3; ++c6) {
      const f3 = 4 * e3[c6];
      for (let e4 = 0; e4 < r8; ++e4)
        s8[o7] = t5[f3], s8[o7 + 1] = t5[f3 + 1], s8[o7 + 2] = t5[f3 + 2], s8[o7 + 3] = t5[f3 + 3], o7 += n3;
    }
}
function y3(e3, t5, f2) {
  const o7 = e3.typedBuffer, r8 = e3.typedBufferStride;
  t5 *= r8;
  for (let s8 = 0; s8 < f2; ++s8)
    o7[t5] = 0, o7[t5 + 1] = 0, o7[t5 + 2] = 0, o7[t5 + 3] = 0, t5 += r8;
}
function b2(t5, f2, o7, r8, s8, n3 = 1) {
  if (!o7)
    return void a5(t5, f2, r8, s8, n3);
  const i3 = r8.typedBuffer, c6 = r8.typedBufferStride, l6 = t5.length, d2 = o7[0], u5 = o7[1], p4 = o7[2], y4 = o7[4], B = o7[5], g3 = o7[6], b3 = o7[8], O5 = o7[9], h2 = o7[10], N3 = o7[12], S4 = o7[13], R3 = o7[14];
  s8 *= c6;
  let A5 = 0, E3 = 0, L = 0;
  const z = H(o7) ? (e3) => {
    A5 = f2[e3] + N3, E3 = f2[e3 + 1] + S4, L = f2[e3 + 2] + R3;
  } : (e3) => {
    const t6 = f2[e3], o8 = f2[e3 + 1], r9 = f2[e3 + 2];
    A5 = d2 * t6 + y4 * o8 + b3 * r9 + N3, E3 = u5 * t6 + B * o8 + O5 * r9 + S4, L = p4 * t6 + g3 * o8 + h2 * r9 + R3;
  };
  if (1 === n3)
    for (let e3 = 0; e3 < l6; ++e3)
      z(3 * t5[e3]), i3[s8] = A5, i3[s8 + 1] = E3, i3[s8 + 2] = L, s8 += c6;
  else
    for (let e3 = 0; e3 < l6; ++e3) {
      z(3 * t5[e3]);
      for (let e4 = 0; e4 < n3; ++e4)
        i3[s8] = A5, i3[s8 + 1] = E3, i3[s8 + 2] = L, s8 += c6;
    }
}
function O4(f2, o7, r8, s8, n3, i3 = 1) {
  if (!r8)
    return void a5(f2, o7, s8, n3, i3);
  const c6 = r8, l6 = s8.typedBuffer, d2 = s8.typedBufferStride, u5 = f2.length, p4 = c6[0], y4 = c6[1], B = c6[2], g3 = c6[4], b3 = c6[5], O5 = c6[6], h2 = c6[8], N3 = c6[9], S4 = c6[10], R3 = !G(c6), A5 = 1e-6, E3 = 1 - A5;
  n3 *= d2;
  let L = 0, z = 0, F = 0;
  const v3 = H(c6) ? (e3) => {
    L = o7[e3], z = o7[e3 + 1], F = o7[e3 + 2];
  } : (e3) => {
    const t5 = o7[e3], f3 = o7[e3 + 1], r9 = o7[e3 + 2];
    L = p4 * t5 + g3 * f3 + h2 * r9, z = y4 * t5 + b3 * f3 + N3 * r9, F = B * t5 + O5 * f3 + S4 * r9;
  };
  if (1 === i3)
    if (R3)
      for (let e3 = 0; e3 < u5; ++e3) {
        v3(3 * f2[e3]);
        const t5 = L * L + z * z + F * F;
        if (t5 < E3 && t5 > A5) {
          const e4 = 1 / Math.sqrt(t5);
          l6[n3] = L * e4, l6[n3 + 1] = z * e4, l6[n3 + 2] = F * e4;
        } else
          l6[n3] = L, l6[n3 + 1] = z, l6[n3 + 2] = F;
        n3 += d2;
      }
    else
      for (let e3 = 0; e3 < u5; ++e3)
        v3(3 * f2[e3]), l6[n3] = L, l6[n3 + 1] = z, l6[n3 + 2] = F, n3 += d2;
  else
    for (let e3 = 0; e3 < u5; ++e3) {
      if (v3(3 * f2[e3]), R3) {
        const e4 = L * L + z * z + F * F;
        if (e4 < E3 && e4 > A5) {
          const t5 = 1 / Math.sqrt(e4);
          L *= t5, z *= t5, F *= t5;
        }
      }
      for (let e4 = 0; e4 < i3; ++e4)
        l6[n3] = L, l6[n3 + 1] = z, l6[n3 + 2] = F, n3 += d2;
    }
}
function h(e3, f2, o7, r8, s8, n3 = 1) {
  if (!o7)
    return void p3(e3, f2, r8, s8, n3);
  const i3 = o7, c6 = r8.typedBuffer, l6 = r8.typedBufferStride, d2 = e3.length, u5 = i3[0], a6 = i3[1], y4 = i3[2], B = i3[4], g3 = i3[5], b3 = i3[6], O5 = i3[8], h2 = i3[9], N3 = i3[10], S4 = !G(i3), R3 = 1e-6, A5 = 1 - R3;
  if (s8 *= l6, 1 === n3)
    for (let t5 = 0; t5 < d2; ++t5) {
      const o8 = 4 * e3[t5], r9 = f2[o8], n4 = f2[o8 + 1], i4 = f2[o8 + 2], d3 = f2[o8 + 3];
      let p4 = u5 * r9 + B * n4 + O5 * i4, E3 = a6 * r9 + g3 * n4 + h2 * i4, L = y4 * r9 + b3 * n4 + N3 * i4;
      if (S4) {
        const e4 = p4 * p4 + E3 * E3 + L * L;
        if (e4 < A5 && e4 > R3) {
          const t6 = 1 / Math.sqrt(e4);
          p4 *= t6, E3 *= t6, L *= t6;
        }
      }
      c6[s8] = p4, c6[s8 + 1] = E3, c6[s8 + 2] = L, c6[s8 + 3] = d3, s8 += l6;
    }
  else
    for (let t5 = 0; t5 < d2; ++t5) {
      const o8 = 4 * e3[t5], r9 = f2[o8], i4 = f2[o8 + 1], d3 = f2[o8 + 2], p4 = f2[o8 + 3];
      let E3 = u5 * r9 + B * i4 + O5 * d3, L = a6 * r9 + g3 * i4 + h2 * d3, z = y4 * r9 + b3 * i4 + N3 * d3;
      if (S4) {
        const e4 = E3 * E3 + L * L + z * z;
        if (e4 < A5 && e4 > R3) {
          const t6 = 1 / Math.sqrt(e4);
          E3 *= t6, L *= t6, z *= t6;
        }
      }
      for (let e4 = 0; e4 < n3; ++e4)
        c6[s8] = E3, c6[s8 + 1] = L, c6[s8 + 2] = z, c6[s8 + 3] = p4, s8 += l6;
    }
}
function N2(e3, t5, f2, o7, r8, s8 = 1) {
  const n3 = o7.typedBuffer, i3 = o7.typedBufferStride, c6 = e3.length;
  if (r8 *= i3, f2 !== t5.length || 4 !== f2)
    if (1 !== s8)
      if (4 !== f2)
        for (let l6 = 0; l6 < c6; ++l6) {
          const f3 = 3 * e3[l6];
          for (let e4 = 0; e4 < s8; ++e4)
            n3[r8] = t5[f3], n3[r8 + 1] = t5[f3 + 1], n3[r8 + 2] = t5[f3 + 2], n3[r8 + 3] = 255, r8 += i3;
        }
      else
        for (let l6 = 0; l6 < c6; ++l6) {
          const f3 = 4 * e3[l6];
          for (let e4 = 0; e4 < s8; ++e4)
            n3[r8] = t5[f3], n3[r8 + 1] = t5[f3 + 1], n3[r8 + 2] = t5[f3 + 2], n3[r8 + 3] = t5[f3 + 3], r8 += i3;
        }
    else {
      if (4 === f2) {
        for (let f3 = 0; f3 < c6; ++f3) {
          const o8 = 4 * e3[f3];
          n3[r8] = t5[o8], n3[r8 + 1] = t5[o8 + 1], n3[r8 + 2] = t5[o8 + 2], n3[r8 + 3] = t5[o8 + 3], r8 += i3;
        }
        return;
      }
      for (let f3 = 0; f3 < c6; ++f3) {
        const o8 = 3 * e3[f3];
        n3[r8] = t5[o8], n3[r8 + 1] = t5[o8 + 1], n3[r8 + 2] = t5[o8 + 2], n3[r8 + 3] = 255, r8 += i3;
      }
    }
  else {
    n3[r8] = t5[0], n3[r8 + 1] = t5[1], n3[r8 + 2] = t5[2], n3[r8 + 3] = t5[3];
    const e4 = new Uint32Array(o7.typedBuffer.buffer, o7.start), f3 = i3 / 4, l6 = e4[r8 /= 4];
    r8 += f3;
    const d2 = c6 * s8;
    for (let t6 = 1; t6 < d2; ++t6)
      e4[r8] = l6, r8 += f3;
  }
}
function S3(e3, t5, f2, o7) {
  const r8 = f2.typedBuffer, s8 = f2.typedBufferStride, n3 = e3.length, i3 = t5[0];
  o7 *= s8;
  for (let c6 = 0; c6 < n3; ++c6)
    r8[o7] = i3, o7 += s8;
}
function R2(e3, t5, f2, o7, r8 = 1) {
  const s8 = t5.typedBuffer, n3 = t5.typedBufferStride;
  if (o7 *= n3, 1 === r8)
    for (let i3 = 0; i3 < f2; ++i3)
      s8[o7] = e3[0], s8[o7 + 1] = e3[1], s8[o7 + 2] = e3[2], s8[o7 + 3] = e3[3], o7 += n3;
  else
    for (let i3 = 0; i3 < f2; ++i3)
      for (let t6 = 0; t6 < r8; ++t6)
        s8[o7] = e3[0], s8[o7 + 1] = e3[1], s8[o7 + 2] = e3[2], s8[o7 + 3] = e3[3], o7 += n3;
}
function A4(e3, t5, o7, r8, s8, n3) {
  for (const i3 of t5.fields.keys()) {
    const t6 = e3.vertexAttributes.get(i3), d2 = e3.indices.get(i3);
    if (t6 && d2)
      E2(i3, t6, d2, o7, r8, s8, n3);
    else if (i3 === O2.OBJECTANDLAYERIDCOLOR && null != e3.objectAndLayerIdColor) {
      const t7 = e3.indices.get(O2.POSITION);
      if (s3(!!t7, `No buffer view for ${i3}`), t7) {
        const o8 = t7.length, r9 = s8.getField(i3, x);
        R2(e3.objectAndLayerIdColor, r9, o8, n3);
      }
    }
  }
}
function E2(e3, t5, d2, a6, y4, B, g3) {
  switch (e3) {
    case O2.POSITION: {
      s3(3 === t5.size);
      const f2 = B.getField(e3, i);
      s3(!!f2, `No buffer view for ${e3}`), f2 && b2(d2, t5.data, a6, f2, g3);
      break;
    }
    case O2.NORMAL: {
      s3(3 === t5.size);
      const f2 = B.getField(e3, i);
      s3(!!f2, `No buffer view for ${e3}`), f2 && O4(d2, t5.data, y4, f2, g3);
      break;
    }
    case O2.NORMALCOMPRESSED: {
      s3(2 === t5.size);
      const f2 = B.getField(e3, q);
      s3(!!f2, `No buffer view for ${e3}`), f2 && u4(d2, t5.data, f2, g3);
      break;
    }
    case O2.UV0: {
      s3(2 === t5.size);
      const f2 = B.getField(e3, u2);
      s3(!!f2, `No buffer view for ${e3}`), f2 && u4(d2, t5.data, f2, g3);
      break;
    }
    case O2.COLOR:
    case O2.SYMBOLCOLOR: {
      const o7 = B.getField(e3, x);
      s3(!!o7, `No buffer view for ${e3}`), s3(3 === t5.size || 4 === t5.size), !o7 || 3 !== t5.size && 4 !== t5.size || N2(d2, t5.data, t5.size, o7, g3);
      break;
    }
    case O2.COLORFEATUREATTRIBUTE: {
      const f2 = B.getField(e3, y);
      s3(!!f2, `No buffer view for ${e3}`), s3(1 === t5.size), f2 && 1 === t5.size && S3(d2, t5.data, f2, g3);
      break;
    }
    case O2.TANGENT: {
      s3(4 === t5.size);
      const f2 = B.getField(e3, c2);
      s3(!!f2, `No buffer view for ${e3}`), f2 && h(d2, t5.data, y4, f2, g3);
      break;
    }
    case O2.PROFILERIGHT:
    case O2.PROFILEUP:
    case O2.PROFILEVERTEXANDNORMAL:
    case O2.FEATUREVALUE: {
      s3(4 === t5.size);
      const f2 = B.getField(e3, c2);
      s3(!!f2, `No buffer view for ${e3}`), f2 && p3(d2, t5.data, f2, g3);
    }
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultBufferWriter.js
var r7 = class {
  constructor(t5) {
    this.vertexBufferLayout = t5;
  }
  elementCount(e3) {
    return e3.indices.get(O2.POSITION).length;
  }
  write(t5, r8, i3, o7, s8) {
    A4(i3, this.vertexBufferLayout, t5, r8, o7, s8);
  }
};

export {
  o5 as o,
  S,
  n2 as n,
  r6 as r,
  s6 as s,
  b,
  c5 as c,
  s7 as s2,
  A3 as A,
  E,
  S2,
  _2 as _,
  a4 as a,
  l5 as l,
  d,
  p3 as p,
  y3 as y,
  b2,
  O4 as O,
  N2 as N,
  R2 as R,
  A4 as A2,
  E2,
  r7 as r2
};
//# sourceMappingURL=chunk-ZPXPJ2G7.js.map
