import {
  o
} from "./chunk-6WMPCNUB.js";
import {
  n as n4
} from "./chunk-GD75B7SP.js";
import {
  d as d2
} from "./chunk-AGK2CKWJ.js";
import {
  e as e8
} from "./chunk-FKUVQAN6.js";
import {
  l as l4
} from "./chunk-GNJFBBMD.js";
import "./chunk-2735WBYK.js";
import {
  c as c2
} from "./chunk-GOA7OKM7.js";
import {
  t as t3
} from "./chunk-XYJMHUDA.js";
import "./chunk-CSLWFQJE.js";
import {
  h
} from "./chunk-5ARHJ4BH.js";
import {
  M
} from "./chunk-A4HFWKMU.js";
import {
  T
} from "./chunk-YRFMBPVS.js";
import {
  n
} from "./chunk-V5N62ACA.js";
import {
  ee,
  re,
  te
} from "./chunk-ZS33I7QE.js";
import {
  d as d3,
  i as i3,
  o as o2,
  s as s3,
  s2 as s4
} from "./chunk-KD4VJNFV.js";
import {
  r as r3
} from "./chunk-KILCBNKU.js";
import {
  M as M2,
  k
} from "./chunk-4GKXMRJI.js";
import "./chunk-HKJ2JMCX.js";
import "./chunk-644IM3NW.js";
import "./chunk-KWPMDFFW.js";
import {
  e as e6,
  r as r2,
  t as t5
} from "./chunk-D5NSNTGJ.js";
import {
  u
} from "./chunk-MUDJ2KE7.js";
import {
  c as c3
} from "./chunk-EVSMDRIW.js";
import {
  T as T2,
  e2 as e7
} from "./chunk-XFZB3R5P.js";
import "./chunk-YRKEWWDW.js";
import "./chunk-63ERNIOV.js";
import {
  e as e5,
  t as t4
} from "./chunk-NHV3P5PD.js";
import {
  L as L2,
  a as a3,
  i as i2,
  l as l3,
  n as n3,
  r
} from "./chunk-JIDIC5HA.js";
import "./chunk-WDZ5AAFL.js";
import {
  n as n2,
  t as t2
} from "./chunk-5KLICR5E.js";
import {
  e as e4
} from "./chunk-6M3QJVKB.js";
import "./chunk-PH45YSDU.js";
import "./chunk-MNDNZJD5.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-CUZNACFZ.js";
import "./chunk-ZHUFARKQ.js";
import "./chunk-4RU6WIRN.js";
import "./chunk-FF5LS3YE.js";
import {
  C,
  D,
  E,
  F,
  G,
  I,
  L,
  R
} from "./chunk-HLBPEADQ.js";
import {
  j as j4
} from "./chunk-JPAY3V43.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-OTNLRAEN.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-6NPJZOPM.js";
import {
  f as f2
} from "./chunk-MNR4BIGQ.js";
import "./chunk-IHCIS6PT.js";
import "./chunk-OHH3UAUS.js";
import {
  e as e3
} from "./chunk-GLVTFP5O.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-2TWR6EVF.js";
import "./chunk-DKCDRJ5N.js";
import "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-POEWD5LS.js";
import "./chunk-HTVQN75V.js";
import "./chunk-W3WHCGIQ.js";
import {
  j as j2,
  l as l2,
  w
} from "./chunk-HPWZ2OON.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-CEXY22SC.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7JNPZC53.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-J2V5CZSS.js";
import "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import {
  j as j3
} from "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import {
  kt
} from "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import {
  i
} from "./chunk-V3CNLYUD.js";
import {
  c
} from "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  a2,
  d,
  e as e2,
  f2 as f,
  j,
  l,
  m,
  s2,
  t
} from "./chunk-UYRCWUYQ.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SchemaHelper.js
var t6 = class {
  constructor(t13, e14, s7) {
    this._scale = t13, this._shift = e14, this._levelShift = s7;
  }
  getLevelRowColumn(t13) {
    const e14 = this.getLevelShift(t13[0]), s7 = this._shift + e14;
    return s7 ? [t13[0] - e14, t13[1] >> s7, t13[2] >> s7] : t13;
  }
  getLevelShift(t13) {
    return Math.min(t13, this._levelShift);
  }
  getOffset(t13, e14) {
    let s7 = 0, i8 = 0;
    const h4 = this._shift + this.getLevelShift(t13[0]);
    if (h4) {
      const l9 = (1 << h4) - 1, f5 = e14 / (this._scale * (1 << h4 - 1));
      s7 = (t13[2] & l9) * f5, i8 = (t13[1] & l9) * f5;
    }
    return [s7, i8];
  }
  getScale(t13) {
    return this._scale * (1 << this._shift + this.getLevelShift(t13));
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e9 = class {
  constructor(e14, t13) {
    this._width = 0, this._height = 0, this._free = [], this._width = e14, this._height = t13, this._free.push(new t3(0, 0, e14, t13));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e14, t13) {
    if (e14 > this._width || t13 > this._height)
      return new t3();
    let i8 = null, s7 = -1;
    for (let h4 = 0; h4 < this._free.length; ++h4) {
      const w3 = this._free[h4];
      e14 <= w3.width && t13 <= w3.height && (null === i8 || w3.y <= i8.y && w3.x <= i8.x) && (i8 = w3, s7 = h4);
    }
    return null === i8 ? new t3() : (this._free.splice(s7, 1), i8.width < i8.height ? (i8.width > e14 && this._free.push(new t3(i8.x + e14, i8.y, i8.width - e14, t13)), i8.height > t13 && this._free.push(new t3(i8.x, i8.y + t13, i8.width, i8.height - t13))) : (i8.width > e14 && this._free.push(new t3(i8.x + e14, i8.y, i8.width - e14, i8.height)), i8.height > t13 && this._free.push(new t3(i8.x, i8.y + t13, e14, i8.height - t13))), new t3(i8.x, i8.y, e14, t13));
  }
  release(h4) {
    for (let e14 = 0; e14 < this._free.length; ++e14) {
      const t13 = this._free[e14];
      if (t13.y === h4.y && t13.height === h4.height && t13.x + t13.width === h4.x)
        t13.width += h4.width;
      else if (t13.x === h4.x && t13.width === h4.width && t13.y + t13.height === h4.y)
        t13.height += h4.height;
      else if (h4.y === t13.y && h4.height === t13.height && h4.x + h4.width === t13.x)
        t13.x = h4.x, t13.width += h4.width;
      else {
        if (h4.x !== t13.x || h4.width !== t13.width || h4.y + h4.height !== t13.y)
          continue;
        t13.y = h4.y, t13.height += h4.height;
      }
      this._free.splice(e14, 1), this.release(h4);
    }
    this._free.push(h4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n5 = class {
  constructor(e14, s7, i8) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e14, this.height = s7, this._glyphSource = i8, this._binPack = new e9(e14 - 4, s7 - 4), this._glyphData.push(new Uint8Array(e14 * s7)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s7, i8) {
    const h4 = [], r6 = this._glyphSource, n9 = /* @__PURE__ */ new Set(), o10 = 1 / 256;
    for (const t13 of i8) {
      const e14 = Math.floor(t13 * o10);
      n9.add(e14);
    }
    const a6 = [];
    return n9.forEach((t13) => {
      const e14 = s7 + t13;
      if (this._rangePromises.has(e14))
        a6.push(this._rangePromises.get(e14));
      else {
        const i9 = r6.getRange(s7, t13).then(() => {
          this._rangePromises.delete(e14);
        }, () => {
          this._rangePromises.delete(e14);
        });
        this._rangePromises.set(e14, i9), a6.push(i9);
      }
    }), Promise.all(a6).then(() => {
      let n10 = this._glyphIndex[s7];
      n10 || (n10 = {}, this._glyphIndex[s7] = n10);
      for (const o11 of i8) {
        const i9 = n10[o11];
        if (i9) {
          h4[o11] = { sdf: true, rect: i9.rect, metrics: i9.metrics, page: i9.page, code: o11 };
          continue;
        }
        const a7 = r6.getGlyph(s7, o11);
        if (!a7 || !a7.metrics)
          continue;
        const c5 = a7.metrics;
        let l9;
        if (0 === c5.width)
          l9 = new t3(0, 0, 0, 0);
        else {
          const e14 = 3, s8 = c5.width + 2 * e14, i10 = c5.height + 2 * e14;
          let h5 = s8 % 4 ? 4 - s8 % 4 : 4, r7 = i10 % 4 ? 4 - i10 % 4 : 4;
          1 === h5 && (h5 = 5), 1 === r7 && (r7 = 5), l9 = this._binPack.allocate(s8 + h5, i10 + r7), l9.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e9(this.width - 4, this.height - 4), l9 = this._binPack.allocate(s8 + h5, i10 + r7));
          const n11 = this._glyphData[this._currentPage], o12 = a7.bitmap;
          let g3, _3;
          if (o12)
            for (let t13 = 0; t13 < i10; t13++) {
              g3 = s8 * t13, _3 = this.width * (l9.y + t13 + 1) + l9.x;
              for (let t14 = 0; t14 < s8; t14++)
                n11[_3 + t14 + 1] = o12[g3 + t14];
            }
        }
        n10[o11] = { rect: l9, metrics: c5, tileIDs: null, page: this._currentPage }, h4[o11] = { sdf: true, rect: l9, metrics: c5, page: this._currentPage, code: o11 }, this._dirties[this._currentPage] = true;
      }
      return h4;
    });
  }
  removeGlyphs(t13) {
    for (const e14 in this._glyphIndex) {
      const s7 = this._glyphIndex[e14];
      if (!s7)
        continue;
      let i8;
      for (const e15 in s7)
        if (i8 = s7[e15], i8.tileIDs.delete(t13), 0 === i8.tileIDs.size) {
          const t14 = this._glyphData[i8.page], h4 = i8.rect;
          let r6, n9;
          for (let e16 = 0; e16 < h4.height; e16++)
            for (r6 = this.width * (h4.y + e16) + h4.x, n9 = 0; n9 < h4.width; n9++)
              t14[r6 + n9] = 0;
          delete s7[e15], this._dirties[i8.page] = true;
        }
    }
  }
  bind(t13, e14, n9, o10 = 0) {
    if (!this._textures[n9]) {
      const e15 = new e7();
      e15.pixelFormat = G.ALPHA, e15.wrapMode = D.CLAMP_TO_EDGE, e15.width = this.width, e15.height = this.height, this._textures[n9] = new T2(t13, e15, new Uint8Array(this.width * this.height));
    }
    const a6 = this._textures[n9];
    a6.setSamplingMode(e14), this._dirties[n9] && a6.setData(this._glyphData[n9]), t13.bindTexture(a6, o10), this._dirties[n9] = false;
  }
  dispose() {
    this._binPack = null;
    for (const t13 of this._textures)
      t13 && t13.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s5 = class {
  constructor(e14) {
    if (this._metrics = [], this._bitmaps = [], e14)
      for (; e14.next(); )
        switch (e14.tag()) {
          case 1: {
            const t13 = e14.getMessage();
            for (; t13.next(); )
              switch (t13.tag()) {
                case 3: {
                  const e15 = t13.getMessage();
                  let s7, a6, r6, n9, i8, c5, g3;
                  for (; e15.next(); )
                    switch (e15.tag()) {
                      case 1:
                        s7 = e15.getUInt32();
                        break;
                      case 2:
                        a6 = e15.getBytes();
                        break;
                      case 3:
                        r6 = e15.getUInt32();
                        break;
                      case 4:
                        n9 = e15.getUInt32();
                        break;
                      case 5:
                        i8 = e15.getSInt32();
                        break;
                      case 6:
                        c5 = e15.getSInt32();
                        break;
                      case 7:
                        g3 = e15.getUInt32();
                        break;
                      default:
                        e15.skip();
                    }
                  e15.release(), s7 && (this._metrics[s7] = { width: r6, height: n9, left: i8, top: c5, advance: g3 }, this._bitmaps[s7] = a6);
                  break;
                }
                default:
                  t13.skip();
              }
            t13.release();
            break;
          }
          default:
            e14.skip();
        }
  }
  getMetrics(e14) {
    return this._metrics[e14];
  }
  getBitmap(e14) {
    return this._bitmaps[e14];
  }
};
var a4 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e14) {
    return this._ranges[e14];
  }
  addRange(e14, t13) {
    this._ranges[e14] = t13;
  }
};
var r4 = class {
  constructor(e14) {
    this._glyphInfo = {}, this._baseURL = e14;
  }
  getRange(a6, r6) {
    const n9 = this._getFontStack(a6);
    if (n9.getRange(r6))
      return Promise.resolve();
    const i8 = 256 * r6, c5 = i8 + 255;
    if (this._baseURL) {
      const g3 = this._baseURL.replace("{fontstack}", a6).replace("{range}", i8 + "-" + c5);
      return j3(g3, { responseType: "array-buffer" }).then((e14) => {
        n9.addRange(r6, new s5(new n(new Uint8Array(e14.data), new DataView(e14.data))));
      }).catch(() => {
        n9.addRange(r6, new s5());
      });
    }
    return n9.addRange(r6, new s5()), Promise.resolve();
  }
  getGlyph(e14, t13) {
    const s7 = this._getFontStack(e14);
    if (!s7)
      return;
    const a6 = Math.floor(t13 / 256), r6 = s7.getRange(a6);
    return r6 ? { metrics: r6.getMetrics(t13), bitmap: r6.getBitmap(t13) } : void 0;
  }
  _getFontStack(e14) {
    let t13 = this._glyphInfo[e14];
    return t13 || (t13 = this._glyphInfo[e14] = new a4()), t13;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r5 = "dasharray-";
var o3 = class _o {
  constructor(t13, e14, s7 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t13 <= 0 || e14 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t13, this._pageHeight = e14, s7 > 0 && (this._maxItemSize = s7), this._binPack = new e9(t13 - 4, e14 - 4);
  }
  dispose() {
    this._binPack = null, this._mosaicRects = {};
    for (const t13 of this._textures)
      t13 && t13.dispose();
    this._textures.length = 0;
  }
  getWidth(t13) {
    return t13 >= this._size.length ? -1 : this._size[t13][0];
  }
  getHeight(t13) {
    return t13 >= this._size.length ? -1 : this._size[t13][1];
  }
  getPageSize(t13) {
    return t13 >= this._size.length ? null : this._size[t13];
  }
  setSpriteSource(t13) {
    if (this.dispose(), this.pixelRatio = t13.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4);
      const t14 = Math.floor(this._pageWidth), e14 = Math.floor(this._pageHeight), s7 = new Uint32Array(t14 * e14);
      this._mosaicsData[0] = s7, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t13;
  }
  getSpriteItem(t13, i8 = false) {
    let e14, s7, h4 = this._mosaicRects[t13];
    if (h4)
      return h4;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t13 && t13.startsWith(r5) ? ([e14, s7] = this._rasterizeDash(t13), i8 = true) : e14 = this._sprites.getSpriteInfo(t13), !e14 || !e14.width || !e14.height || e14.width < 0 || e14.height < 0)
      return null;
    const a6 = e14.width, o10 = e14.height, [n9, _3, g3] = this._allocateImage(a6, o10);
    return n9.width <= 0 ? null : (this._copy(n9, e14, _3, g3, i8, s7), h4 = { rect: n9, width: a6, height: o10, sdf: e14.sdf, simplePattern: false, pixelRatio: e14.pixelRatio, page: _3 }, this._mosaicRects[t13] = h4, h4);
  }
  getSpriteItems(t13) {
    const i8 = {};
    for (const e14 of t13)
      i8[e14.name] = this.getSpriteItem(e14.name, e14.repeat);
    return i8;
  }
  getMosaicItemPosition(t13, i8) {
    const e14 = this.getSpriteItem(t13, i8), s7 = e14 && e14.rect;
    if (!s7)
      return null;
    s7.width = e14.width, s7.height = e14.height;
    const h4 = e14.width, a6 = e14.height, r6 = 2;
    return { tl: [s7.x + r6, s7.y + r6], br: [s7.x + r6 + h4, s7.y + r6 + a6], page: e14.page };
  }
  bind(t13, i8, e14 = 0, r6 = 0) {
    if (e14 >= this._size.length || e14 >= this._mosaicsData.length)
      return;
    if (!this._textures[e14]) {
      const i9 = new e7();
      i9.wrapMode = D.CLAMP_TO_EDGE, i9.width = this._size[e14][0], i9.height = this._size[e14][1], this._textures[e14] = new T2(t13, i9, new Uint8Array(this._mosaicsData[e14].buffer));
    }
    const o10 = this._textures[e14];
    o10.setSamplingMode(i8), this._dirties[e14] && o10.setData(new Uint8Array(this._mosaicsData[e14].buffer)), t13.bindTexture(o10, r6), this._dirties[e14] = false;
  }
  static _copyBits(t13, i8, e14, s7, h4, a6, r6, o10, n9, _3, g3) {
    let c5 = s7 * i8 + e14, l9 = o10 * a6 + r6;
    if (g3) {
      l9 -= a6;
      for (let r7 = -1; r7 <= _3; r7++, c5 = ((r7 + _3) % _3 + s7) * i8 + e14, l9 += a6)
        for (let i9 = -1; i9 <= n9; i9++)
          h4[l9 + i9] = t13[c5 + (i9 + n9) % n9];
    } else
      for (let p3 = 0; p3 < _3; p3++) {
        for (let i9 = 0; i9 < n9; i9++)
          h4[l9 + i9] = t13[c5 + i9];
        c5 += i8, l9 += a6;
      }
  }
  _copy(t13, i8, e14, s7, h4, a6) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e14 >= this._mosaicsData.length)
      return;
    const r6 = new Uint32Array(a6 ? a6.buffer : this._sprites.image.buffer), n9 = this._mosaicsData[e14];
    n9 && r6 || console.error("Source or target images are uninitialized!");
    const _3 = 2, g3 = a6 ? i8.width : this._sprites.width;
    _o._copyBits(r6, g3, i8.x, i8.y, n9, s7[0], t13.x + _3, t13.y + _3, i8.width, i8.height, h4), this._dirties[e14] = true;
  }
  _allocateImage(t13, s7) {
    t13 += 2, s7 += 2;
    const h4 = Math.max(t13, s7);
    if (this._maxItemSize && this._maxItemSize < h4) {
      const i8 = new t3(0, 0, t13, s7);
      return this._mosaicsData.push(new Uint32Array(t13 * s7)), this._dirties.push(true), this._size.push([t13, s7]), this._textures.push(void 0), [i8, this._mosaicsData.length - 1, [t13, s7]];
    }
    let a6 = t13 % 4 ? 4 - t13 % 4 : 4, r6 = s7 % 4 ? 4 - s7 % 4 : 4;
    1 === a6 && (a6 = 5), 1 === r6 && (r6 = 5);
    const o10 = this._binPack.allocate(t13 + a6, s7 + r6);
    return o10.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t13, s7)) : [o10, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i8) {
    const e14 = /\[(.*?)\]/, s7 = i8.match(e14);
    if (!s7)
      return null;
    const h4 = s7[1].split(",").map(Number), a6 = i8.slice(i8.lastIndexOf("-") + 1), [r6, o10, n9] = e8(h4, a6);
    return [{ x: 0, y: 0, width: o10, height: n9, sdf: true, pixelRatio: 1 }, new Uint8Array(r6.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var h2 = class {
  constructor(t13, e14, s7) {
    this._layer = t13, this._styleRepository = e14, this.devicePixelRatio = s7, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e2(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t13) {
    this._requestSprite(t13);
    const s7 = this._layer.currentStyleInfo.glyphsUrl, r6 = new r4(s7 ? kt(s7, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n5(1024, 1024, r6), this._broadcastPromise = f2("WorkerTileHandler", { client: this, schedule: t13.schedule, signal: t13.signal }).then((s8) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s8, this._layer && !this._connection.closed)) {
        const r7 = s8.broadcast("setStyle", this._layer.currentStyleInfo.style, t13);
        Promise.all(r7).catch((t14) => m(t14));
      }
    });
  }
  _requestSprite(t13) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e14 = new AbortController();
    this._spriteSourceAbortController = e14;
    const r6 = t13 == null ? void 0 : t13.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r6 && (this._inputSignalEventListener = p(e14), r6.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i8 } = e14, o10 = { ...t13, signal: i8 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o10), this._spriteSourcePromise.then((t14) => {
      f(i8), this._spriteMosaic = new o3(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t14);
    });
  }
  async updateStyle(t13) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", t13)), this._broadcastPromise;
  }
  setSpriteSource(t13) {
    const e14 = new o3(1024, 1024, 250);
    return e14.setSpriteSource(t13), this._spriteMosaic = e14, this._spriteSourcePromise = Promise.resolve(t13), this._spriteSourceAbortController = null, e14;
  }
  async setStyle(t13, e14) {
    await this._broadcastPromise, this._styleRepository = t13, this._requestSprite();
    const s7 = new r4(this._layer.currentStyleInfo.glyphsUrl ? kt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n5(1024, 1024, s7), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", e14)), this._broadcastPromise;
  }
  fetchTileData(t13, e14) {
    return this._getRefKeys(t13, e14).then((t14) => {
      const s7 = this._layer.sourceNameToSource, r6 = [];
      for (const e15 in s7)
        r6.push(e15);
      return this._getSourcesData(r6, t14, e14);
    });
  }
  parseTileData(t13, e14) {
    const s7 = t13 && t13.data;
    if (!s7)
      return Promise.resolve(null);
    const { sourceName2DataAndRefKey: r6, transferList: i8 } = s7;
    return 0 === Object.keys(r6).length ? Promise.resolve(null) : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t13.key.id, sourceName2DataAndRefKey: r6, styleLayerUIDs: t13.styleLayerUIDs }, { ...e14, transferList: i8 }));
  }
  async getSprites(t13) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t13);
  }
  getGlyphs(t13) {
    return this._glyphMosaic.getGlyphItems(t13.font, t13.codePoints);
  }
  async _getTilePayload(t13, e14, s7) {
    const i8 = e4.pool.acquire(t13.id), o10 = this._layer.sourceNameToSource[e14], { level: n9, row: l9, col: a6 } = i8;
    e4.pool.release(i8);
    try {
      return { protobuff: await o10.requestTile(n9, l9, a6, s7), sourceName: e14 };
    } catch (c5) {
      if (d(c5))
        throw c5;
      return { protobuff: null, sourceName: e14 };
    }
  }
  _getRefKeys(t13, e14) {
    const s7 = this._layer.sourceNameToSource, r6 = new Array();
    for (const i8 in s7) {
      const o10 = s7[i8].getRefKey(t13, e14);
      r6.push(o10);
    }
    return j(r6);
  }
  _getSourcesData(t13, e14, s7) {
    const r6 = [];
    for (let i8 = 0; i8 < e14.length; i8++)
      if (null == e14[i8].value || null == t13[i8])
        r6.push(null);
      else {
        const o10 = this._getTilePayload(e14[i8].value, t13[i8], s7);
        r6.push(o10);
      }
    return j(r6).then((t14) => {
      const s8 = {}, r7 = [];
      for (let i8 = 0; i8 < t14.length; i8++) {
        const o10 = t14[i8].value;
        if (o10 && (o10.protobuff && o10.protobuff.byteLength > 0)) {
          const t15 = e14[i8].value.id;
          s8[o10.sourceName] = { refKey: t15, protobuff: o10.protobuff }, r7.push(o10.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s8, transferList: r7 };
    });
  }
};
function p(t13) {
  return () => t13.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i4(e14, t13, n9, o10, i8, l9) {
  const { iconRotationAlignment: a6, textRotationAlignment: c5, iconTranslate: h4, iconTranslateAnchor: u3, textTranslate: d6, textTranslateAnchor: y3 } = o10;
  let x = 0;
  for (const g3 of e14.colliders) {
    const [e15, o11] = 0 === g3.partIndex ? h4 : d6, m2 = 0 === g3.partIndex ? u3 : y3, f5 = g3.minLod <= l9 && l9 <= g3.maxLod;
    x += f5 ? 0 : 1, g3.enabled = f5, g3.xScreen = g3.xTile * i8[0] + g3.yTile * i8[3] + i8[6], g3.yScreen = g3.xTile * i8[1] + g3.yTile * i8[4] + i8[7], m2 === r.MAP ? (g3.xScreen += n9 * e15 - t13 * o11, g3.yScreen += t13 * e15 + n9 * o11) : (g3.xScreen += e15, g3.yScreen += o11), l3.VIEWPORT === (0 === g3.partIndex ? a6 : c5) ? (g3.dxScreen = g3.dxPixels, g3.dyScreen = g3.dyPixels) : (g3.dxScreen = n9 * (g3.dxPixels + g3.width / 2) - t13 * (g3.dyPixels + g3.height / 2) - g3.width / 2, g3.dyScreen = t13 * (g3.dxPixels + g3.width / 2) + n9 * (g3.dyPixels + g3.height / 2) - g3.height / 2);
  }
  e14.colliders.length > 0 && x === e14.colliders.length && (e14.unique.show = false);
}
var l5 = class {
  constructor(o10, r6, s7, i8, l9, a6) {
    this._symbols = o10, this._styleRepository = i8, this._zoom = l9, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new o2(r6, s7, t4), this._si = Math.sin(Math.PI * a6 / 180), this._co = Math.cos(Math.PI * a6 / 180);
    for (const t13 of o10)
      for (const n9 of t13.symbols)
        this._allNeededMatrices.has(n9.tile) || this._allNeededMatrices.set(n9.tile, r2(n9.tile.transforms.tileUnitsToPixels));
  }
  work(e14) {
    const t13 = this._gridIndex;
    function n9(e15) {
      const n10 = e15.xScreen + e15.dxScreen, o11 = e15.yScreen + e15.dyScreen, r6 = n10 + e15.width, s7 = o11 + e15.height, [i8, l9, a6, c5] = t13.getCellSpan(n10, o11, r6, s7);
      for (let h4 = l9; h4 <= c5; h4++)
        for (let e16 = i8; e16 <= a6; e16++) {
          const i9 = t13.cells[h4][e16];
          for (const e17 of i9) {
            const t14 = e17.xScreen + e17.dxScreen, i10 = e17.yScreen + e17.dyScreen, l10 = t14 + e17.width, a7 = i10 + e17.height;
            if (!(r6 < t14 || n10 > l10 || s7 < i10 || o11 > a7))
              return true;
          }
        }
      return false;
    }
    const o10 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t14 = this._symbols[this._currentLayerCursor], r6 = this._getProperties(t14.styleLayerUID);
      for (; this._currentSymbolCursor < t14.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o10 > e14)
          return false;
        const s7 = t14.symbols[this._currentSymbolCursor];
        if (!s7.unique.show)
          continue;
        i4(s7, this._si, this._co, r6, this._allNeededMatrices.get(s7.tile), this._zoom);
        const l9 = s7.unique;
        if (!l9.show)
          continue;
        const { iconAllowOverlap: a6, iconIgnorePlacement: c5, textAllowOverlap: h4, textIgnorePlacement: u3 } = r6;
        for (const e15 of s7.colliders) {
          if (!e15.enabled)
            continue;
          const t15 = l9.parts[e15.partIndex];
          if (!t15.show)
            continue;
          !(e15.partIndex ? h4 : a6) && n9(e15) && (e15.hard ? l9.show = false : t15.show = false);
        }
        if (l9.show)
          for (const e15 of s7.colliders) {
            if (!e15.enabled)
              continue;
            if (e15.partIndex ? u3 : c5)
              continue;
            if (!l9.parts[e15.partIndex].show)
              continue;
            const t15 = e15.xScreen + e15.dxScreen, n10 = e15.yScreen + e15.dyScreen, o11 = t15 + e15.width, r7 = n10 + e15.height, [s8, i8, a7, h5] = this._gridIndex.getCellSpan(t15, n10, o11, r7);
            for (let l10 = i8; l10 <= h5; l10++)
              for (let t16 = s8; t16 <= a7; t16++) {
                this._gridIndex.cells[l10][t16].push(e15);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e14) {
    const t13 = this._styleProps.get(e14);
    if (t13)
      return t13;
    const n9 = this._zoom, s7 = this._styleRepository.getStyleLayerByUID(e14), i8 = s7.getLayoutValue("symbol-placement", n9) !== n3.POINT;
    let l9 = s7.getLayoutValue("icon-rotation-alignment", n9);
    l9 === l3.AUTO && (l9 = i8 ? l3.MAP : l3.VIEWPORT);
    let a6 = s7.getLayoutValue("text-rotation-alignment", n9);
    a6 === l3.AUTO && (a6 = i8 ? l3.MAP : l3.VIEWPORT);
    const c5 = s7.getPaintValue("icon-translate", n9), h4 = s7.getPaintValue("icon-translate-anchor", n9), u3 = s7.getPaintValue("text-translate", n9), d6 = s7.getPaintValue("text-translate-anchor", n9), y3 = { iconAllowOverlap: s7.getLayoutValue("icon-allow-overlap", n9), iconIgnorePlacement: s7.getLayoutValue("icon-ignore-placement", n9), textAllowOverlap: s7.getLayoutValue("text-allow-overlap", n9), textIgnorePlacement: s7.getLayoutValue("text-ignore-placement", n9), iconRotationAlignment: l9, textRotationAlignment: a6, iconTranslateAnchor: h4, iconTranslate: c5, textTranslateAnchor: d6, textTranslate: u3 };
    return this._styleProps.set(e14, y3), y3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t7(o10, t13) {
  if (o10.priority - t13.priority)
    return o10.priority - t13.priority;
  const e14 = o10.tile.key, i8 = t13.tile.key;
  return e14.world - i8.world ? e14.world - i8.world : e14.level - i8.level ? e14.level - i8.level : e14.row - i8.row ? e14.row - i8.row : e14.col - i8.col ? e14.col - i8.col : o10.xTile - t13.xTile ? o10.xTile - t13.xTile : o10.yTile - t13.yTile;
}
var e10 = class {
  get running() {
    return this._running;
  }
  constructor(o10, t13, e14, i8, s7, n9) {
    this._visibleTiles = o10, this._symbolRepository = t13, this._createCollisionJob = e14, this._assignTileSymbolsOpacity = i8, this._symbolLayerSorter = s7, this._isLayerVisible = n9, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o10, t13) {
    this._screenWidth === o10 && this._screenHeight === t13 || this.restart(), this._screenWidth = o10, this._screenHeight = t13;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o10) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t13 = performance.now();
      if (!this._selectionJob.work(o10))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o10 = Math.max(0, o10 - (performance.now() - t13))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t13 = performance.now();
      if (!this._collisionJob.work(o10))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o10 = Math.max(0, o10 - (performance.now() - t13))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t13 = performance.now();
      if (!this._opacityJob.work(o10))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o10 = Math.max(0, o10 - (performance.now() - t13))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o10 = this._symbolRepository.uniqueSymbols;
    for (let t13 = 0; t13 < o10.length; t13++) {
      const e15 = o10[t13];
      for (let o11 = 0; o11 < e15.uniqueSymbols.length; o11++) {
        const t14 = e15.uniqueSymbols[o11];
        for (const o12 of t14.tileSymbols)
          o12.selectedForRendering = false;
      }
    }
    const e14 = [];
    let i8 = 0, s7 = 0;
    const n9 = this._isLayerVisible;
    function r6(r7) {
      let l10;
      const c5 = performance.now();
      for (; s7 < o10.length; s7++, i8 = 0) {
        const t13 = o10[s7], h4 = t13.styleLayerUID;
        if (!n9(h4)) {
          e14[s7] || (e14[s7] = { styleLayerUID: h4, symbols: [] });
          continue;
        }
        e14[s7] = e14[s7] || { styleLayerUID: h4, symbols: [] };
        const a6 = e14[s7];
        for (; i8 < t13.uniqueSymbols.length; i8++) {
          if (l10 = t13.uniqueSymbols[i8], i8 % 100 == 99 && performance.now() - c5 > r7)
            return false;
          let o11 = null, e15 = false, s8 = false;
          for (const t14 of l10.tileSymbols)
            if (!s8 || !e15) {
              const i9 = t14.tile;
              (!o11 || i9.isCoverage || i9.neededForCoverage && !e15) && (o11 = t14, (i9.neededForCoverage || i9.isCoverage) && (s8 = true), i9.isCoverage && (e15 = true));
            }
          if (o11.selectedForRendering = true, s8) {
            a6.symbols.push(o11), l10.show = true;
            for (const o12 of l10.parts)
              o12.show = true;
          } else
            l10.show = false;
        }
      }
      for (const o11 of e14)
        o11.symbols.sort(t7);
      return true;
    }
    const l9 = this._symbolLayerSorter;
    return { work: r6, get sortedSymbols() {
      return e14.sort(l9);
    } };
  }
  _createOpacityJob() {
    const o10 = this._assignTileSymbolsOpacity, t13 = this._visibleTiles;
    let e14 = 0;
    function s7(t14, e15) {
      const n9 = t14.symbols;
      for (const [o11, s8] of n9)
        i5(s8, e15);
      o10(t14, e15);
      for (const o11 of t14.childrenTiles)
        s7(o11, e15);
    }
    return { work(o11) {
      const i8 = performance.now();
      for (; e14 < t13.length; e14++) {
        if (performance.now() - i8 > o11)
          return false;
        const n9 = t13[e14];
        if (null != n9.parentTile)
          continue;
        s7(n9, performance.now());
      }
      return true;
    } };
  }
};
function i5(t13, e14) {
  for (const i8 of t13) {
    const t14 = i8.unique;
    for (const i9 of t14.parts) {
      const s7 = i9.targetOpacity > 0.5 ? 1 : -1;
      i9.startOpacity += s7 * ((e14 - i9.startTime) / e5), i9.startOpacity = Math.min(Math.max(i9.startOpacity, 0), 1), i9.startTime = e14, i9.targetOpacity = t14.show && i9.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var l6 = 32;
var o4 = 8;
var t8 = 64;
var i6 = class {
  constructor(e14, s7, l9) {
    this.tileCoordRange = e14, this._visibleTiles = s7, this._createUnique = l9, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  add(s7, i8) {
    this._uniqueSymbolLayerArray = null;
    let n9 = this._tiles.get(s7.id);
    n9 || (n9 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s7.id, n9));
    const r6 = /* @__PURE__ */ new Map();
    if (i8)
      for (const e14 of i8)
        n9.symbols.has(e14) && (r6.set(e14, n9.symbols.get(e14)), n9.symbols.delete(e14));
    else
      for (const [e14, l9] of s7.layerData)
        n9.symbols.has(e14) && (r6.set(e14, n9.symbols.get(e14)), n9.symbols.delete(e14));
    this._removeSymbols(r6);
    const y3 = s7.symbols, a6 = /* @__PURE__ */ new Map();
    for (const [f5, c5] of y3) {
      let s8 = c5.length;
      if (s8 >= l6) {
        let l9 = this.tileCoordRange;
        do {
          l9 /= 2, s8 /= 4;
        } while (s8 > o4 && l9 > t8);
        const i9 = new o2(this.tileCoordRange, this.tileCoordRange, l9);
        a6.set(f5, { flat: c5, index: i9 }), n9.symbols.set(f5, { flat: c5, index: i9 });
        for (const e14 of c5)
          i9.getCell(e14.xTile, e14.yTile).push(e14);
      } else
        a6.set(f5, { flat: c5 }), n9.symbols.set(f5, { flat: c5 });
    }
    this._addSymbols(s7.key, y3);
  }
  deleteStyleLayers(e14) {
    this._uniqueSymbolLayerArray = null;
    for (const [s7, l9] of this._tiles) {
      const o10 = /* @__PURE__ */ new Map();
      for (const s8 of e14)
        l9.symbols.has(s8) && (o10.set(s8, l9.symbols.get(s8)), l9.symbols.delete(s8));
      this._removeSymbols(o10), 0 === l9.symbols.size && this._tiles.delete(s7);
    }
  }
  removeTile(e14) {
    this._uniqueSymbolLayerArray = null;
    const s7 = this._tiles.get(e14.id);
    if (!s7)
      return;
    const l9 = /* @__PURE__ */ new Map();
    for (const [o10, t13] of e14.symbols)
      s7.symbols.has(o10) && (l9.set(o10, s7.symbols.get(o10)), s7.symbols.delete(o10));
    this._removeSymbols(l9), 0 === s7.symbols.size && this._tiles.delete(e14.id);
  }
  _removeSymbols(e14) {
    for (const [s7, { flat: l9 }] of e14)
      for (const e15 of l9) {
        const l10 = e15.unique, o10 = l10.tileSymbols, t13 = o10.length - 1;
        for (let s8 = 0; s8 < t13; s8++)
          if (o10[s8] === e15) {
            o10[s8] = o10[t13];
            break;
          }
        if (o10.length = t13, 0 === t13) {
          const e16 = this._uniqueSymbolsReferences.get(s7);
          e16.delete(l10), 0 === e16.size && this._uniqueSymbolsReferences.delete(s7);
        }
        e15.unique = null;
      }
  }
  _addSymbols(e14, s7) {
    if (0 === s7.size)
      return;
    const l9 = this._visibleTiles;
    for (const o10 of l9)
      o10.parentTile || o10.key.world !== e14.world || o10.key.level === e14.level && !o10.key.equals(e14) || this._matchSymbols(o10, e14, s7);
    for (const [o10, t13] of s7)
      for (const e15 of t13)
        if (null == e15.unique) {
          const s8 = this._createUnique();
          e15.unique = s8, s8.tileSymbols.push(e15);
          let l10 = this._uniqueSymbolsReferences.get(o10);
          l10 || (l10 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o10, l10)), l10.add(s8);
        }
  }
  _matchSymbols(e14, l9, o10) {
    if (e14.key.level > l9.level) {
      const s7 = e14.key.level - l9.level;
      if (e14.key.row >> s7 !== l9.row || e14.key.col >> s7 !== l9.col)
        return;
    }
    if (l9.level > e14.key.level) {
      const s7 = l9.level - e14.key.level;
      if (l9.row >> s7 !== e14.key.row || l9.col >> s7 !== e14.key.col)
        return;
    }
    if (l9.equals(e14.key)) {
      for (const s7 of e14.childrenTiles)
        this._matchSymbols(s7, l9, o10);
      return;
    }
    const t13 = /* @__PURE__ */ new Map();
    for (const [i8, n9] of o10) {
      const o11 = [];
      for (const t14 of n9) {
        const i9 = s4(this.tileCoordRange, t14.xTile, l9.level, l9.col, e14.key.level, e14.key.col), n10 = s4(this.tileCoordRange, t14.yTile, l9.level, l9.row, e14.key.level, e14.key.row);
        i9 >= 0 && i9 < this.tileCoordRange && n10 >= 0 && n10 < this.tileCoordRange && o11.push({ symbol: t14, xTransformed: i9, yTransformed: n10 });
      }
      const r6 = [], y3 = e14.key.level < l9.level ? 1 : 1 << e14.key.level - l9.level, a6 = this._tiles.get(e14.id).symbols.get(i8);
      if (a6) {
        const e15 = a6.flat;
        for (const s7 of o11) {
          let l10, o12 = false;
          const t14 = s7.xTransformed, i9 = s7.yTransformed;
          l10 = null != a6.index ? a6.index.getCell(t14, i9) : e15;
          const n10 = s7.symbol, f5 = n10.hash;
          for (const e16 of l10)
            if (f5 === e16.hash && Math.abs(t14 - e16.xTile) <= y3 && Math.abs(i9 - e16.yTile) <= y3) {
              const s8 = e16.unique;
              n10.unique = s8, s8.tileSymbols.push(n10), o12 = true;
              break;
            }
          o12 || r6.push(n10);
        }
      }
      r6.length > 0 && t13.set(i8, r6);
    }
    for (const s7 of e14.childrenTiles)
      this._matchSymbols(s7, l9, t13);
  }
  _createUniqueSymbolLayerArray() {
    const e14 = this._uniqueSymbolsReferences, s7 = new Array(e14.size);
    let l9, o10 = 0;
    for (const [t13, i8] of e14) {
      const e15 = new Array(i8.size);
      l9 = 0;
      for (const s8 of i8)
        e15[l9++] = s8;
      s7[o10] = { styleLayerUID: t13, uniqueSymbols: e15 }, o10++;
    }
    return s7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobsUtil.js
function p2(p3) {
  const y3 = [], a6 = new i6(4096, y3, () => {
    const e14 = new s3();
    return e14.show = false, e14.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e14.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e14;
  }), m2 = new e10(y3, a6, (t13, r6, o10) => new l5(t13, r6, o10, p3.styleRepository, p3.key.level, 0), (t13, e14) => {
    i3(t13, e14, false);
  }, () => 0, (t13) => {
    const e14 = p3.styleRepository.getStyleLayerByUID(t13).getLayoutProperty("visibility");
    return !e14 || e14.getValue() !== i2.NONE;
  });
  y3.push(p3), a6.add(p3), m2.setScreenSize(512, 512), m2.continue(1 / 0);
}

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t9 = class extends h {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e14) {
    const l9 = e4.pool.acquire(e14), t13 = 0 === l9.level ? null : e4.getId(l9.level - 1, l9.row >> 1, l9.col >> 1, l9.world);
    return e4.pool.release(l9), t13;
  }
  getTileCoverage(e14, l9, s7 = true, t13) {
    const o10 = super.getTileCoverage(e14, l9, s7, t13);
    if (!o10)
      return o10;
    const i8 = 1 << o10.lodInfo.level;
    return o10.spans = o10.spans.filter((e15) => e15.row >= 0 && e15.row < i8), o10;
  }
  scaleToLevel(e14) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e14])
      return this._levelByScale[e14];
    {
      const l9 = this._fullCacheLodInfos;
      if (e14 > l9[0].scale)
        return l9[0].level;
      let s7, t13;
      for (let o10 = 0; o10 < l9.length - 1; o10++)
        if (t13 = l9[o10 + 1], e14 > t13.scale)
          return s7 = l9[o10], s7.level + (s7.scale - e14) / (s7.scale - t13.scale);
      return l9[l9.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l9) {
    let s7;
    if (0 === l9[0].level)
      s7 = l9.map((e14) => ({ level: e14.level, resolution: e14.resolution, scale: e14.scale }));
    else {
      const l10 = this.tileInfo.size[0], t13 = this.tileInfo.spatialReference;
      s7 = j4.create({ size: l10, spatialReference: t13 }).lods.map((e14) => ({ level: e14.level, resolution: e14.resolution, scale: e14.scale }));
    }
    for (let e14 = 0; e14 < s7.length; e14++)
      this._levelByScale[s7[e14].scale] = s7[e14].level;
    this._fullCacheLodInfos = s7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler3D.js
var g = class extends h2 {
  constructor(e14, t13, o10, i8) {
    super(e14, t13, o10), this._memCache = i8, this._ongoingTileRequests = /* @__PURE__ */ new Map(), this._ongoingRequestToController = /* @__PURE__ */ new Map(), this._tileInfoView = new t9(e14.tileInfo, e14.fullExtent);
  }
  destroy() {
    super.destroy(), this._ongoingRequestToController.forEach((e14) => e14.abort()), this._ongoingRequestToController.clear(), this._ongoingTileRequests.clear();
  }
  async getVectorTile(s7, l9, g3, h4) {
    const u3 = new e4(s7, l9, g3, 0);
    let m2 = this._memCache.get(u3.id);
    if (null != m2)
      return m2.retain(), m2;
    const c5 = await this._getVectorTileData(u3);
    if (s2(h4), !this._layer)
      return null;
    if (m2 = this._memCache.get(u3.id), null != m2)
      return m2.retain(), m2;
    const T3 = this._layer.tileInfo.getTileBounds(i(), u3), _3 = this._tileInfoView.getTileResolution(s7);
    return m2 = new d3(u3, _3, T3[0], T3[3], 512, 512, this._styleRepository, this._memCache), c5 ? (m2.setData(c5), m2.retain(), this._memCache.put(u3.id, m2, m2.memoryUsed, e3)) : m2.setData(null), m2.neededForCoverage = true, m2.transforms.tileUnitsToPixels = t5(1 / 8, 0, 0, 0, 1 / 8, 0, 0, 0, 1), p2(m2), m2;
  }
  _getVectorTileData(e14) {
    const t13 = e14.id;
    if (this._ongoingTileRequests.has(t13))
      return this._ongoingTileRequests.get(t13);
    const o10 = new AbortController(), i8 = { signal: o10.signal }, s7 = this._getParsedVectorTileData(e14, i8).then((e15) => (this._ongoingTileRequests.delete(t13), this._ongoingRequestToController.delete(t13), e15)).catch(() => (this._ongoingTileRequests.delete(t13), this._ongoingRequestToController.delete(t13), null));
    return this._ongoingTileRequests.set(t13, s7), this._ongoingRequestToController.set(t13, o10), s7;
  }
  _getParsedVectorTileData(e14, t13) {
    return this.fetchTileData(e14, t13).then((o10) => this.parseTileData({ key: e14, data: o10 }, t13));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrush.js
var t10 = class {
  constructor() {
    this.name = this.constructor.name || "UnnamedBrush", this.brushEffect = null;
  }
  prepareState(t13, r6) {
  }
  draw(t13, r6, s7) {
  }
  drawMany(t13, r6, s7) {
    for (const a6 of r6)
      a6.visible && this.draw(t13, a6, s7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLBackground.js
var _ = class extends t10 {
  constructor() {
    super(...arguments), this._color = r3(1, 0, 0, 1), this._patternMatrix = e6(), this._programOptions = { id: false, pattern: false };
  }
  dispose() {
    this._vao && (this._vao.dispose(), this._vao = null);
  }
  drawMany(e14, r6) {
    const { context: n9, painter: c5, styleLayerUID: u3, requestRender: p3, allowDelayedRender: _3 } = e14;
    this._loadWGLResources(e14);
    const d6 = e14.displayLevel, h4 = e14.styleLayer, g3 = h4.backgroundMaterial, v2 = c5.vectorTilesMaterialManager, y3 = h4.getPaintValue("background-color", d6), b2 = h4.getPaintValue("background-opacity", d6), x = h4.getPaintValue("background-pattern", d6), M3 = void 0 !== x, j5 = y3[3] * b2, U = 1 | window.devicePixelRatio, w3 = e14.spriteMosaic;
    let L3, A;
    const P = U > te ? 2 : 1, I2 = e14.drawPhase === T.HITTEST, R2 = this._programOptions;
    R2.id = I2, R2.pattern = M3;
    const k2 = v2.getMaterialProgram(n9, g3, R2);
    if (!_3 || null == p3 || k2.compiled) {
      if (n9.bindVAO(this._vao), n9.useProgram(k2), M3) {
        const t13 = w3.getMosaicItemPosition(x, true);
        if (null != t13) {
          const { tl: e15, br: r7, page: i8 } = t13;
          L3 = r7[0] - e15[0], A = r7[1] - e15[1];
          const s7 = w3.getPageSize(i8);
          null != s7 && (w3.bind(n9, L.LINEAR, i8, ee), k2.setUniform4f("u_tlbr", e15[0], e15[1], r7[0], r7[1]), k2.setUniform2fv("u_mosaicSize", s7), k2.setUniform1i("u_texture", ee));
        }
        k2.setUniform1f("u_opacity", b2);
      } else
        this._color[0] = j5 * y3[0], this._color[1] = j5 * y3[1], this._color[2] = j5 * y3[2], this._color[3] = j5, k2.setUniform4fv("u_color", this._color);
      if (k2.setUniform1f("u_depth", h4.z || 0), I2) {
        const t13 = M(u3 + 1);
        k2.setUniform4fv("u_id", t13);
      }
      for (const e15 of r6) {
        if (k2.setUniform1f("u_coord_range", e15.rangeX), k2.setUniformMatrix3fv("u_dvsMat3", e15.transforms.dvs), M3) {
          const r7 = Math.max(2 ** (Math.round(d6) - e15.key.level), 1), o10 = P * e15.width * r7, i8 = o10 / c(L3), s7 = o10 / c(A);
          this._patternMatrix[0] = i8, this._patternMatrix[4] = s7, k2.setUniformMatrix3fv("u_pattern_matrix", this._patternMatrix);
        }
        n9.setStencilFunction(I.EQUAL, 0, 255), n9.drawArrays(E.TRIANGLE_STRIP, 0, 4);
      }
    } else
      p3();
  }
  _loadWGLResources(t13) {
    if (this._vao)
      return;
    const { context: e14, styleLayer: r6 } = t13, o10 = r6.backgroundMaterial, i8 = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]), s7 = c3.createVertex(e14, F.STATIC_DRAW, i8), a6 = new u(e14, o10.getAttributeLocations(), o10.getLayoutInfo(), { geometry: s7 });
    this._vao = a6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLCircle.js
var o5 = class extends t10 {
  constructor() {
    super(...arguments), this._programOptions = { id: false };
  }
  dispose() {
  }
  drawMany(i8, o10) {
    const { context: l9, displayLevel: c5, requiredLevel: u3, state: d6, drawPhase: f5, painter: m2, spriteMosaic: p3, styleLayerUID: y3, requestRender: v2, allowDelayedRender: g3 } = i8;
    if (!o10.some((e14) => {
      var _a;
      return ((_a = e14.layerData.get(y3)) == null ? void 0 : _a.circleIndexCount) ?? false;
    }))
      return;
    const E2 = i8.styleLayer, M3 = E2.circleMaterial, T3 = m2.vectorTilesMaterialManager, I2 = 1.2, U = E2.getPaintValue("circle-translate", c5), _3 = E2.getPaintValue("circle-translate-anchor", c5), x = f5 === T.HITTEST, R2 = this._programOptions;
    R2.id = x;
    const h4 = T3.getMaterialProgram(l9, M3, R2);
    if (g3 && null != v2 && !h4.compiled)
      return void v2();
    l9.useProgram(h4), h4.setUniformMatrix3fv("u_displayMat3", _3 === r.VIEWPORT ? d6.displayMat3 : d6.displayViewMat3), h4.setUniform2fv("u_circleTranslation", U), h4.setUniform1f("u_depth", E2.z), h4.setUniform1f("u_antialiasingWidth", I2);
    let D2 = -1;
    if (x) {
      const e14 = M(y3 + 1);
      h4.setUniform4fv("u_id", e14);
    }
    for (const e14 of o10) {
      if (!e14.layerData.has(y3))
        continue;
      e14.key.level !== D2 && (D2 = e14.key.level, M3.setDataUniforms(h4, c5, E2, D2, p3));
      const t13 = e14.layerData.get(y3);
      if (!t13.circleIndexCount)
        continue;
      t13.prepareForRendering(l9);
      const r6 = t13.vao;
      null != r6 && (l9.bindVAO(r6), h4.setUniformMatrix3fv("u_dvsMat3", e14.transforms.dvs), u3 !== e14.key.level ? l9.setStencilFunction(I.EQUAL, e14.stencilRef, 255) : l9.setStencilFunction(I.GREATER, 255, 255), l9.drawElements(E.TRIANGLES, t13.circleIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t13.circleIndexStart), e14.triangleCount += t13.circleIndexCount / 3);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLFill.js
var u2 = 1 / 65536;
var d4 = class extends t10 {
  constructor() {
    super(...arguments), this._fillProgramOptions = { id: false, pattern: false }, this._outlineProgramOptions = { id: false };
  }
  dispose() {
  }
  drawMany(t13, e14) {
    const { displayLevel: i8, drawPhase: r6, renderPass: l9, spriteMosaic: o10, styleLayerUID: s7 } = t13;
    let f5 = false;
    for (const n9 of e14)
      if (n9.layerData.has(s7)) {
        const t14 = n9.layerData.get(s7);
        if (t14.fillIndexCount > 0 || t14.outlineIndexCount > 0) {
          f5 = true;
          break;
        }
      }
    if (!f5)
      return;
    const u3 = t13.styleLayer, d6 = u3.getPaintProperty("fill-pattern"), c5 = void 0 !== d6, m2 = c5 && d6.isDataDriven;
    let p3;
    if (c5 && !m2) {
      const t14 = d6.getValue(i8);
      p3 = o10.getMosaicItemPosition(t14, true);
    }
    const y3 = !c5 && u3.getPaintValue("fill-antialias", i8);
    let g3 = true, _3 = 1;
    if (!c5) {
      const t14 = u3.getPaintProperty("fill-color"), e15 = u3.getPaintProperty("fill-opacity");
      if (!(t14 == null ? void 0 : t14.isDataDriven) && !(e15 == null ? void 0 : e15.isDataDriven)) {
        const t15 = u3.getPaintValue("fill-color", i8);
        _3 = u3.getPaintValue("fill-opacity", i8) * t15[3], _3 >= 1 && (g3 = false);
      }
    }
    if (g3 && "opaque" === l9)
      return;
    let E2;
    r6 === T.HITTEST && (E2 = M(s7 + 1));
    const v2 = u3.getPaintValue("fill-translate", i8), M3 = u3.getPaintValue("fill-translate-anchor", i8);
    (g3 || "translucent" !== l9) && this._drawFill(t13, s7, u3, e14, v2, M3, c5, p3, m2, E2);
    const P = !u3.hasDataDrivenOutlineColor && u3.outlineUsesFillColor && _3 < 1;
    y3 && "opaque" !== l9 && !P && this._drawOutline(t13, s7, u3, e14, v2, M3, E2);
  }
  _drawFill(a6, r6, d6, c5, m2, p3, y3, g3, _3, E2) {
    if (y3 && !_3 && null == g3)
      return;
    const { context: v2, displayLevel: M3, state: P, drawPhase: I2, painter: T3, pixelRatio: U, spriteMosaic: x, requestRender: D2, allowDelayedRender: h4 } = a6, S3 = d6.fillMaterial, R2 = T3.vectorTilesMaterialManager, w3 = U > te ? 2 : 1, N = I2 === T.HITTEST, L3 = this._fillProgramOptions;
    L3.id = N, L3.pattern = y3;
    const A = R2.getMaterialProgram(v2, S3, L3);
    if (h4 && null != D2 && !A.compiled)
      return void D2();
    if (v2.useProgram(A), null != g3) {
      const { page: t13 } = g3, i8 = x.getPageSize(t13);
      null != i8 && (x.bind(v2, L.LINEAR, t13, ee), A.setUniform2fv("u_mosaicSize", i8), A.setUniform1i("u_texture", ee));
    }
    A.setUniformMatrix3fv("u_displayMat3", p3 === r.VIEWPORT ? P.displayMat3 : P.displayViewMat3), A.setUniform2fv("u_fillTranslation", m2), A.setUniform1f("u_depth", d6.z + u2), N && A.setUniform4fv("u_id", E2);
    let V = -1;
    for (const t13 of c5) {
      if (!t13.layerData.has(r6))
        continue;
      t13.key.level !== V && (V = t13.key.level, S3.setDataUniforms(A, M3, d6, V, x));
      const i8 = t13.layerData.get(r6);
      if (!i8.fillIndexCount)
        continue;
      i8.prepareForRendering(v2);
      const n9 = i8.fillVAO;
      if (null != n9) {
        if (v2.bindVAO(n9), A.setUniformMatrix3fv("u_dvsMat3", t13.transforms.dvs), v2.setStencilFunction(I.EQUAL, t13.stencilRef, 255), y3) {
          const e14 = Math.max(2 ** (Math.round(M3) - t13.key.level), 1), i9 = t13.rangeX / (w3 * t13.width * e14);
          A.setUniform1f("u_patternFactor", i9);
        }
        if (_3) {
          const t14 = i8.patternMap;
          if (!t14)
            continue;
          for (const [i9, n10] of t14) {
            const t15 = x.getPageSize(i9);
            null != t15 && (x.bind(v2, L.LINEAR, i9, ee), A.setUniform2fv("u_mosaicSize", t15), A.setUniform1i("u_texture", ee), v2.drawElements(E.TRIANGLES, n10[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * n10[0]));
          }
        } else
          v2.drawElements(E.TRIANGLES, i8.fillIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * i8.fillIndexStart);
        t13.triangleCount += i8.fillIndexCount / 3;
      }
    }
  }
  _drawOutline(e14, i8, a6, r6, l9, d6, c5) {
    const { context: m2, displayLevel: p3, state: y3, drawPhase: g3, painter: _3, pixelRatio: E2, spriteMosaic: v2, requestRender: M3, allowDelayedRender: P } = e14, I2 = a6.outlineMaterial, T3 = _3.vectorTilesMaterialManager, U = 0.75 / E2, x = g3 === T.HITTEST, D2 = this._outlineProgramOptions;
    D2.id = x;
    const h4 = T3.getMaterialProgram(m2, I2, D2);
    if (P && null != M3 && !h4.compiled)
      return void M3();
    m2.useProgram(h4), h4.setUniformMatrix3fv("u_displayMat3", d6 === r.VIEWPORT ? y3.displayMat3 : y3.displayViewMat3), h4.setUniform2fv("u_fillTranslation", l9), h4.setUniform1f("u_depth", a6.z + u2), h4.setUniform1f("u_outline_width", U), x && h4.setUniform4fv("u_id", c5);
    let S3 = -1;
    for (const t13 of r6) {
      if (!t13.layerData.has(i8))
        continue;
      t13.key.level !== S3 && (S3 = t13.key.level, I2.setDataUniforms(h4, p3, a6, S3, v2));
      const e15 = t13.layerData.get(i8);
      if (e15.prepareForRendering(m2), !e15.outlineIndexCount)
        continue;
      const n9 = e15.outlineVAO;
      null != n9 && (m2.bindVAO(n9), h4.setUniformMatrix3fv("u_dvsMat3", t13.transforms.dvs), m2.setStencilFunction(I.EQUAL, t13.stencilRef, 255), m2.drawElements(E.TRIANGLES, e15.outlineIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * e15.outlineIndexStart), t13.triangleCount += e15.outlineIndexCount / 3);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLLine.js
var f3 = class extends t10 {
  constructor() {
    super(...arguments), this._programOptions = { id: false, pattern: false, sdf: false };
  }
  dispose() {
  }
  drawMany(a6, f5) {
    const { context: u3, displayLevel: m2, state: d6, drawPhase: c5, painter: p3, pixelRatio: g3, spriteMosaic: y3, styleLayerUID: E2, requestRender: v2, allowDelayedRender: M3 } = a6;
    if (!f5.some((e14) => {
      var _a;
      return ((_a = e14.layerData.get(E2)) == null ? void 0 : _a.lineIndexCount) ?? false;
    }))
      return;
    const _3 = a6.styleLayer, U = _3.lineMaterial, I2 = p3.vectorTilesMaterialManager, P = _3.getPaintValue("line-translate", m2), T3 = _3.getPaintValue("line-translate-anchor", m2), x = _3.getPaintProperty("line-pattern"), D2 = void 0 !== x, S3 = D2 && x.isDataDriven;
    let L3, N;
    if (D2 && !S3) {
      const e14 = x.getValue(m2);
      L3 = y3.getMosaicItemPosition(e14);
    }
    let R2 = false;
    if (!D2) {
      const e14 = _3.getPaintProperty("line-dasharray");
      if (N = void 0 !== e14, R2 = N && e14.isDataDriven, N && !R2) {
        const t13 = e14.getValue(m2), i8 = _3.getDashKey(t13, _3.getLayoutValue("line-cap", m2));
        L3 = y3.getMosaicItemPosition(i8);
      }
    }
    const V = 1 / g3, h4 = c5 === T.HITTEST, w3 = this._programOptions;
    w3.id = h4, w3.pattern = D2, w3.sdf = N;
    const A = I2.getMaterialProgram(u3, U, w3);
    if (M3 && null != v2 && !A.compiled)
      return void v2();
    if (u3.useProgram(A), A.setUniformMatrix3fv("u_displayViewMat3", d6.displayViewMat3), A.setUniformMatrix3fv("u_displayMat3", T3 === r.VIEWPORT ? d6.displayMat3 : d6.displayViewMat3), A.setUniform2fv("u_lineTranslation", P), A.setUniform1f("u_depth", _3.z), A.setUniform1f("u_antialiasing", V), h4) {
      const e14 = M(E2 + 1);
      A.setUniform4fv("u_id", e14);
    }
    if (L3 && null != L3) {
      const { page: e14 } = L3, i8 = y3.getPageSize(e14);
      null != i8 && (y3.bind(u3, L.LINEAR, e14, ee), A.setUniform2fv("u_mosaicSize", i8), A.setUniform1i("u_texture", ee));
    }
    let j5 = -1;
    for (const e14 of f5) {
      if (!e14.layerData.has(E2))
        continue;
      e14.key.level !== j5 && (j5 = e14.key.level, U.setDataUniforms(A, m2, _3, j5, y3));
      const i8 = 2 ** (m2 - j5) / g3;
      A.setUniform1f("u_zoomFactor", i8);
      const n9 = e14.layerData.get(E2);
      if (!n9.lineIndexCount)
        continue;
      n9.prepareForRendering(u3);
      const a7 = n9.vao;
      if (null != a7) {
        if (u3.bindVAO(a7), A.setUniformMatrix3fv("u_dvsMat3", e14.transforms.dvs), u3.setStencilFunction(I.EQUAL, e14.stencilRef, 255), S3 || R2) {
          const e15 = n9.patternMap;
          if (!e15)
            continue;
          for (const [i9, n10] of e15) {
            const e16 = y3.getPageSize(i9);
            null != e16 && (y3.bind(u3, L.LINEAR, i9, ee), A.setUniform2fv("u_mosaicSize", e16), A.setUniform1i("u_texture", ee), u3.drawElements(E.TRIANGLES, n10[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * n10[0]));
          }
        } else
          u3.drawElements(E.TRIANGLES, n9.lineIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * n9.lineIndexStart);
        e14.triangleCount += n9.lineIndexCount / 3;
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLSymbol.js
var y2 = 1 / 65536;
var _2 = class extends t10 {
  constructor() {
    super(...arguments), this._iconProgramOptions = { id: false, sdf: false }, this._sdfProgramOptions = { id: false }, this._spritesTextureSize = n2();
  }
  dispose() {
  }
  drawMany(e14, t13) {
    const { drawPhase: i8, styleLayerUID: a6 } = e14, r6 = e14.styleLayer;
    let n9;
    i8 === T.HITTEST && (n9 = M(a6 + 1)), this._drawIcons(e14, r6, t13, n9), this._drawText(e14, r6, t13, n9);
  }
  _drawIcons(e14, t13, o10, u3) {
    const { context: p3, displayLevel: c5, drawPhase: m2, painter: d6, spriteMosaic: g3, state: y3, styleLayerUID: _3, requestRender: h4, allowDelayedRender: M3 } = e14, P = t13.iconMaterial, T3 = d6.vectorTilesMaterialManager;
    let U, E2 = false;
    for (const i8 of o10)
      if (i8.layerData.has(_3) && (U = i8.layerData.get(_3), U.iconPerPageElementsMap.size > 0)) {
        E2 = true;
        break;
      }
    if (!E2)
      return;
    const v2 = t13.getPaintValue("icon-translate", c5), x = t13.getPaintValue("icon-translate-anchor", c5);
    let D2 = t13.getLayoutValue("icon-rotation-alignment", c5);
    D2 === l3.AUTO && (D2 = t13.getLayoutValue("symbol-placement", c5) === n3.POINT ? l3.VIEWPORT : l3.MAP);
    const I2 = D2 === l3.MAP, R2 = t13.getLayoutValue("icon-keep-upright", c5) && I2, S3 = U.isIconSDF, V = m2 === T.HITTEST, w3 = this._iconProgramOptions;
    w3.id = V, w3.sdf = S3;
    const A = T3.getMaterialProgram(p3, P, w3);
    if (M3 && null != h4 && !A.compiled)
      return void h4();
    p3.useProgram(A), A.setUniformMatrix3fv("u_displayViewMat3", D2 === l3.MAP ? y3.displayViewMat3 : y3.displayMat3), A.setUniformMatrix3fv("u_displayMat3", x === r.VIEWPORT ? y3.displayMat3 : y3.displayViewMat3), A.setUniform2fv("u_iconTranslation", v2), A.setUniform1f("u_depth", t13.z), A.setUniform1f("u_mapRotation", c2(y3.rotation)), A.setUniform1f("u_keepUpright", R2 ? 1 : 0), A.setUniform1f("u_level", 10 * c5), A.setUniform1i("u_texture", ee), A.setUniform1f("u_fadeDuration", e5 / 1e3), V && A.setUniform4fv("u_id", u3);
    let L3 = -1;
    for (const i8 of o10) {
      if (!i8.layerData.has(_3))
        continue;
      if (i8.key.level !== L3 && (L3 = i8.key.level, P.setDataUniforms(A, c5, t13, L3, g3)), U = i8.layerData.get(_3), 0 === U.iconPerPageElementsMap.size)
        continue;
      U.prepareForRendering(p3), U.updateOpacityInfo();
      const a6 = U.iconVAO;
      if (null != a6) {
        p3.bindVAO(a6), A.setUniformMatrix3fv("u_dvsMat3", i8.transforms.dvs), A.setUniform1f("u_time", (performance.now() - U.lastOpacityUpdate) / 1e3);
        for (const [t14, a7] of U.iconPerPageElementsMap)
          this._renderIconRange(e14, A, a7, t14, i8);
      }
    }
  }
  _renderIconRange(e14, t13, i8, a6, r6) {
    const { context: n9, spriteMosaic: o10 } = e14;
    this._spritesTextureSize[0] = o10.getWidth(a6) / 4, this._spritesTextureSize[1] = o10.getHeight(a6) / 4, t13.setUniform2fv("u_mosaicSize", this._spritesTextureSize), o10.bind(n9, L.LINEAR, a6, ee), n9.setStencilTestEnabled(true), n9.setStencilFunction(I.GREATER, 255, 255), n9.setStencilWriteMask(0), n9.drawElements(E.TRIANGLES, i8[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * i8[0]), r6.triangleCount += i8[1] / 3;
  }
  _drawText(e14, s7, u3, p3) {
    const { context: c5, displayLevel: d6, drawPhase: g3, glyphMosaic: _3, painter: h4, pixelRatio: M3, spriteMosaic: P, state: T3, styleLayerUID: U, requestRender: E2, allowDelayedRender: v2 } = e14, x = s7.textMaterial, D2 = h4.vectorTilesMaterialManager;
    let I2, R2 = false;
    for (const t13 of u3)
      if (t13.layerData.has(U) && (I2 = t13.layerData.get(U), I2.glyphPerPageElementsMap.size > 0)) {
        R2 = true;
        break;
      }
    if (!R2)
      return;
    const S3 = s7.getPaintProperty("text-opacity");
    if (S3 && !S3.isDataDriven && 0 === S3.getValue(d6))
      return;
    const V = s7.getPaintProperty("text-color"), w3 = !V || V.isDataDriven || V.getValue(d6)[3] > 0, A = s7.getPaintProperty("text-halo-width"), L3 = s7.getPaintProperty("text-halo-color"), O = (!A || A.isDataDriven || A.getValue(d6) > 0) && (!L3 || L3.isDataDriven || L3.getValue(d6)[3] > 0);
    if (!w3 && !O)
      return;
    const N = 24 / 8;
    let z = s7.getLayoutValue("text-rotation-alignment", d6);
    z === l3.AUTO && (z = s7.getLayoutValue("symbol-placement", d6) === n3.POINT ? l3.VIEWPORT : l3.MAP);
    const k2 = z === l3.MAP, b2 = s7.getLayoutValue("text-keep-upright", d6) && k2, G2 = g3 === T.HITTEST, j5 = 0.8 * N / M3;
    this._glyphTextureSize || (this._glyphTextureSize = t2(_3.width / 4, _3.height / 4));
    const W = s7.getPaintValue("text-translate", d6), F2 = s7.getPaintValue("text-translate-anchor", d6), B = this._sdfProgramOptions;
    B.id = G2;
    const H = D2.getMaterialProgram(c5, x, B);
    if (v2 && null != E2 && !H.compiled)
      return void E2();
    c5.useProgram(H), H.setUniformMatrix3fv("u_displayViewMat3", z === l3.MAP ? T3.displayViewMat3 : T3.displayMat3), H.setUniformMatrix3fv("u_displayMat3", F2 === r.VIEWPORT ? T3.displayMat3 : T3.displayViewMat3), H.setUniform2fv("u_textTranslation", W), H.setUniform1f("u_depth", s7.z + y2), H.setUniform2fv("u_mosaicSize", this._glyphTextureSize), H.setUniform1f("u_mapRotation", c2(T3.rotation)), H.setUniform1f("u_keepUpright", b2 ? 1 : 0), H.setUniform1f("u_level", 10 * d6), H.setUniform1i("u_texture", re), H.setUniform1f("u_antialiasingWidth", j5), H.setUniform1f("u_fadeDuration", e5 / 1e3), G2 && H.setUniform4fv("u_id", p3);
    let C3 = -1;
    for (const t13 of u3) {
      if (!t13.layerData.has(U))
        continue;
      if (t13.key.level !== C3 && (C3 = t13.key.level, x.setDataUniforms(H, d6, s7, C3, P)), I2 = t13.layerData.get(U), 0 === I2.glyphPerPageElementsMap.size)
        continue;
      I2.prepareForRendering(c5), I2.updateOpacityInfo();
      const e15 = I2.textVAO;
      if (null == e15)
        continue;
      c5.bindVAO(e15), H.setUniformMatrix3fv("u_dvsMat3", t13.transforms.dvs), c5.setStencilTestEnabled(true), c5.setStencilFunction(I.GREATER, 255, 255), c5.setStencilWriteMask(0);
      const i8 = (performance.now() - I2.lastOpacityUpdate) / 1e3;
      H.setUniform1f("u_time", i8), I2.glyphPerPageElementsMap.forEach((e16, i9) => {
        this._renderGlyphRange(c5, e16, i9, _3, H, O, w3, t13);
      });
    }
  }
  _renderGlyphRange(e14, t13, i8, a6, r6, n9, s7, l9) {
    a6.bind(e14, L.LINEAR, i8, re), n9 && (r6.setUniform1f("u_halo", 1), e14.drawElements(E.TRIANGLES, t13[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t13[0]), l9.triangleCount += t13[1] / 3), s7 && (r6.setUniform1f("u_halo", 0), e14.drawElements(E.TRIANGLES, t13[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t13[0]), l9.triangleCount += t13[1] / 3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vtlBrushes.js
var b = { vtlBackground: _, vtlFill: d4, vtlLine: f3, vtlCircle: o5, vtlSymbol: _2 };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e11 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/webgl/ShaderCompiler.js
var e12 = class {
  constructor(e14) {
    this._readFile = e14;
  }
  resolveIncludes(e14) {
    return this._resolve(e14);
  }
  _resolve(e14, t13 = /* @__PURE__ */ new Map()) {
    if (t13.has(e14))
      return t13.get(e14);
    const r6 = this._read(e14);
    if (!r6)
      throw new Error(`cannot find shader file ${e14}`);
    const s7 = /^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;
    let n9 = s7.exec(r6);
    const l9 = [];
    for (; null != n9; )
      l9.push({ path: n9[1], start: n9.index, length: n9[0].length }), n9 = s7.exec(r6);
    let a6 = 0, h4 = "";
    return l9.forEach((e15) => {
      h4 += r6.slice(a6, e15.start), h4 += t13.has(e15.path) ? "" : this._resolve(e15.path, t13), a6 = e15.start + e15.length;
    }), h4 += r6.slice(a6), t13.set(e14, h4), h4;
  }
  _read(e14) {
    return this._readFile(e14);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o6(e14) {
  let o10 = e11;
  return e14.split("/").forEach((r6) => {
    o10 && (o10 = o10[r6]);
  }), o10;
}
var t11 = new e12(o6);
function n6(r6) {
  return t11.resolveIncludes(r6);
}

// node_modules/@arcgis/core/views/webgl/programUtils.js
function e13(e14) {
  const { options: n9, value: o10 } = e14;
  return "number" == typeof n9[o10];
}
function n7(n9) {
  let o10 = "";
  for (const t13 in n9) {
    const i8 = n9[t13];
    if ("boolean" == typeof i8)
      i8 && (o10 += `#define ${t13}
`);
    else if ("number" == typeof i8)
      o10 += `#define ${t13} ${i8.toFixed()}
`;
    else if ("object" == typeof i8)
      if (e13(i8)) {
        const { value: e14, options: n10, namespace: f5 } = i8, s7 = f5 ? `${f5}_` : "";
        for (const t14 in n10)
          o10 += `#define ${s7}${t14} ${n10[t14].toFixed()}
`;
        o10 += `#define ${t13} ${s7}${e14}
`;
      } else {
        const e14 = i8.options;
        let n10 = 0;
        for (const t14 in e14)
          o10 += `#define ${e14[t14]} ${(n10++).toFixed()}
`;
        o10 += `#define ${t13} ${e14[i8.value]}
`;
      }
  }
  return o10;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t12 = (e14) => n7({ ID: e14.id, PATTERN: e14.pattern });
var a5 = { shaders: (r6) => ({ vertexShader: t12(r6) + n6("background/background.vert"), fragmentShader: t12(r6) + n6("background/background.frag") }) };
var d5 = (e14) => n7({ ID: e14.id });
var i7 = { shaders: (r6) => ({ vertexShader: d5(r6) + n6("circle/circle.vert"), fragmentShader: d5(r6) + n6("circle/circle.frag") }) };
var n8 = (e14) => n7({ ID: e14.id, PATTERN: e14.pattern });
var l7 = { shaders: (r6) => ({ vertexShader: n8(r6) + n6("fill/fill.vert"), fragmentShader: n8(r6) + n6("fill/fill.frag") }) };
var s6 = (e14) => n7({ ID: e14.id });
var f4 = { shaders: (r6) => ({ vertexShader: s6(r6) + n6("outline/outline.vert"), fragmentShader: s6(r6) + n6("outline/outline.frag") }) };
var h3 = (e14) => n7({ ID: e14.id, SDF: e14.sdf });
var o7 = { shaders: (r6) => ({ vertexShader: h3(r6) + n6("icon/icon.vert"), fragmentShader: h3(r6) + n6("icon/icon.frag") }) };
var g2 = (e14) => n7({ ID: e14.id, PATTERN: e14.pattern, SDF: e14.sdf });
var c4 = { shaders: (r6) => ({ vertexShader: g2(r6) + n6("line/line.vert"), fragmentShader: g2(r6) + n6("line/line.frag") }) };
var S = (e14) => n7({ ID: e14.id });
var v = { shaders: (r6) => ({ vertexShader: S(r6) + n6("text/text.vert"), fragmentShader: S(r6) + n6("text/text.frag") }) };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var o8 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e14) => e14.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e14, r6, t13) {
    const a6 = r6.key << 3 | this._getMaterialOptionsValue(r6.type, t13);
    if (this._programByKey.has(a6))
      return this._programByKey.get(a6);
    const s7 = this._getProgramTemplate(r6.type), { shaders: n9 } = s7, { vertexShader: c5, fragmentShader: i8 } = n9(t13), o10 = r6.getShaderHeader(), u3 = r6.getShaderMain(), p3 = c5.replace("#pragma header", o10).replace("#pragma main", u3), g3 = e14.programCache.acquire(p3, i8, r6.getAttributeLocations());
    return this._programByKey.set(a6, g3), g3;
  }
  _getMaterialOptionsValue(r6, t13) {
    switch (r6) {
      case L2.BACKGROUND: {
        const e14 = t13;
        return (e14.pattern ? 1 : 0) << 1 | (e14.id ? 1 : 0);
      }
      case L2.FILL: {
        const e14 = t13;
        return (e14.pattern ? 1 : 0) << 1 | (e14.id ? 1 : 0);
      }
      case L2.OUTLINE:
        return t13.id ? 1 : 0;
      case L2.LINE: {
        const e14 = t13;
        return (e14.sdf ? 1 : 0) << 2 | (e14.pattern ? 1 : 0) << 1 | (e14.id ? 1 : 0);
      }
      case L2.ICON: {
        const e14 = t13;
        return (e14.sdf ? 1 : 0) << 1 | (e14.id ? 1 : 0);
      }
      case L2.CIRCLE:
        return t13.id ? 1 : 0;
      case L2.TEXT:
        return t13.id ? 1 : 0;
      default:
        return 0;
    }
  }
  _getProgramTemplate(o10) {
    switch (o10) {
      case L2.BACKGROUND:
        return a5;
      case L2.CIRCLE:
        return i7;
      case L2.FILL:
        return l7;
      case L2.ICON:
        return o7;
      case L2.LINE:
        return c4;
      case L2.OUTLINE:
        return f4;
      case L2.TEXT:
        return v;
      default:
        return null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VTLPainter3D.js
var l8 = 1e-6;
var o9 = class {
  constructor(e14, t13) {
    this.spriteMosaic = e14, this.glyphMosaic = t13, this._brushCache = /* @__PURE__ */ new Map(), this._vtlMaterialManager = new o8();
  }
  dispose() {
    this._brushCache && (this._brushCache.forEach((e14) => e14.dispose()), this._brushCache = null), this._vtlMaterialManager = t(this._vtlMaterialManager), this.spriteMosaic.dispose(), this.glyphMosaic.dispose();
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  drawTile(e14, t13, r6, s7) {
    const { context: a6 } = e14, l9 = r6.layers;
    r6.backgroundBucketIds.length > 0 && (e14.renderPass = "background", r6.backgroundBucketIds.forEach((a7) => {
      const n9 = r6.getLayerById(a7);
      null != s7 && s7 !== n9.type || this._renderStyleLayer(n9, e14, t13, true);
    })), a6.setBlendingEnabled(false), a6.setDepthTestEnabled(true), a6.setDepthWriteEnabled(true), a6.setDepthFunction(I.LEQUAL), e14.renderPass = "opaque";
    for (let n9 = l9.length - 1; n9 >= 0; n9--) {
      const r7 = l9[n9];
      null != s7 && s7 !== r7.type || this._renderStyleLayer(r7, e14, t13, false);
    }
    a6.setDepthWriteEnabled(false), a6.setBlendingEnabled(true), a6.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e14.renderPass = "translucent";
    for (let n9 = 0; n9 < l9.length; n9++) {
      const r7 = l9[n9];
      null != s7 && s7 !== r7.type || this._renderStyleLayer(r7, e14, t13, false);
    }
    a6.setDepthTestEnabled(false), a6.bindVAO();
  }
  _renderStyleLayer(e14, t13, r6, n9) {
    if (!(n9 || e14 && r6.layerData.has(e14.uid)))
      return;
    const i8 = e14.getLayoutProperty("visibility");
    if (i8 && i8.getValue() === i2.NONE)
      return;
    const { renderPass: o10 } = t13;
    let h4;
    switch (e14.type) {
      case a3.BACKGROUND:
        if ("background" !== o10)
          return;
        h4 = "vtlBackground";
        break;
      case a3.FILL:
        if ("opaque" !== o10 && "translucent" !== t13.renderPass)
          return;
        h4 = "vtlFill";
        break;
      case a3.LINE:
        if ("translucent" !== o10)
          return;
        h4 = "vtlLine";
        break;
      case a3.CIRCLE:
        if ("translucent" !== o10)
          return;
        h4 = "vtlCircle";
        break;
      case a3.SYMBOL:
        if ("translucent" !== o10)
          return;
        h4 = "vtlSymbol";
    }
    const c5 = t13.displayLevel;
    void 0 !== e14.minzoom && e14.minzoom > c5 + l8 || void 0 !== e14.maxzoom && e14.maxzoom <= c5 - l8 || (t13.styleLayerUID = e14.uid, t13.styleLayer = e14, this._drawWithBrush(t13, r6, h4));
  }
  _drawWithBrush(e14, r6, s7) {
    if (!this._brushCache.has(s7)) {
      const e15 = b[s7];
      this._brushCache.set(s7, new e15());
    }
    this._brushCache.get(s7).drawMany(e14, [r6]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/VectorTileLayerView3D.js
var C2 = class extends o(n4(d2)) {
  constructor() {
    super(...arguments), this._tileHandlerController = null, this.type = "vector-tile-3d", this.levelShift = has("disable-feature:vtl-level-shift") ? 0 : 1, this.contentZoom = has("disable-feature:vtl-level-shift") ? 1 : 1.5;
  }
  initialize() {
    if (null == this.layer.fullExtent)
      return void this.addResolvingPromise(Promise.reject(new s("vectortilelayerview:full-extent-undefined", "This layer view's layer does not define a fullExtent.")));
    const { basemapTerrain: e14, spatialReference: i8, state: l9, viewingMode: r6 } = this.view, h4 = "local" === r6 && !M2(i8) || k.force512VTL, c5 = this.layer.tileInfo.spatialReference.isGeographic, y3 = h4 ? this.layer.tileInfo : this.layer.tileInfo.getOrCreateCompatible(256, c5 ? 1 : 2), g3 = this._getTileInfoSupportError(y3, this.layer.fullExtent);
    if (null != g3)
      return this.addResolvingPromise(Promise.reject(g3));
    const _3 = j2(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
    }).then(() => {
      var _a, _b, _c;
      const t13 = e14.tilingScheme, i9 = t13.pixelSize, l10 = 256 === i9 ? 1 : 2, r7 = ((_a = e14.spatialReference) == null ? void 0 : _a.isGeographic) && 256 === i9 ? 1 : 0, s7 = ((_b = e14.spatialReference) == null ? void 0 : _b.isGeographic) || 256 !== i9 ? 0 : 1;
      let o10;
      if (this.schemaHelper = new t6(l10, r7, this.levelShift + s7), 256 === i9) {
        const e15 = this.layer.tileInfo.spatialReference.isGeographic;
        o10 = this.layer.tileInfo.getOrCreateCompatible(256, e15 ? 1 : 2);
      } else
        o10 = ((_c = this.view.spatialReference) == null ? void 0 : _c.isGeographic) ? this.layer.tileInfo.getOrCreateCompatible(512, 0.5) : this.layer.tileInfo;
      const a6 = this._getTileInfoCompatibilityError(o10, t13);
      if (a6)
        throw a6;
      this.tileInfo = o10;
    });
    this._tileHandlerController = new AbortController();
    const C3 = this.view.resourceController;
    this._memCache = C3.memoryController.newCache(`vtl-${this.layer.uid}`, (e15) => {
      e15.release();
    }), this.handles.add(l2(() => this.view.qualitySettings.memoryLimit, (e15) => this._memCache.maxSize = Math.ceil(e15 / 10 * 1048576), w));
    const S3 = new l4(this.layer.currentStyleInfo.style);
    this._tileHandler = new g(this.layer, S3, l9.contentPixelRatio, this._memCache);
    const H = this._tileHandlerController.signal, R2 = w2(C3), j5 = this._tileHandler.start({ signal: H, schedule: R2 }), x = this._tileHandler.spriteMosaic;
    x.then((e15) => {
      !a2(H) && this._tileHandler && (this.painter = new o9(e15, this._tileHandler.glyphMosaic));
    }), j5.then(() => this._tileHandlerController = null), this.updatingHandles.add(() => {
      var _a;
      return { style: this.layer.currentStyleInfo.style, pixelRatio: (_a = this.view.state) == null ? void 0 : _a.contentPixelRatio };
    }, ({ style: e15, pixelRatio: t13 }) => {
      this._tileHandlerController && this._tileHandlerController.abort(), this._tileHandlerController = new AbortController(), this._memCache.clear();
      const i9 = new l4(e15), l10 = new g(this.layer, i9, t13, this._memCache), r7 = l10.start({ signal: this._tileHandlerController.signal, schedule: R2 }), s7 = l10.spriteMosaic;
      r7.then(() => this._tileHandlerController = null), this.updatingHandles.addPromise(Promise.all([r7, s7]).then(([, e16]) => {
        const t14 = this._tileHandler, i10 = this.painter;
        this.painter = new o9(e16, l10.glyphMosaic), this._tileHandler = l10, this.emit("data-changed"), t14.destroy(), i10 && i10.dispose();
      }));
    });
    const L3 = Promise.all([_3, j5, x]);
    this.addResolvingPromise(L3);
  }
  destroy() {
    this.painter = t(this.painter), this._tileHandlerController = e2(this._tileHandlerController), this._tileHandler = l(this._tileHandler), this._memCache = l(this._memCache);
  }
  get displayLevelRange() {
    const e14 = this.tileInfo.lods, t13 = this.layer.minScale || e14[0].scale, i8 = this.layer.maxScale || e14[e14.length - 1].scale, l9 = this.levelRangeFromScaleRange(t13, i8);
    return this.layer.maxScale ? l9.maxLevel++ : l9.maxLevel += this.levelShift, l9;
  }
  get dataScaleRange() {
    const e14 = this.tileInfo.lods;
    return { minScale: e14[0].scale, maxScale: e14[e14.length - 1].scale };
  }
  get dataLevelRange() {
    const { minScale: e14, maxScale: t13 } = this.dataScaleRange, i8 = this.levelRangeFromScaleRange(e14, t13);
    return 1 === i8.minLevel && 256 === this.tileInfo.size[0] && (i8.minLevel = 0), i8.maxLevel += this.levelShift, i8;
  }
  async fetchTile(e14, t13, i8, l9) {
    return this._tileHandler.getVectorTile(e14, t13, i8, l9);
  }
};
e([y()], C2.prototype, "layer", void 0), e([y()], C2.prototype, "levelShift", void 0), e([y()], C2.prototype, "contentZoom", void 0), e([y()], C2.prototype, "displayLevelRange", null), e([y()], C2.prototype, "tileInfo", void 0), e([y()], C2.prototype, "dataScaleRange", null), e([y()], C2.prototype, "dataLevelRange", null), e([y()], C2.prototype, "updatingProgressValue", void 0), C2 = e([a("esri.views.3d.layers.VectorTileLayerView3D")], C2);
var S2 = C2;
function w2(e14) {
  return (t13) => e14.immediate.schedule(t13);
}
export {
  S2 as default
};
//# sourceMappingURL=VectorTileLayerView3D-JBZWKQ2Y.js.map
