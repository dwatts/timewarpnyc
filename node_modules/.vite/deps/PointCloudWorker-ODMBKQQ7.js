import {
  c,
  f as f2,
  i,
  u
} from "./chunk-BJVNCU4L.js";
import "./chunk-SQUWJDUL.js";
import "./chunk-XKENZ7D5.js";
import {
  e
} from "./chunk-XY26YCFX.js";
import {
  n as n2,
  r
} from "./chunk-3TTW7E7W.js";
import {
  S
} from "./chunk-OKABUMQT.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-NHHKW3WR.js";
import {
  yn
} from "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-W3WHCGIQ.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import {
  E
} from "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import {
  f
} from "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import "./chunk-453UIKKW.js";
import "./chunk-5BLDWPLW.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import "./chunk-UYRCWUYQ.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R,
  n2 as n
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorker.js
var c2 = class {
  transform(t) {
    const e2 = this._transform(t), a = [e2.points.buffer, e2.rgb.buffer];
    null != e2.pointIdFilterMap && a.push(e2.pointIdFilterMap.buffer);
    for (const o of e2.attributes)
      "buffer" in o.values && n(o.values.buffer) && o.values.buffer !== e2.rgb.buffer && a.push(o.values.buffer);
    return Promise.resolve({ result: e2, transferList: a });
  }
  _transform(r2) {
    const e2 = u(r2.schema, r2.geometryBuffer);
    let a = e2.length / 3, o = null;
    const n3 = new Array(), f3 = c(r2.primaryAttributeData, e2, a);
    null != r2.primaryAttributeData && f3 && n3.push({ attributeInfo: r2.primaryAttributeData.attributeInfo, values: f3 });
    const i2 = c(r2.modulationAttributeData, e2, a);
    null != r2.modulationAttributeData && i2 && n3.push({ attributeInfo: r2.modulationAttributeData.attributeInfo, values: i2 });
    let c3 = i(r2.rendererInfo, f3, i2, a);
    if (r2.filterInfo && r2.filterInfo.length > 0 && null != r2.filterAttributesData) {
      const f4 = r2.filterAttributesData.filter(R).map((t) => {
        const r3 = c(t, e2, a), o2 = { attributeInfo: t.attributeInfo, values: r3 };
        return n3.push(o2), o2;
      });
      o = new Uint32Array(a), a = f2(e2, c3, o, r2.filterInfo, f4);
    }
    for (const t of r2.userAttributesData) {
      const r3 = c(t, e2, a);
      n3.push({ attributeInfo: t.attributeInfo, values: r3 });
    }
    3 * a < c3.length && (c3 = new Uint8Array(c3.buffer.slice(0, 3 * a))), this._applyElevationOffsetInPlace(e2, a, r2.elevationOffset);
    const p2 = this._transformCoordinates(e2, a, r2.obb, f.fromJSON(r2.inSR), f.fromJSON(r2.outSR));
    return { obb: r2.obb, points: p2, rgb: c3, attributes: n3, pointIdFilterMap: o };
  }
  _transformCoordinates(t, r2, a, s, u2) {
    if (!yn(t, s, 0, t, u2, 0, r2))
      throw new Error("Can't reproject");
    const l = r(a.center[0], a.center[1], a.center[2]), b = n2(), m = n2();
    S(p, a.quaternion);
    const c3 = new Float32Array(3 * r2);
    for (let e2 = 0; e2 < r2; e2++)
      b[0] = t[3 * e2] - l[0], b[1] = t[3 * e2 + 1] - l[1], b[2] = t[3 * e2 + 2] - l[2], E(m, b, p), a.halfSize[0] = Math.max(a.halfSize[0], Math.abs(m[0])), a.halfSize[1] = Math.max(a.halfSize[1], Math.abs(m[1])), a.halfSize[2] = Math.max(a.halfSize[2], Math.abs(m[2])), c3[3 * e2] = b[0], c3[3 * e2 + 1] = b[1], c3[3 * e2 + 2] = b[2];
    return c3;
  }
  _applyElevationOffsetInPlace(t, r2, e2) {
    if (0 !== e2)
      for (let a = 0; a < r2; a++)
        t[3 * a + 2] += e2;
  }
};
var p = e();
function h() {
  return new c2();
}
export {
  h as default
};
//# sourceMappingURL=PointCloudWorker-ODMBKQQ7.js.map
