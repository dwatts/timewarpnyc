import {
  t as t3
} from "./chunk-PM77FW2O.js";
import {
  T
} from "./chunk-AHKW4ZTY.js";
import {
  t as t2
} from "./chunk-RRRAGAMB.js";
import {
  f
} from "./chunk-GZTLZ6RD.js";
import {
  c
} from "./chunk-YAWND7HF.js";
import {
  st
} from "./chunk-ICEO3WMK.js";
import {
  t
} from "./chunk-M5UHI5WR.js";
import {
  a,
  s as s2
} from "./chunk-VYG5A4VI.js";
import {
  d,
  i
} from "./chunk-CNS4YGGN.js";
import {
  n as n2
} from "./chunk-UHAU5IXU.js";
import {
  p
} from "./chunk-BAMKEIAF.js";
import {
  n
} from "./chunk-J2V5CZSS.js";
import {
  u
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/chunks/rbush.js
function i2(t5, n4) {
  if (!(this instanceof i2))
    return new i2(t5, n4);
  this._maxEntries = Math.max(4, t5 || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), n4 && ("function" == typeof n4 ? this.toBBox = n4 : this._initFormat(n4)), this.clear();
}
function n3(t5, i3, n4) {
  if (!n4)
    return i3.indexOf(t5);
  for (var h4 = 0; h4 < i3.length; h4++)
    if (n4(t5, i3[h4]))
      return h4;
  return -1;
}
function h(t5, i3) {
  a2(t5, 0, t5.children.length, i3, t5);
}
function a2(t5, i3, n4, h4, a4) {
  a4 || (a4 = x(null)), a4.minX = 1 / 0, a4.minY = 1 / 0, a4.maxX = -1 / 0, a4.maxY = -1 / 0;
  for (var e2, o3 = i3; o3 < n4; o3++)
    e2 = t5.children[o3], r(a4, t5.leaf ? h4(e2) : e2);
  return a4;
}
function r(t5, i3) {
  return t5.minX = Math.min(t5.minX, i3.minX), t5.minY = Math.min(t5.minY, i3.minY), t5.maxX = Math.max(t5.maxX, i3.maxX), t5.maxY = Math.max(t5.maxY, i3.maxY), t5;
}
function e(t5, i3) {
  return t5.minX - i3.minX;
}
function o(t5, i3) {
  return t5.minY - i3.minY;
}
function s3(t5) {
  return (t5.maxX - t5.minX) * (t5.maxY - t5.minY);
}
function l(t5) {
  return t5.maxX - t5.minX + (t5.maxY - t5.minY);
}
function m(t5, i3) {
  return (Math.max(i3.maxX, t5.maxX) - Math.min(i3.minX, t5.minX)) * (Math.max(i3.maxY, t5.maxY) - Math.min(i3.minY, t5.minY));
}
function c2(t5, i3) {
  var n4 = Math.max(t5.minX, i3.minX), h4 = Math.max(t5.minY, i3.minY), a4 = Math.min(t5.maxX, i3.maxX), r4 = Math.min(t5.maxY, i3.maxY);
  return Math.max(0, a4 - n4) * Math.max(0, r4 - h4);
}
function u2(t5, i3) {
  return t5.minX <= i3.minX && t5.minY <= i3.minY && i3.maxX <= t5.maxX && i3.maxY <= t5.maxY;
}
function f2(t5, i3) {
  return i3.minX <= t5.maxX && i3.minY <= t5.maxY && i3.maxX >= t5.minX && i3.maxY >= t5.minY;
}
function x(t5) {
  return { children: t5, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function d2(i3, n4, h4, a4, r4) {
  for (var e2, o3 = [n4, h4]; o3.length; )
    (h4 = o3.pop()) - (n4 = o3.pop()) <= a4 || (e2 = n4 + Math.ceil((h4 - n4) / a4 / 2) * a4, f(i3, e2, n4, h4, r4), o3.push(n4, e2, e2, h4));
}
i2.prototype = { all: function() {
  return this._all(this.data, []);
}, search: function(t5) {
  var i3 = this.data, n4 = [], h4 = this.toBBox;
  if (!f2(t5, i3))
    return n4;
  for (var a4, r4, e2, o3, s4 = []; i3; ) {
    for (a4 = 0, r4 = i3.children.length; a4 < r4; a4++)
      e2 = i3.children[a4], f2(t5, o3 = i3.leaf ? h4(e2) : e2) && (i3.leaf ? n4.push(e2) : u2(t5, o3) ? this._all(e2, n4) : s4.push(e2));
    i3 = s4.pop();
  }
  return n4;
}, collides: function(t5) {
  var i3 = this.data, n4 = this.toBBox;
  if (!f2(t5, i3))
    return false;
  for (var h4, a4, r4, e2, o3 = []; i3; ) {
    for (h4 = 0, a4 = i3.children.length; h4 < a4; h4++)
      if (r4 = i3.children[h4], f2(t5, e2 = i3.leaf ? n4(r4) : r4)) {
        if (i3.leaf || u2(t5, e2))
          return true;
        o3.push(r4);
      }
    i3 = o3.pop();
  }
  return false;
}, load: function(t5) {
  if (!t5 || !t5.length)
    return this;
  if (t5.length < this._minEntries) {
    for (var i3 = 0, n4 = t5.length; i3 < n4; i3++)
      this.insert(t5[i3]);
    return this;
  }
  var h4 = this._build(t5.slice(), 0, t5.length - 1, 0);
  if (this.data.children.length)
    if (this.data.height === h4.height)
      this._splitRoot(this.data, h4);
    else {
      if (this.data.height < h4.height) {
        var a4 = this.data;
        this.data = h4, h4 = a4;
      }
      this._insert(h4, this.data.height - h4.height - 1, true);
    }
  else
    this.data = h4;
  return this;
}, insert: function(t5) {
  return t5 && this._insert(t5, this.data.height - 1), this;
}, clear: function() {
  return this.data = x([]), this;
}, remove: function(t5, i3) {
  if (!t5)
    return this;
  for (var h4, a4, r4, e2, o3 = this.data, s4 = this.toBBox(t5), l3 = [], m3 = []; o3 || l3.length; ) {
    if (o3 || (o3 = l3.pop(), a4 = l3[l3.length - 1], h4 = m3.pop(), e2 = true), o3.leaf && -1 !== (r4 = n3(t5, o3.children, i3)))
      return o3.children.splice(r4, 1), l3.push(o3), this._condense(l3), this;
    e2 || o3.leaf || !u2(o3, s4) ? a4 ? (h4++, o3 = a4.children[h4], e2 = false) : o3 = null : (l3.push(o3), m3.push(h4), h4 = 0, a4 = o3, o3 = o3.children[0]);
  }
  return this;
}, toBBox: function(t5) {
  return t5;
}, compareMinX: e, compareMinY: o, toJSON: function() {
  return this.data;
}, fromJSON: function(t5) {
  return this.data = t5, this;
}, _all: function(t5, i3) {
  for (var n4 = []; t5; )
    t5.leaf ? i3.push.apply(i3, t5.children) : n4.push.apply(n4, t5.children), t5 = n4.pop();
  return i3;
}, _build: function(t5, i3, n4, a4) {
  var r4, e2 = n4 - i3 + 1, o3 = this._maxEntries;
  if (e2 <= o3)
    return h(r4 = x(t5.slice(i3, n4 + 1)), this.toBBox), r4;
  a4 || (a4 = Math.ceil(Math.log(e2) / Math.log(o3)), o3 = Math.ceil(e2 / Math.pow(o3, a4 - 1))), (r4 = x([])).leaf = false, r4.height = a4;
  var s4, l3, m3, c5, u5 = Math.ceil(e2 / o3), f4 = u5 * Math.ceil(Math.sqrt(o3));
  for (d2(t5, i3, n4, f4, this.compareMinX), s4 = i3; s4 <= n4; s4 += f4)
    for (d2(t5, s4, m3 = Math.min(s4 + f4 - 1, n4), u5, this.compareMinY), l3 = s4; l3 <= m3; l3 += u5)
      c5 = Math.min(l3 + u5 - 1, m3), r4.children.push(this._build(t5, l3, c5, a4 - 1));
  return h(r4, this.toBBox), r4;
}, _chooseSubtree: function(t5, i3, n4, h4) {
  for (var a4, r4, e2, o3, l3, c5, u5, f4; h4.push(i3), !i3.leaf && h4.length - 1 !== n4; ) {
    for (u5 = f4 = 1 / 0, a4 = 0, r4 = i3.children.length; a4 < r4; a4++)
      l3 = s3(e2 = i3.children[a4]), (c5 = m(t5, e2) - l3) < f4 ? (f4 = c5, u5 = l3 < u5 ? l3 : u5, o3 = e2) : c5 === f4 && l3 < u5 && (u5 = l3, o3 = e2);
    i3 = o3 || i3.children[0];
  }
  return i3;
}, _insert: function(t5, i3, n4) {
  var h4 = this.toBBox, a4 = n4 ? t5 : h4(t5), e2 = [], o3 = this._chooseSubtree(a4, this.data, i3, e2);
  for (o3.children.push(t5), r(o3, a4); i3 >= 0 && e2[i3].children.length > this._maxEntries; )
    this._split(e2, i3), i3--;
  this._adjustParentBBoxes(a4, e2, i3);
}, _split: function(t5, i3) {
  var n4 = t5[i3], a4 = n4.children.length, r4 = this._minEntries;
  this._chooseSplitAxis(n4, r4, a4);
  var e2 = this._chooseSplitIndex(n4, r4, a4), o3 = x(n4.children.splice(e2, n4.children.length - e2));
  o3.height = n4.height, o3.leaf = n4.leaf, h(n4, this.toBBox), h(o3, this.toBBox), i3 ? t5[i3 - 1].children.push(o3) : this._splitRoot(n4, o3);
}, _splitRoot: function(t5, i3) {
  this.data = x([t5, i3]), this.data.height = t5.height + 1, this.data.leaf = false, h(this.data, this.toBBox);
}, _chooseSplitIndex: function(t5, i3, n4) {
  var h4, r4, e2, o3, l3, m3, u5, f4;
  for (m3 = u5 = 1 / 0, h4 = i3; h4 <= n4 - i3; h4++)
    o3 = c2(r4 = a2(t5, 0, h4, this.toBBox), e2 = a2(t5, h4, n4, this.toBBox)), l3 = s3(r4) + s3(e2), o3 < m3 ? (m3 = o3, f4 = h4, u5 = l3 < u5 ? l3 : u5) : o3 === m3 && l3 < u5 && (u5 = l3, f4 = h4);
  return f4;
}, _chooseSplitAxis: function(t5, i3, n4) {
  var h4 = t5.leaf ? this.compareMinX : e, a4 = t5.leaf ? this.compareMinY : o;
  this._allDistMargin(t5, i3, n4, h4) < this._allDistMargin(t5, i3, n4, a4) && t5.children.sort(h4);
}, _allDistMargin: function(t5, i3, n4, h4) {
  t5.children.sort(h4);
  var e2, o3, s4 = this.toBBox, m3 = a2(t5, 0, i3, s4), c5 = a2(t5, n4 - i3, n4, s4), u5 = l(m3) + l(c5);
  for (e2 = i3; e2 < n4 - i3; e2++)
    o3 = t5.children[e2], r(m3, t5.leaf ? s4(o3) : o3), u5 += l(m3);
  for (e2 = n4 - i3 - 1; e2 >= i3; e2--)
    o3 = t5.children[e2], r(c5, t5.leaf ? s4(o3) : o3), u5 += l(c5);
  return u5;
}, _adjustParentBBoxes: function(t5, i3, n4) {
  for (var h4 = n4; h4 >= 0; h4--)
    r(i3[h4], t5);
}, _condense: function(t5) {
  for (var i3, n4 = t5.length - 1; n4 >= 0; n4--)
    0 === t5[n4].children.length ? n4 > 0 ? (i3 = t5[n4 - 1].children).splice(i3.indexOf(t5[n4]), 1) : this.clear() : h(t5[n4], this.toBBox);
}, _initFormat: function(t5) {
  var i3 = ["return a", " - b", ";"];
  this.compareMinX = new Function("a", "b", i3.join(t5[0])), this.compareMinY = new Function("a", "b", i3.join(t5[1])), this.toBBox = new Function("a", "return {minX: a" + t5[0] + ", minY: a" + t5[1] + ", maxX: a" + t5[2] + ", maxY: a" + t5[3] + "};");
} };

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithCursor.js
function r2(r4, a4, t5) {
  if (null == r4)
    return null;
  const u5 = a4.readArcadeFeature();
  try {
    return r4.evaluate({ ...t5, $feature: u5 }, r4.services);
  } catch (n4) {
    return s.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", n4), null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/Store2D.js
var a3 = class {
  constructor(e2, s4) {
    this._canCacheExpressionValue = false, this._sourceInfo = e2, this._storage = s4, this._bitsets = { computed: s4.getBitset(s4.createBitset()) };
  }
  get storage() {
    return this._storage;
  }
  invalidate() {
    this._bitsets.computed.clear();
  }
  async updateSchema(t5, i3) {
    const a4 = a(this._schema, i3);
    if (this._schema = i3, !i3 || null == a4 || !s2(a4, "attributes"))
      return;
    has("esri-2d-update-debug") && console.debug("Applying Update - Store:", a4), this._bitsets.computed.clear(), t5.targets[i3.name] = true;
    const r4 = i3.attributes, o3 = [], c5 = [];
    for (const e2 in r4) {
      const s4 = r4[e2];
      switch (s4.type) {
        case "field":
          break;
        case "expression":
          o3.push(this._createArcadeComputedField(s4));
          break;
        case "label-expression":
          o3.push(this._createLabelArcadeComputedField(s4));
          break;
        case "statistic":
          c5.push(s4);
      }
    }
    this._computedFields = await Promise.all(o3), this._canCacheExpressionValue = !this._computedFields.some((e2) => "expression" === e2.type && null != e2.expression && e2.expression.referencesScale()), this._statisticFields = c5;
  }
  setComputedAttributes(e2, s4, t5, i3) {
    const a4 = this._bitsets.computed;
    if (!this._canCacheExpressionValue || !a4.has(t5)) {
      a4.set(t5);
      for (const a5 of this._computedFields) {
        const r4 = this._evaluateField(s4, a5, i3);
        switch (a5.resultType) {
          case "numeric":
            e2.setComputedNumericAtIndex(t5, a5.fieldIndex, r4);
            break;
          case "string":
            e2.setComputedStringAtIndex(t5, a5.fieldIndex, r4);
        }
      }
    }
  }
  async _createArcadeComputedField(e2) {
    const s4 = this._sourceInfo.spatialReference, i3 = this._sourceInfo.fieldsIndex;
    return { ...e2, expression: await n2(e2.valueExpression, s4, i3) };
  }
  async _createLabelArcadeComputedField(e2) {
    const s4 = this._sourceInfo.spatialReference, t5 = this._sourceInfo.fieldsIndex, { createLabelFunction: i3 } = await import("./labelFormatUtils-I5XQL5II.js"), a4 = await i3(e2.label, t5, s4);
    return { ...e2, builder: a4 };
  }
  _evaluateField(e2, s4, t5) {
    switch (s4.type) {
      case "label-expression": {
        const t6 = e2.readArcadeFeature();
        return s4.builder.evaluate(t6) || "";
      }
      case "expression": {
        const { expression: a4 } = s4;
        return r2(a4, e2, { $view: { scale: t5 } });
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t4 = class _t {
  static fromBuffer(e2, s4) {
    return new _t(e2, s4);
  }
  static create(e2, s4 = 4294967295) {
    const r4 = new Uint32Array(Math.ceil(e2 / 32));
    return new _t(r4, s4);
  }
  constructor(t5, e2) {
    this._mask = 0, this._buf = t5, this._mask = e2;
  }
  _getIndex(t5) {
    return Math.floor(t5 / 32);
  }
  has(t5) {
    const e2 = this._mask & t5;
    return !!(this._buf[this._getIndex(e2)] & 1 << e2 % 32);
  }
  hasRange(t5, e2) {
    let s4 = t5, r4 = e2;
    for (; s4 % 32 && s4 !== r4; ) {
      if (this.has(s4))
        return true;
      s4++;
    }
    for (; r4 % 32 && s4 !== r4; ) {
      if (this.has(s4))
        return true;
      r4--;
    }
    if (s4 === r4)
      return false;
    for (let h4 = s4 / 32; h4 !== r4 / 32; h4++) {
      if (this._buf[h4])
        return true;
    }
    return false;
  }
  set(t5) {
    const e2 = this._mask & t5, s4 = this._getIndex(e2), r4 = 1 << e2 % 32;
    this._buf[s4] |= r4;
  }
  setRange(t5, e2) {
    let s4 = t5, r4 = e2;
    for (; s4 % 32 && s4 !== r4; )
      this.set(s4++);
    for (; r4 % 32 && s4 !== r4; )
      this.set(r4--);
    if (s4 !== r4)
      for (let h4 = s4 / 32; h4 !== r4 / 32; h4++)
        this._buf[h4] = 4294967295;
  }
  unset(t5) {
    const e2 = this._mask & t5, s4 = this._getIndex(e2), r4 = 1 << e2 % 32;
    this._buf[s4] &= 4294967295 ^ r4;
  }
  resize(t5) {
    const e2 = this._buf, s4 = new Uint32Array(Math.ceil(t5 / 32));
    s4.set(e2), this._buf = s4;
  }
  or(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] |= t5._buf[e2];
    return this;
  }
  and(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] &= t5._buf[e2];
    return this;
  }
  xor(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] ^= t5._buf[e2];
    return this;
  }
  ior(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] |= ~t5._buf[e2];
    return this;
  }
  iand(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] &= ~t5._buf[e2];
    return this;
  }
  ixor(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] ^= ~t5._buf[e2];
    return this;
  }
  any() {
    for (let t5 = 0; t5 < this._buf.length; t5++)
      if (this._buf[t5])
        return true;
    return false;
  }
  copy(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] = t5._buf[e2];
    return this;
  }
  clone() {
    return new _t(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t5 = 0; t5 < this._buf.length; t5++)
      this._buf[t5] = 0;
  }
  forEachSet(t5) {
    for (let e2 = 0; e2 < this._buf.length; e2++) {
      let s4 = this._buf[e2], r4 = 32 * e2;
      if (s4)
        for (; s4; ) {
          1 & s4 && t5(r4), s4 >>>= 1, r4++;
        }
    }
  }
  countSet() {
    let t5 = 0;
    return this.forEachSet((e2) => {
      t5++;
    }), t5;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var d3 = 0;
var h2 = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var u3 = h2[0];
var l2 = h2[1];
var c3 = h2[2];
var m2 = h2[3];
var f3 = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var g = f3[0];
var y = f3[1];
var _ = f3[2];
var p2 = has("featurelayer-simplify-mobile-factor") ?? 2;
var x2 = has("esri-mobile");
var I = class {
  constructor(e2, t5) {
    this.type = "FeatureSetReader", this.arcadeDeclaredClass = "esri.arcade.Feature", this.seen = false, this.instance = 0, this._tx = 0, this._ty = 0, this._sx = 1, this._sy = 1, this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._level = 0, this._datetimeMetadata = null, this.contextTimeReference = null, this.instance = e2, this._layerSchema = t5;
  }
  static createInstance() {
    return d3++, d3 = d3 > 65535 ? 0 : d3, d3;
  }
  get isEmpty() {
    return null != this._deleted && this._deleted.countSet() === this.getSize();
  }
  set level(e2) {
    this._level = e2;
  }
  getAreaSimplificationThreshold(e2, t5) {
    let r4 = 1;
    const s4 = x2 ? p2 : 1;
    t5 > 4e6 ? r4 = _ * s4 : t5 > 1e6 ? r4 = y * s4 : t5 > 5e5 ? r4 = g * s4 : t5 > 1e5 && (r4 = s4);
    let i3 = 0;
    e2 > 4e3 ? i3 = m2 * r4 : e2 > 2e3 ? i3 = c3 * r4 : e2 > 100 ? i3 = l2 : e2 > 15 && (i3 = u3);
    let n4 = 8;
    return this._level < 4 ? n4 = 1 : this._level < 5 ? n4 = 2 : this._level < 6 && (n4 = 4), i3 * n4;
  }
  createQuantizedExtrudedQuad(e2, t5) {
    return new t([5], [e2 - 1, t5, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  parseTimestampOffset(e2) {
    return e2;
  }
  setArcadeSpatialReference(e2) {
    this._arcadeSpatialReference = e2;
  }
  attachStorage(e2) {
    this._storage = e2;
  }
  getQuantizationTransform() {
    throw new Error("Unable to find transform for featureSet");
  }
  getStorage() {
    return this._storage;
  }
  getComputedNumeric(e2) {
    return this.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e2, t5) {
    return this.setComputedNumericAtIndex(t5, 0);
  }
  getComputedString(e2) {
    return this.getComputedStringAtIndex(0);
  }
  setComputedString(e2, t5) {
    return this.setComputedStringAtIndex(0, t5);
  }
  getComputedNumericAtIndex(e2) {
    return this._storage.getComputedNumericAtIndex(this.getDisplayId(), e2);
  }
  setComputedNumericAtIndex(e2, t5) {
    this._storage.setComputedNumericAtIndex(this.getDisplayId(), e2, t5);
  }
  getComputedStringAtIndex(e2) {
    return this._storage.getComputedStringAtIndex(this.getDisplayId(), e2);
  }
  setComputedStringAtIndex(e2, t5) {
    return this._storage.setComputedStringAtIndex(this.getDisplayId(), e2, t5);
  }
  transform(e2, t5, r4, s4) {
    const i3 = this.copy();
    return i3._tx += e2, i3._ty += t5, i3._sx *= r4, i3._sy *= s4, i3;
  }
  readAttribute(e2, t5 = false) {
    const r4 = this._readAttribute(e2, t5);
    if (void 0 !== r4)
      return r4;
    for (const s4 of this._joined) {
      s4.setIndex(this.getIndex());
      const r5 = s4._readAttribute(e2, t5);
      if (void 0 !== r5)
        return r5;
    }
  }
  readAttributes() {
    const e2 = this._readAttributes();
    for (const t5 of this._joined) {
      t5.setIndex(this.getIndex());
      const r4 = t5._readAttributes();
      for (const t6 of Object.keys(r4))
        e2[t6] = r4[t6];
    }
    return e2;
  }
  joinAttributes(e2) {
    this._joined.push(e2);
  }
  readArcadeFeature() {
    return this;
  }
  hasField(e2) {
    return this.fields.has(e2);
  }
  geometry() {
    const e2 = this.readHydratedGeometry(), t5 = st(e2, this.geometryType, this.hasZ, this.hasM), r4 = p(t5);
    return r4 && (r4.spatialReference = this._arcadeSpatialReference), r4;
  }
  get dateTimeReferenceFieldIndex() {
    return this._datetimeMetadata || (this._datetimeMetadata = T.create(this._layerSchema.fields, this._layerSchema)), this._datetimeMetadata;
  }
  autocastArcadeDate(t5, r4) {
    var _a;
    return r4 && r4 instanceof Date ? this.isUnknownDateTimeField(t5) ? c.unknownDateJSToArcadeDate(r4) : c.dateJSAndZoneToArcadeDate(r4, ((_a = this.contextTimeReference) == null ? void 0 : _a.timeZone) ?? "system") : r4;
  }
  isUnknownDateTimeField(e2) {
    var _a;
    return "unknown" === ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e2));
  }
  fieldSourceTimeZone(e2) {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e2)) ?? "";
  }
  get layerPreferredTimeZone() {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.layerPreferredTimeZone) ?? "";
  }
  field(e2) {
    if (this.hasField(e2))
      return this.autocastArcadeDate(e2, this.readAttribute(e2, true));
    for (const t5 of this._joined)
      if (t5.setIndex(this.getIndex()), t5.hasField(e2)) {
        const r4 = t5._readAttribute(e2, true);
        return this.autocastArcadeDate(e2, r4);
      }
    throw new Error(`Field ${e2} does not exist`);
  }
  setField(e2, t5) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.fields.fields.map((e2) => e2.name);
  }
  castToText(e2 = false) {
    if (!e2)
      return JSON.stringify(this.readLegacyFeature());
    const t5 = this.readLegacyFeature();
    if (!t5)
      return JSON.stringify(null);
    const r4 = { geometry: t5.geometry, attributes: { ...t5.attributes ?? {} } };
    for (const s4 in r4.attributes) {
      const e3 = r4.attributes[s4];
      e3 instanceof Date && (r4.attributes[s4] = e3.getTime());
    }
    return JSON.stringify(r4);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this._layerSchema;
  }
  castAsJson(e2 = null) {
    var _a;
    return { attributes: this._readAttributes(), geometry: true === (e2 == null ? void 0 : e2.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
  }
  castAsJsonAsync(e2 = null, t5 = null) {
    return Promise.resolve(this.castAsJson(t5));
  }
  removeIds(e2) {
    if (null == this._objectIdToIndex) {
      const e3 = /* @__PURE__ */ new Map(), t6 = this.getCursor();
      for (; t6.next(); ) {
        const s4 = u(t6.getObjectId());
        e3.set(s4, t6.getIndex());
      }
      this._objectIdToIndex = e3;
    }
    const t5 = this._objectIdToIndex;
    for (const r4 of e2)
      t5.has(r4) && this.removeAtIndex(t5.get(r4));
  }
  removeAtIndex(e2) {
    null == this._deleted && (this._deleted = t4.create(this.getSize())), this._deleted.set(e2);
  }
  readGeometryForDisplay() {
    return this.readUnquantizedGeometry(true);
  }
  readLegacyGeometryForDisplay() {
    return this.readLegacyGeometry(true);
  }
  *features() {
    const e2 = this.getCursor();
    for (; e2.next(); )
      yield e2.readOptimizedFeature();
  }
  _getExists() {
    return null == this._deleted || !this._deleted.has(this.getIndex());
  }
  _computeCentroid() {
    if ("esriGeometryPolygon" !== this.geometryType)
      return null;
    const e2 = this.readUnquantizedGeometry();
    if (!e2 || e2.hasIndeterminateRingOrder)
      return null;
    const t5 = this.getQuantizationTransform() ?? null;
    return t2(new t(), e2, this.hasM, this.hasZ, t5);
  }
  copyInto(e2) {
    e2.seen = this.seen, e2._storage = this._storage, e2._arcadeSpatialReference = this._arcadeSpatialReference, e2._joined = this._joined, e2._tx = this._tx, e2._ty = this._ty, e2._sx = this._sx, e2._sy = this._sy, e2._deleted = this._deleted, e2._objectIdToIndex = this._objectIdToIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFIndirect.js
var r3 = class _r extends I {
  static from(e2, t5) {
    return new _r(e2.copy(), t5);
  }
  constructor(r4, t5) {
    super(I.createInstance(), r4.fullSchema()), this._currentIndex = -1, this._reader = r4, this._indices = t5;
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const e2 = new _r(this._reader.copy(), this._indices);
    return e2._currentIndex = this._currentIndex, e2;
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); )
      ;
    return this._currentIndex < this._indices.length;
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  setArcadeSpatialReference(e2) {
    this._reader.setArcadeSpatialReference(e2);
  }
  attachStorage(e2) {
    this._reader.attachStorage(e2);
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  getStorage() {
    return this._reader.getStorage();
  }
  getComputedNumeric(e2) {
    return this._reader.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e2, r4) {
    return this._reader.setComputedNumericAtIndex(r4, 0);
  }
  getComputedString(e2) {
    return this._reader.getComputedStringAtIndex(0);
  }
  setComputedString(e2, r4) {
    return this._reader.setComputedStringAtIndex(0, r4);
  }
  getComputedNumericAtIndex(e2) {
    return this._reader.getComputedNumericAtIndex(e2);
  }
  setComputedNumericAtIndex(e2, r4) {
    this._reader.setComputedNumericAtIndex(e2, r4);
  }
  getComputedStringAtIndex(e2) {
    return this._reader.getComputedStringAtIndex(e2);
  }
  setComputedStringAtIndex(e2, r4) {
    return this._reader.setComputedStringAtIndex(e2, r4);
  }
  transform(e2, r4, t5, d5) {
    const a4 = this.copy();
    return a4._reader = this._reader.transform(e2, r4, t5, d5), a4;
  }
  readAttribute(e2, r4 = false) {
    return this._reader.readAttribute(e2, r4);
  }
  readAttributes() {
    return this._reader.readAttributes();
  }
  joinAttributes(e2) {
    return this._reader.joinAttributes(e2);
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(e2) {
    return this.readAttribute(e2, true);
  }
  hasField(e2) {
    return this._reader.hasField(e2);
  }
  setField(e2, r4) {
    return this._reader.setField(e2, r4);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(e2 = false) {
    return this._reader.castToText(e2);
  }
  getQuantizationTransform() {
    return this._reader.getQuantizationTransform();
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(e2) {
    return this._reader.setDisplayId(e2);
  }
  getGroupId() {
    return this._reader.getGroupId();
  }
  setGroupId(e2) {
    return this._reader.setGroupId(e2);
  }
  getXHydrated() {
    return this._reader.getXHydrated();
  }
  getYHydrated() {
    return this._reader.getYHydrated();
  }
  getX() {
    return this._reader.getX();
  }
  getY() {
    return this._reader.getY();
  }
  setIndex(e2) {
    return this._reader.setIndex(e2);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readLegacyFeature() {
    return this._reader.readLegacyFeature();
  }
  readOptimizedFeature() {
    return this._reader.readOptimizedFeature();
  }
  readLegacyPointGeometry() {
    return this._reader.readLegacyPointGeometry();
  }
  readLegacyGeometry() {
    return this._reader.readLegacyGeometry();
  }
  readLegacyCentroid() {
    return this._reader.readLegacyCentroid();
  }
  readGeometryArea() {
    return this._reader.readGeometryArea();
  }
  readUnquantizedGeometry() {
    return this._reader.readUnquantizedGeometry();
  }
  readHydratedGeometry() {
    return this._reader.readHydratedGeometry();
  }
  readGeometry() {
    return this._reader.readGeometry();
  }
  readCentroid() {
    return this._reader.readCentroid();
  }
  _readAttribute(e2, r4) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStore2D.js
var o2 = i();
function d4(t5, e2) {
  return t5 << 16 | e2;
}
function h3(t5) {
  return (4294901760 & t5) >>> 16;
}
function c4(t5) {
  return 65535 & t5;
}
var I2 = { getObjectId: (t5) => t5.getObjectId(), getAttributes: (t5) => t5.readAttributes(), getAttribute: (t5, e2) => t5.readAttribute(e2), cloneWithGeometry: (t5, e2) => t5, getGeometry: (t5) => t5.readHydratedGeometry(), getCentroid: (t5, e2) => t5.readCentroid() };
var u4 = class extends a3 {
  constructor(a4, r4, n4) {
    super(a4, r4), this.featureAdapter = I2, this.events = new n(), this._featureSetsByInstance = /* @__PURE__ */ new Map(), this._objectIdToDisplayId = /* @__PURE__ */ new Map(), this._spatialIndexInvalid = true, this._indexSearchCache = new t3(50), this._index = i2(9, (t5) => ({ minX: this._storage.getXMin(t5), minY: this._storage.getYMin(t5), maxX: this._storage.getXMax(t5), maxY: this._storage.getYMax(t5) })), this.mode = n4;
  }
  get storeStatistics() {
    let t5 = 0, e2 = 0, s4 = 0;
    return this.forEach((a4) => {
      const r4 = a4.readGeometry();
      r4 && (e2 += r4.isPoint ? 1 : r4.lengths.reduce((t6, e3) => t6 + e3, 0), s4 += r4.isPoint ? 1 : r4.lengths.length, t5 += 1);
    }), { featureCount: t5, vertexCount: e2, ringCount: s4 };
  }
  hasInstance(t5) {
    return this._featureSetsByInstance.has(t5);
  }
  onTileData(t5, e2) {
    if (null == e2.addOrUpdate)
      return e2;
    if (e2.addOrUpdate.attachStorage(this._storage), "snapshot" === this.mode) {
      const s5 = e2.addOrUpdate.getCursor();
      for (; s5.next(); ) {
        const e3 = s5.getDisplayId();
        this.setComputedAttributes(this._storage, s5, e3, t5.scale);
      }
      return e2;
    }
    this._featureSetsByInstance.set(e2.addOrUpdate.instance, e2.addOrUpdate);
    const s4 = e2.addOrUpdate.getCursor();
    for (; s4.next(); )
      this._insertFeature(s4, t5.scale);
    return this._spatialIndexInvalid = true, this.events.emit("changed"), e2;
  }
  search(t5) {
    this._rebuildIndex();
    const e2 = t5.id, s4 = this._indexSearchCache.find((t6) => t6.tileId === e2);
    if (null != s4)
      return s4.readers;
    const a4 = /* @__PURE__ */ new Map(), r4 = this._searchIndex(t5.bounds), n4 = [];
    for (const i3 of r4) {
      const t6 = this._storage.getInstanceId(i3), e3 = h3(t6), s5 = c4(t6);
      a4.has(e3) || a4.set(e3, []);
      a4.get(e3).push(s5);
    }
    return a4.forEach((t6, e3) => {
      const s5 = this._featureSetsByInstance.get(e3);
      n4.push(r3.from(s5, t6));
    }), this._indexSearchCache.enqueue({ tileId: e2, readers: n4 }), n4;
  }
  insert(t5) {
    const e2 = t5.getCursor(), s4 = this._storage;
    for (; e2.next(); ) {
      const t6 = d4(e2.instance, e2.getIndex()), a4 = e2.getObjectId(), r4 = this._objectIdToDisplayId.get(a4) ?? this._storage.createDisplayId();
      e2.setDisplayId(r4), s4.setInstanceId(r4, t6), this._objectIdToDisplayId.set(a4, r4);
    }
    this._featureSetsByInstance.set(t5.instance, t5), this._spatialIndexInvalid = true;
  }
  remove(t5) {
    const e2 = this._objectIdToDisplayId.get(t5);
    if (!e2)
      return;
    const s4 = this._storage.getInstanceId(e2), a4 = c4(s4), r4 = h3(s4), n4 = this._featureSetsByInstance.get(r4);
    this._objectIdToDisplayId.delete(t5), this._storage.releaseDisplayId(e2), n4.removeAtIndex(a4), n4.isEmpty && this._featureSetsByInstance.delete(r4), this._spatialIndexInvalid = true;
  }
  forEach(t5) {
    this._objectIdToDisplayId.forEach((e2) => {
      const s4 = this._storage.getInstanceId(e2), a4 = this._lookupFeature(s4);
      t5(a4);
    });
  }
  forEachUnsafe(t5) {
    this._objectIdToDisplayId.forEach((e2) => {
      const s4 = this._storage.getInstanceId(e2), a4 = h3(s4), r4 = c4(s4), n4 = this._getFeatureSet(a4);
      n4.setIndex(r4), t5(n4);
    });
  }
  forEachInBounds(t5, e2) {
    const s4 = this._searchIndex(t5);
    for (const a4 of s4) {
      e2(this.lookupFeatureByDisplayId(a4, this._storage));
    }
  }
  forEachBounds(t5, e2) {
    this._rebuildIndex();
    for (const s4 of t5) {
      if (!s4.readGeometry())
        continue;
      const t6 = s4.getDisplayId();
      d(o2, this._storage.getXMin(t6), this._storage.getYMin(t6), this._storage.getXMax(t6), this._storage.getYMax(t6)), e2(o2);
    }
  }
  sweepFeatures(t5, e2, s4) {
    this._spatialIndexInvalid = true, this._objectIdToDisplayId.forEach((a4, r4) => {
      t5.has(a4) || (e2.releaseDisplayId(a4), s4 && s4.unsetAttributeData(a4), this._objectIdToDisplayId.delete(r4));
    }), this.events.emit("changed");
  }
  sweepFeatureSets(t5) {
    this._spatialIndexInvalid = true, this._featureSetsByInstance.forEach((e2, s4) => {
      t5.has(s4) || this._featureSetsByInstance.delete(s4);
    });
  }
  lookupObjectId(t5, e2) {
    const s4 = this.lookupFeatureByDisplayId(t5, e2);
    return null == s4 ? null : s4.getObjectId();
  }
  lookupDisplayId(t5) {
    return this._objectIdToDisplayId.get(t5);
  }
  lookupFeatureByDisplayId(t5, e2) {
    const s4 = e2.getInstanceId(t5);
    return this._lookupFeature(s4);
  }
  lookupByDisplayIdUnsafe(t5) {
    const e2 = this._storage.getInstanceId(t5), s4 = h3(e2), a4 = c4(e2), r4 = this._getFeatureSet(s4);
    return r4 ? (r4.setIndex(a4), r4) : null;
  }
  _insertFeature(t5, e2) {
    const s4 = this._storage, a4 = t5.getObjectId(), r4 = d4(t5.instance, t5.getIndex());
    s4.getInstanceId(t5.getDisplayId());
    let n4 = this._objectIdToDisplayId.get(a4);
    n4 || (n4 = s4.createDisplayId(), this._objectIdToDisplayId.set(a4, n4), this._spatialIndexInvalid = true), t5.setDisplayId(n4), s4.setInstanceId(n4, r4), this.setComputedAttributes(s4, t5, n4, e2);
  }
  _searchIndex(t5) {
    this._rebuildIndex();
    const e2 = { minX: t5[0], minY: t5[1], maxX: t5[2], maxY: t5[3] };
    return this._index.search(e2);
  }
  _rebuildIndex() {
    if (!this._spatialIndexInvalid)
      return;
    const t5 = [];
    "snapshot" === this.mode ? this._featureSetsByInstance.forEach((e2) => {
      const s4 = e2.getCursor();
      for (; s4.next(); ) {
        const e3 = s4.getDisplayId();
        this._storage.setBounds(e3, s4) && t5.push(e3);
      }
    }) : this._objectIdToDisplayId.forEach((e2) => {
      const s4 = this._storage.getInstanceId(e2);
      this._storage.setBounds(e2, this._lookupFeature(s4)) && t5.push(e2);
    }), this._index.clear(), this._index.load(t5), this._indexSearchCache.clear(), this._spatialIndexInvalid = false;
  }
  _lookupFeature(t5) {
    const e2 = h3(t5), s4 = this._getFeatureSet(e2);
    if (!s4)
      return;
    const a4 = s4.getCursor(), r4 = c4(t5);
    return a4.setIndex(r4), a4;
  }
  _getFeatureSet(t5) {
    return this._featureSetsByInstance.get(t5);
  }
};

export {
  i2 as i,
  a3 as a,
  t4 as t,
  I,
  r3 as r,
  I2,
  u4 as u
};
//# sourceMappingURL=chunk-C4NVJBAG.js.map
