import {
  H
} from "./chunk-DHFFBNI6.js";
import "./chunk-PODY5IF6.js";
import {
  I,
  T
} from "./chunk-QSO5MBMS.js";
import {
  d as d3
} from "./chunk-YKVCEFM7.js";
import {
  m
} from "./chunk-RMQ3PJIC.js";
import "./chunk-6OVHX5ZO.js";
import "./chunk-3LR4MDXK.js";
import {
  ee
} from "./chunk-V7IVNH7O.js";
import "./chunk-LLQHB2ZB.js";
import {
  f,
  g
} from "./chunk-O2Q4W74O.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-PVUG2RDQ.js";
import "./chunk-J3HE7QNA.js";
import "./chunk-GRB6LNZN.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-HSZYWTXA.js";
import "./chunk-YZ24SAPZ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-S5RIUWET.js";
import "./chunk-MNDNZJD5.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-CUZNACFZ.js";
import "./chunk-ZHUFARKQ.js";
import {
  rt,
  st
} from "./chunk-ICEO3WMK.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-L3FCQBVC.js";
import {
  r
} from "./chunk-BFZI4PK4.js";
import "./chunk-E2PV5YTZ.js";
import "./chunk-GLVTFP5O.js";
import "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-WIQR3T32.js";
import "./chunk-C2EHS6UI.js";
import {
  d as d2
} from "./chunk-DR3XNW4L.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-3ESTI2X4.js";
import "./chunk-YK2WEG7V.js";
import "./chunk-W3WHCGIQ.js";
import "./chunk-HPWZ2OON.js";
import "./chunk-CNS4YGGN.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-J2V5CZSS.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import "./chunk-7U6V6KY2.js";
import {
  S2 as S,
  p
} from "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import "./chunk-453UIKKW.js";
import "./chunk-5BLDWPLW.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  d,
  s2 as s3
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var d4 = class {
  constructor() {
    this._queryEngine = null, this._customParameters = null, this._snapshotFeatures = async (e) => {
      const { objectIdField: t } = this._queryEngine, r2 = await H(this._getFeatureUrl ?? "", this._featureType.typeName, this._getFeatureOutputFormat, { customParameters: this._customParameters, dateFields: this._queryEngine.fieldsIndex.dateFields.map((e2) => e2.name), signal: e });
      await T(r2), s3(e);
      const a = I(r2, { geometryType: this._queryEngine.geometryType, hasZ: false, objectIdField: t });
      if (!S(this._queryEngine.spatialReference, p))
        for (const s4 of a)
          null != s4.geometry && (s4.geometry = rt(g(st(s4.geometry, this._queryEngine.geometryType, false, false), p, this._queryEngine.spatialReference)));
      let p2 = 1;
      for (const s4 of a) {
        const e2 = {};
        d3(this._fieldsIndex, e2, s4.attributes, true), s4.attributes = e2, null == s4.attributes[t] && (s4.objectId = s4.attributes[t] = p2++);
      }
      return a;
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, t) {
    const { getFeatureUrl: r2, getFeatureOutputFormat: a, spatialReference: i, fields: n, geometryType: o, featureType: u, objectIdField: h, customParameters: y } = e;
    this._featureType = u, this._customParameters = y, this._getFeatureUrl = r2, this._getFeatureOutputFormat = a, this._fieldsIndex = new r(n), await this._checkProjection(i), s3(t), this._queryEngine = new ee({ fields: n, geometryType: o, hasM: false, hasZ: false, objectIdField: h, spatialReference: i, timeInfo: null, featureStore: new m({ geometryType: o, hasM: false, hasZ: false }) });
    const l = await this._snapshotFeatures(t.signal);
    return this._queryEngine.featureStore.addMany(l), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s2("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(s4) {
    var _a;
    return this._customParameters = s4, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e) => {
      this._queryEngine.featureStore.clear(), e && this._queryEngine.featureStore.addMany(e);
    }, (e) => {
      this._queryEngine.featureStore.clear(), d(e) || s.getLogger("esri.layers.WFSLayer").error(new s2("wfs-layer:getfeature-error", "An error occurred during the GetFeature request", { error: e }));
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _checkProjection(e) {
    try {
      await f(p, e);
    } catch {
      throw new s2("unsupported-projection", "Projection not supported", { spatialReference: e });
    }
  }
};
export {
  d4 as default
};
//# sourceMappingURL=WFSSourceWorker-LWOLTTCV.js.map
