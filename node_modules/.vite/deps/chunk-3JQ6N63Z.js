import {
  p
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  O,
  b,
  v
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/core/handleUtils.js
function n(n3) {
  return e(() => n3.forEach((n4) => null != n4 && n4.remove()));
}
function e(n3) {
  return { remove: () => {
    n3 && (n3(), n3 = void 0);
  } };
}
function o(n3) {
  return e(null != n3 ? () => n3.destroy() : void 0);
}

// node_modules/@arcgis/core/core/accessorSupport/utils.js
function e2(r) {
  return r.__accessor__ ?? null;
}
function i(r, n3) {
  return null != r && r.metadatas && null != r.metadatas[n3];
}
function o2(r, n3, t2) {
  if (t2) {
    return a2(r, n3, { policy: t2, path: "" });
  }
  return a2(r, n3, null);
}
function a2(r, e4, i4) {
  return e4 ? Object.keys(e4).reduce((r2, u2) => {
    const o5 = u2;
    let l3 = null, s4 = "merge";
    if (i4 && (l3 = i4.path ? `${i4.path}.${u2}` : u2, s4 = i4.policy(l3)), "replace" === s4)
      return r2[o5] = e4[o5], r2;
    if ("replace-arrays" === s4 && Array.isArray(r2[o5]))
      return r2[o5] = e4[o5], r2;
    if (void 0 === r2[o5])
      return r2[o5] = a(e4[o5]), r2;
    let c3 = r2[o5], f3 = e4[o5];
    if (c3 === f3)
      return r2;
    if (Array.isArray(f3) || Array.isArray(r2))
      c3 = c3 ? Array.isArray(c3) ? r2[o5] = c3.concat() : r2[o5] = [c3] : r2[o5] = [], f3 && (Array.isArray(f3) || (f3 = [f3]), f3.forEach((r3) => {
        c3.includes(r3) || c3.push(r3);
      }));
    else if (f3 && "object" == typeof f3)
      if (i4) {
        const n3 = i4.path;
        i4.path = p(l3), r2[o5] = a2(c3, f3, i4), i4.path = n3;
      } else
        r2[o5] = a2(c3, f3, null);
    else
      r2.hasOwnProperty(u2) && !e4.hasOwnProperty(u2) || (r2[o5] = f3);
    return r2;
  }, r || {}) : r;
}
function s2(r) {
  return Array.isArray(r) ? r : r.split(".");
}
function c(r) {
  return r.includes(",") ? r.split(",").map((r2) => r2.trim()) : [r.trim()];
}
function f(r) {
  if (Array.isArray(r)) {
    const n3 = [];
    for (const t2 of r)
      n3.push(...c(t2));
    return n3;
  }
  return c(r);
}
function y(n3, t2, e4, i4) {
  const u2 = f(t2);
  if (1 !== u2.length) {
    const t3 = u2.map((r) => i4(n3, r, e4));
    return n(t3);
  }
  return i4(n3, u2[0], e4);
}
function h(r) {
  let n3 = false;
  return () => {
    n3 || (n3 = true, r());
  };
}

// node_modules/@arcgis/core/core/accessorSupport/tracking/Flags.js
var i2;
!function(i4) {
  i4[i4.Dirty = 1] = "Dirty", i4[i4.Overriden = 2] = "Overriden", i4[i4.Computing = 4] = "Computing", i4[i4.NonNullable = 8] = "NonNullable", i4[i4.HasDefaultValue = 16] = "HasDefaultValue", i4[i4.DepTrackingInitialized = 32] = "DepTrackingInitialized", i4[i4.AutoTracked = 64] = "AutoTracked", i4[i4.ExplicitlyTracking = 128] = "ExplicitlyTracking";
}(i2 || (i2 = {}));

// node_modules/@arcgis/core/core/accessorSupport/tracking.js
var o3 = { onObservableAccessed: () => {
}, onTrackingEnd: () => {
} };
var c2 = [];
var s3 = o3;
function i3(t2) {
  s3.onObservableAccessed(t2);
}
var l = false;
var a3 = false;
function f2(t2, n3, e4) {
  if (l)
    return u(t2, n3, e4);
  p2(t2);
  const r = n3.call(e4);
  return d(), r;
}
function g(t2, n3) {
  return f2(o3, t2, n3);
}
function u(n3, e4, r) {
  const o5 = l;
  l = true, p2(n3);
  let c3 = null;
  try {
    c3 = e4.call(r);
  } catch (s4) {
    a3 && s.getLogger("esri.core.accessorSupport.tracking").error(s4);
  }
  return d(), l = o5, c3;
}
function p2(t2) {
  s3 = t2, c2.push(t2);
}
function d() {
  const t2 = c2.length;
  if (t2 > 1) {
    const n3 = c2.pop();
    s3 = c2[t2 - 2], n3.onTrackingEnd();
  } else if (1 === t2) {
    const t3 = c2.pop();
    s3 = o3, t3.onTrackingEnd();
  } else
    s3 = o3;
}
function b2(t2, n3) {
  const e4 = n3.observerObject;
  if (e4.flags & i2.DepTrackingInitialized)
    return;
  const o5 = a3;
  a3 = false, e4.flags & i2.AutoTracked ? u(n3, n3.metadata.get, t2) : y2(t2, n3), a3 = o5;
}
var m = [];
function y2(t2, e4) {
  const o5 = e4.observerObject;
  o5.flags & i2.ExplicitlyTracking || (o5.flags |= i2.ExplicitlyTracking, u(e4, () => {
    const r = e4.metadata.dependsOn || m;
    for (const e5 of r)
      if ("string" != typeof e5 || e5.includes(".")) {
        const r2 = s2(e5);
        for (let n3 = 0, e6 = t2; n3 < r2.length && null != e6 && "object" == typeof e6; ++n3)
          e6 = k(e6, r2[n3], n3 !== r2.length - 1);
      } else
        k(t2, e5, false);
  }), o5.flags &= ~i2.ExplicitlyTracking);
}
function k(t2, n3, r) {
  const o5 = "?" === n3[n3.length - 1] ? n3.slice(0, -1) : n3;
  if (null != t2.getItemAt || Array.isArray(t2)) {
    const n4 = parseInt(o5, 10);
    if (!isNaN(n4))
      return Array.isArray(t2) ? t2[n4] : t2.at(n4);
  }
  const c3 = e2(t2);
  if (c3) {
    const n4 = c3.propertiesByName.get(o5);
    n4 && (i3(n4.observerObject), b2(t2, n4));
  }
  return r ? t2[o5] : void 0;
}

// node_modules/@arcgis/core/core/HeapSort.js
var o4;
!function(o5) {
  const t2 = (o6, t3, n4, e5) => {
    let i5 = t3, c3 = t3;
    const l3 = n4 >>> 1, r = o6[i5 - 1];
    for (; c3 <= l3; ) {
      c3 = i5 << 1, c3 < n4 && e5(o6[c3 - 1], o6[c3]) < 0 && ++c3;
      const t4 = o6[c3 - 1];
      if (e5(t4, r) <= 0)
        break;
      o6[i5 - 1] = t4, i5 = c3;
    }
    o6[i5 - 1] = r;
  }, n3 = (o6, t3) => o6 < t3 ? -1 : o6 > t3 ? 1 : 0;
  function e4(o6, e5, i5, c3) {
    void 0 === e5 && (e5 = 0), void 0 === i5 && (i5 = o6.length), void 0 === c3 && (c3 = n3);
    for (let n4 = i5 >>> 1; n4 > e5; n4--)
      t2(o6, n4, i5, c3);
    const l3 = e5 + 1;
    for (let n4 = i5 - 1; n4 > e5; n4--) {
      const i6 = o6[e5];
      o6[e5] = o6[n4], o6[n4] = i6, t2(o6, l3, n4, c3);
    }
  }
  function* i4(o6, e5, i5, c3) {
    void 0 === e5 && (e5 = 0), void 0 === i5 && (i5 = o6.length), void 0 === c3 && (c3 = n3);
    for (let n4 = i5 >>> 1; n4 > e5; n4--)
      t2(o6, n4, i5, c3), yield;
    const l3 = e5 + 1;
    for (let n4 = i5 - 1; n4 > e5; n4--) {
      const i6 = o6[e5];
      o6[e5] = o6[n4], o6[n4] = i6, t2(o6, l3, n4, c3), yield;
    }
  }
  o5.sort = e4, o5.iterableSort = i4;
}(o4 || (o4 = {}));
var t = o4;

// node_modules/@arcgis/core/core/PooledArray.js
var a4 = 1.5;
var e3 = 1.1;
var l2 = class {
  constructor(h2) {
    this.data = [], this._length = 0, this._allocator = void 0, this._deallocator = () => null, this._shrink = () => {
    }, this._hint = new v(), h2 && (h2.initialSize && (this.data = new Array(h2.initialSize)), h2.allocator && (this._allocator = h2.allocator), void 0 !== h2.deallocator && (this._deallocator = h2.deallocator), h2.shrink && (this._shrink = () => n2(this)));
  }
  toArray() {
    return this.data.slice(0, this.length);
  }
  filter(t2) {
    const h2 = new Array();
    for (let i4 = 0; i4 < this._length; i4++) {
      const s4 = this.data[i4];
      t2(s4) && h2.push(s4);
    }
    return h2;
  }
  at(t2) {
    if ((t2 = Math.trunc(t2) || 0) < 0 && (t2 += this._length), !(t2 < 0 || t2 >= this._length))
      return this.data[t2];
  }
  includes(t2, h2) {
    const i4 = this.data.indexOf(t2, h2);
    return -1 !== i4 && i4 < this.length;
  }
  get length() {
    return this._length;
  }
  set length(t2) {
    if (t2 > this._length) {
      if (this._allocator) {
        for (; this._length < t2; )
          this.data[this._length++] = this._allocator(this.data[this._length]);
        return;
      }
      this._length = t2;
    } else {
      if (this._deallocator)
        for (let h2 = t2; h2 < this._length; ++h2)
          this.data[h2] = this._deallocator(this.data[h2]);
      this._length = t2, this._shrink();
    }
  }
  clear() {
    this.length = 0;
  }
  prune() {
    this.clear(), this.data = [];
  }
  push(t2) {
    this.data[this._length++] = t2;
  }
  pushArray(t2, h2 = t2.length) {
    for (let i4 = 0; i4 < h2; i4++)
      this.data[this._length++] = t2[i4];
  }
  fill(t2, h2) {
    for (let i4 = 0; i4 < h2; i4++)
      this.data[this._length++] = t2;
  }
  pushNew() {
    this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
    const t2 = this.data[this._length];
    return ++this._length, t2;
  }
  unshift(t2) {
    this.data.unshift(t2), this._length++, n2(this);
  }
  pop() {
    if (0 === this.length)
      return;
    const t2 = this.data[this.length - 1];
    return this.length = this.length - 1, this._shrink(), t2;
  }
  remove(t2) {
    const i4 = b(this.data, t2, this.length, this._hint);
    if (-1 !== i4)
      return this.data.splice(i4, 1), this.length = this.length - 1, t2;
  }
  removeUnordered(t2) {
    return this.removeUnorderedIndex(b(this.data, t2, this.length, this._hint));
  }
  removeUnorderedIndex(t2) {
    if (!(t2 >= this.length || t2 < 0))
      return this.swapElements(t2, this.length - 1), this.pop();
  }
  removeUnorderedMany(t2, h2 = t2.length, s4) {
    this.length = O(this.data, t2, this.length, h2, this._hint, s4), this._shrink();
  }
  front() {
    if (0 !== this.length)
      return this.data[0];
  }
  back() {
    if (0 !== this.length)
      return this.data[this.length - 1];
  }
  swapElements(t2, h2) {
    if (t2 >= this.length || h2 >= this.length || t2 === h2)
      return;
    const i4 = this.data[t2];
    this.data[t2] = this.data[h2], this.data[h2] = i4;
  }
  sort(t2) {
    t.sort(this.data, 0, this.length, t2);
  }
  iterableSort(t2) {
    return t.iterableSort(this.data, 0, this.length, t2);
  }
  some(t2, h2) {
    for (let i4 = 0; i4 < this.length; ++i4)
      if (t2.call(h2, this.data[i4], i4, this.data))
        return true;
    return false;
  }
  find(t2, h2) {
    for (let i4 = 0; i4 < this.length; ++i4) {
      const s4 = this.data[i4];
      if (t2.call(h2, s4, i4))
        return s4;
    }
  }
  filterInPlace(t2, h2) {
    let i4 = 0;
    for (let s4 = 0; s4 < this._length; ++s4) {
      const a5 = this.data[s4];
      t2.call(h2, a5, s4, this.data) && (this.data[s4] = this.data[i4], this.data[i4] = a5, i4++);
    }
    if (this._deallocator)
      for (let s4 = i4; s4 < this._length; s4++)
        this.data[s4] = this._deallocator(this.data[s4]);
    return this._length = i4, this._shrink(), this;
  }
  forAll(t2, h2) {
    const i4 = this.length, s4 = this.data;
    for (let a5 = 0; a5 < i4; ++a5)
      t2.call(h2, s4[a5], a5, s4);
  }
  forEach(t2, h2) {
    for (let i4 = 0; i4 < this.length; ++i4)
      t2.call(h2, this.data[i4], i4, this.data);
  }
  map(t2, h2) {
    const i4 = new Array(this.length);
    for (let s4 = 0; s4 < this.length; ++s4)
      i4[s4] = t2.call(h2, this.data[s4], s4, this.data);
    return i4;
  }
  reduce(t2, h2) {
    let i4 = h2;
    for (let s4 = 0; s4 < this.length; ++s4)
      i4 = t2(i4, this.data[s4], s4, this.data);
    return i4;
  }
  has(t2) {
    const h2 = this.length, i4 = this.data;
    for (let s4 = 0; s4 < h2; ++s4)
      if (i4[s4] === t2)
        return true;
    return false;
  }
};
function n2(t2) {
  t2.data.length > a4 * t2.length && (t2.data.length = Math.floor(t2.length * e3));
}

export {
  n,
  e,
  o,
  e2,
  i,
  o2,
  s2 as s,
  y,
  h,
  i2,
  i3,
  f2 as f,
  g,
  b2 as b,
  y2,
  l2 as l
};
//# sourceMappingURL=chunk-3JQ6N63Z.js.map
