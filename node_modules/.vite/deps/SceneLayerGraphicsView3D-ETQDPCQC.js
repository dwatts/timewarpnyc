import {
  i as i3,
  j,
  l as l3,
  p,
  r
} from "./chunk-MTP3D562.js";
import {
  i as i2
} from "./chunk-QEB7IAEU.js";
import {
  t2 as t6
} from "./chunk-W2BFH4NJ.js";
import {
  D2 as D,
  ee
} from "./chunk-OBTF4YMI.js";
import "./chunk-LUW5YH5K.js";
import "./chunk-TFBK4UWT.js";
import {
  _,
  c as c2
} from "./chunk-57BN4YG4.js";
import "./chunk-DEBQNQHK.js";
import "./chunk-RHUGUXGR.js";
import "./chunk-PKQ2SINV.js";
import "./chunk-SYR2G6XU.js";
import "./chunk-NCJWSWGW.js";
import "./chunk-MHABBCOV.js";
import "./chunk-UVYXRE2S.js";
import {
  n as n4
} from "./chunk-GD75B7SP.js";
import "./chunk-AGK2CKWJ.js";
import "./chunk-ANLIVU2T.js";
import "./chunk-KGLSZSEH.js";
import "./chunk-WON6TZX6.js";
import "./chunk-5GTBTJ5J.js";
import "./chunk-NCMHNGYC.js";
import "./chunk-NWXX4RT6.js";
import "./chunk-IRHHHG7O.js";
import "./chunk-3VYBBKPH.js";
import "./chunk-DDU77THI.js";
import "./chunk-5RQTPWCM.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-FP4CFXG6.js";
import "./chunk-V5N62ACA.js";
import "./chunk-RMQ3PJIC.js";
import "./chunk-6OVHX5ZO.js";
import "./chunk-3LR4MDXK.js";
import "./chunk-V7IVNH7O.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-O2Q4W74O.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-PVUG2RDQ.js";
import "./chunk-J3HE7QNA.js";
import "./chunk-GRB6LNZN.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-HSZYWTXA.js";
import "./chunk-YZ24SAPZ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-6XUC2FZF.js";
import "./chunk-BUKSB3RJ.js";
import "./chunk-FQPEAXKN.js";
import "./chunk-QL3WCPM7.js";
import "./chunk-JBKOFMVJ.js";
import "./chunk-LB5DD6MA.js";
import "./chunk-UYTOEYIN.js";
import "./chunk-JQKL7AD5.js";
import "./chunk-UXILD4EC.js";
import {
  c
} from "./chunk-SU7C3V7L.js";
import "./chunk-KV3PR5T6.js";
import "./chunk-Y554AESO.js";
import "./chunk-SCHIU6CT.js";
import "./chunk-AD4YIQAV.js";
import "./chunk-4DMQJ2S2.js";
import "./chunk-SFLHXPT4.js";
import "./chunk-ICIEEFA3.js";
import "./chunk-UTDRCXKP.js";
import "./chunk-HXNDA4EJ.js";
import "./chunk-ZFRKFGUZ.js";
import "./chunk-6YRYWMPZ.js";
import "./chunk-ADAZBQKN.js";
import "./chunk-6EBCANA3.js";
import "./chunk-K7N526Q4.js";
import "./chunk-JRSZCAZV.js";
import "./chunk-YIZLAUCA.js";
import "./chunk-3ZJOLTPQ.js";
import "./chunk-V4MUDRER.js";
import {
  C
} from "./chunk-FUNFO42Y.js";
import "./chunk-N33CV3QM.js";
import "./chunk-FF3JARPY.js";
import "./chunk-UP7SW73R.js";
import "./chunk-VHOCNQAB.js";
import "./chunk-OK2X54ZK.js";
import "./chunk-RDB3JY7T.js";
import "./chunk-WO5DESPO.js";
import "./chunk-W5D3JTKS.js";
import "./chunk-JGNIGIZR.js";
import "./chunk-LUC7NVZB.js";
import "./chunk-XEG7QIWD.js";
import "./chunk-SFZTK3JV.js";
import "./chunk-GZLXOXKP.js";
import "./chunk-SME753HL.js";
import "./chunk-4QCFWJ22.js";
import {
  o as o3
} from "./chunk-PC4A4CQR.js";
import "./chunk-MIJNMSZR.js";
import "./chunk-HKJ2JMCX.js";
import {
  t as t5
} from "./chunk-644IM3NW.js";
import "./chunk-KWPMDFFW.js";
import "./chunk-O25GNIYL.js";
import "./chunk-XKYCNHCM.js";
import "./chunk-KFBN32GM.js";
import "./chunk-N4JKQR77.js";
import "./chunk-ZPXPJ2G7.js";
import "./chunk-GXIJZVS6.js";
import "./chunk-6LC2JTLC.js";
import "./chunk-LYVSHBLV.js";
import "./chunk-NZZXHYUD.js";
import "./chunk-S2XINYNZ.js";
import "./chunk-ZIP4LO57.js";
import "./chunk-D5NSNTGJ.js";
import "./chunk-5IGN7QB3.js";
import "./chunk-AN7CDKM7.js";
import "./chunk-AA5GXCZF.js";
import "./chunk-X3ONRBOR.js";
import "./chunk-UF4LSGC7.js";
import "./chunk-VG7E4EAR.js";
import "./chunk-Y5WQRWCP.js";
import "./chunk-JI3FA4UR.js";
import "./chunk-HXPEPPWJ.js";
import "./chunk-A76FH7WO.js";
import "./chunk-3JWSWLNQ.js";
import "./chunk-MUDJ2KE7.js";
import "./chunk-EVSMDRIW.js";
import "./chunk-2CJB7VCN.js";
import "./chunk-5AW2TAZE.js";
import "./chunk-Z2RTGLQI.js";
import "./chunk-77DVCCTB.js";
import "./chunk-VVBWSIUG.js";
import "./chunk-TXZY5TKH.js";
import "./chunk-YMGFO2D7.js";
import "./chunk-FZT425TB.js";
import "./chunk-6AORBEIP.js";
import "./chunk-E4SXYCGV.js";
import "./chunk-CYWA6YJM.js";
import "./chunk-5DK7WWJE.js";
import "./chunk-M3ODSYZR.js";
import "./chunk-FB4A6PBH.js";
import "./chunk-UG4QYACC.js";
import "./chunk-GRRIWI4U.js";
import "./chunk-X5HNB5JI.js";
import "./chunk-K43XJEZQ.js";
import "./chunk-6JSGBXI6.js";
import "./chunk-KBPF5PFD.js";
import "./chunk-STAL4WDK.js";
import "./chunk-GXJIA6VA.js";
import "./chunk-L5ONWTZL.js";
import "./chunk-UI5O37MZ.js";
import "./chunk-XFZB3R5P.js";
import "./chunk-YRKEWWDW.js";
import {
  t as t4
} from "./chunk-KHQ5TXSL.js";
import "./chunk-NU4UASX6.js";
import "./chunk-LQIVAUXR.js";
import "./chunk-F4YTVHY4.js";
import "./chunk-4FXCMZ3U.js";
import "./chunk-SADO52IH.js";
import "./chunk-FOJITELY.js";
import "./chunk-NCXRF7LF.js";
import "./chunk-73PNWDTS.js";
import "./chunk-PKS3ZVLN.js";
import "./chunk-XMR2X5WG.js";
import "./chunk-KUPJ3HED.js";
import "./chunk-36L3RRF7.js";
import "./chunk-BUCIQGFS.js";
import "./chunk-OUYOFOVY.js";
import "./chunk-HVLYIZVQ.js";
import "./chunk-FDGDKKWR.js";
import "./chunk-25GSBURT.js";
import "./chunk-63ERNIOV.js";
import "./chunk-KKDPZLGI.js";
import "./chunk-XTOI3E3Y.js";
import {
  h as h2
} from "./chunk-WT7BDUIR.js";
import "./chunk-IWGINM6K.js";
import "./chunk-WUQZO2AO.js";
import "./chunk-IVCEO3SL.js";
import "./chunk-3RKFJO4O.js";
import "./chunk-P4NNXJS3.js";
import "./chunk-LZAQ3R3T.js";
import "./chunk-Y67AAEQ4.js";
import "./chunk-L2MGQ544.js";
import "./chunk-O2CT6XUA.js";
import "./chunk-DWF7HN4X.js";
import "./chunk-2ORXZKWN.js";
import "./chunk-KTGLOZE4.js";
import "./chunk-K6DV6EVZ.js";
import "./chunk-EDILO3VR.js";
import "./chunk-2CKXYQCA.js";
import "./chunk-JP7O2ZWE.js";
import "./chunk-6AGTIZBD.js";
import "./chunk-UT4ZWPHT.js";
import "./chunk-LWDDTPWX.js";
import "./chunk-LWKRCHND.js";
import "./chunk-USOI6RP2.js";
import "./chunk-TLBJBU3X.js";
import "./chunk-YYE6WDO2.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-QNBIVGAZ.js";
import "./chunk-5KLICR5E.js";
import "./chunk-RSPVLZNN.js";
import "./chunk-PR2OEILG.js";
import "./chunk-JPKFB2QL.js";
import "./chunk-2AUW3MT4.js";
import {
  e as e2,
  t as t2
} from "./chunk-UM64E5NS.js";
import "./chunk-2SZNVP5H.js";
import {
  M,
  Z
} from "./chunk-MXVQCJ4K.js";
import "./chunk-G4LSNP77.js";
import "./chunk-S5RIUWET.js";
import {
  I
} from "./chunk-MNDNZJD5.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-CUZNACFZ.js";
import "./chunk-ZHUFARKQ.js";
import "./chunk-ICEO3WMK.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-L3FCQBVC.js";
import "./chunk-IUCM3FNB.js";
import "./chunk-PCEMOYTZ.js";
import "./chunk-4RU6WIRN.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-OX5TJXHM.js";
import "./chunk-BDWD2ZNU.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-HLBPEADQ.js";
import "./chunk-FIBWCATC.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-JPAY3V43.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-RR3IDPQP.js";
import "./chunk-QOWAKGE4.js";
import {
  Z as Z2,
  fe,
  ge,
  ne,
  ye
} from "./chunk-S7T3AEV6.js";
import {
  t as t3
} from "./chunk-3FVFBGNT.js";
import "./chunk-XKENZ7D5.js";
import {
  R
} from "./chunk-BPWFCV3C.js";
import "./chunk-AI6XUWWS.js";
import {
  s as s2
} from "./chunk-6S2FCH6S.js";
import "./chunk-BZL5MAFP.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-XY26YCFX.js";
import "./chunk-3TTW7E7W.js";
import "./chunk-7FNOSSSO.js";
import "./chunk-LLQMBVBO.js";
import "./chunk-DS6JZDZO.js";
import "./chunk-OTNLRAEN.js";
import "./chunk-OKABUMQT.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-4KXQQ53L.js";
import {
  d
} from "./chunk-TBKQVVVQ.js";
import "./chunk-CDI6XFV5.js";
import "./chunk-SJSAYHBJ.js";
import "./chunk-WXSXHXM4.js";
import "./chunk-PYQNXC2L.js";
import "./chunk-NHHKW3WR.js";
import "./chunk-V4EIGIRT.js";
import "./chunk-MD5VUVM5.js";
import {
  b
} from "./chunk-CF43FEIV.js";
import "./chunk-GNESNC4Q.js";
import "./chunk-VYG5A4VI.js";
import "./chunk-ANW6V73Y.js";
import "./chunk-FJ3XUIT3.js";
import "./chunk-CGJNVOU3.js";
import "./chunk-BFZI4PK4.js";
import "./chunk-HVAOWOGC.js";
import "./chunk-6NPJZOPM.js";
import "./chunk-MNR4BIGQ.js";
import "./chunk-IHCIS6PT.js";
import "./chunk-OHH3UAUS.js";
import "./chunk-2NTQWEQZ.js";
import "./chunk-QZ6WR57P.js";
import "./chunk-E2PV5YTZ.js";
import "./chunk-GLVTFP5O.js";
import "./chunk-YGUWDSEH.js";
import {
  Hn,
  yn
} from "./chunk-2NXAWKLI.js";
import {
  t
} from "./chunk-AUKNAK3D.js";
import "./chunk-2TWR6EVF.js";
import "./chunk-IR32DXLL.js";
import "./chunk-7BMUKKBX.js";
import "./chunk-WIQR3T32.js";
import "./chunk-C2EHS6UI.js";
import {
  m as m2
} from "./chunk-HKUQGT3G.js";
import "./chunk-LTYDGBC5.js";
import "./chunk-XR4HIGQP.js";
import "./chunk-H2WAWDF5.js";
import "./chunk-LG2ZH3JE.js";
import "./chunk-DKJBDKGA.js";
import "./chunk-4CZO65BK.js";
import "./chunk-DR3XNW4L.js";
import "./chunk-DKCDRJ5N.js";
import "./chunk-PCTUO7WS.js";
import "./chunk-KGA7WAD3.js";
import "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-ZUBHLDU6.js";
import "./chunk-C3PCK5WU.js";
import "./chunk-HE256ZWN.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-PZXYASUU.js";
import "./chunk-VYGC2LVC.js";
import "./chunk-VHPS7AS5.js";
import "./chunk-GH3XG2RA.js";
import "./chunk-3ESTI2X4.js";
import "./chunk-YK2WEG7V.js";
import "./chunk-5EXFDBQJ.js";
import "./chunk-GVQH342Z.js";
import "./chunk-POEWD5LS.js";
import "./chunk-HTVQN75V.js";
import "./chunk-W3WHCGIQ.js";
import {
  h,
  l as l2
} from "./chunk-HPWZ2OON.js";
import {
  h as h3
} from "./chunk-WAPUHORU.js";
import "./chunk-HXDFHMRK.js";
import "./chunk-5HSVWQOA.js";
import "./chunk-C2BBLDPU.js";
import "./chunk-GWA3PLGA.js";
import "./chunk-FXWSVUF2.js";
import "./chunk-CNS4YGGN.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-CEXY22SC.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7JNPZC53.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-UNJDKTFU.js";
import "./chunk-DH42JQZX.js";
import "./chunk-674HAVOZ.js";
import "./chunk-MHGDFNBE.js";
import {
  n as n3
} from "./chunk-J2V5CZSS.js";
import "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import {
  o as o2
} from "./chunk-TPJLFGOT.js";
import {
  n as n2
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import {
  i,
  o
} from "./chunk-T35GN7EL.js";
import "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  n
} from "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  l
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  m,
  x
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/3d/layers/I3SPointsWorkerHandle.js
var r2 = class extends h2 {
  constructor(e3) {
    super("SceneLayerWorker", "dracoDecompressPointCloudData", { dracoDecompressPointCloudData: (e4) => [e4.geometryBuffer] }, e3, { hasInitialize: true });
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SGraphicsMap.js
var s3 = class extends n3 {
  constructor(e3, t7) {
    super(), this._updateAndCompare = e3, this._notifyUpdated = t7, this._nodes = /* @__PURE__ */ new Map(), this._graphics = /* @__PURE__ */ new Map(), this._duplicates = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._graphics.size > 0) {
      const e3 = this.toArray();
      this._graphics.clear(), this.emit("change", { added: [], removed: e3 });
    }
    this._nodes.clear();
  }
  get length() {
    return this._graphics.size;
  }
  get(e3) {
    return this._graphics.get(e3);
  }
  getNode(e3) {
    return this._nodes.get(e3);
  }
  hasNode(e3) {
    return this._nodes.has(e3);
  }
  nodes() {
    return this._nodes.values();
  }
  addNode(e3, t7) {
    this._nodes.set(e3, t7);
    const s4 = t7.graphics;
    if (0 === s4.length)
      return;
    const n5 = /* @__PURE__ */ new Set();
    for (let i4 = 0; i4 < s4.length; i4++) {
      const t8 = s4[i4], o5 = t8.objectId, r3 = this._graphics.get(o5);
      if (r3) {
        n5.add(o5), t8 !== r3 && (s4[i4] = r3);
        const d2 = this._duplicates.get(o5);
        d2 ? d2.push(e3) : this._duplicates.set(o5, [r3.nodeIndex, e3]);
      } else
        t8.nodeIndex = e3, this._graphics.set(o5, t8);
    }
    n5.size && this._updateForeignGraphics(t7);
    const o4 = n5.size > 0 ? s4.filter((e4) => !n5.has(e4.objectId)) : s4;
    o4.length > 0 && this.emit("change", { added: o4, removed: [] });
  }
  removeNode(e3) {
    const t7 = this._nodes.get(e3);
    if (!t7)
      return void console.error("Removing unknown node");
    this._nodes.delete(e3);
    const s4 = /* @__PURE__ */ new Set(), n5 = [];
    for (const o4 of t7.graphics) {
      const t8 = o4.objectId, i4 = this._graphics.get(t8);
      if (!i4)
        continue;
      const r3 = this._duplicates.get(t8);
      if (r3) {
        const n6 = r3.indexOf(e3);
        if (-1 === n6) {
          console.error("error: removing graphic from node that should not reference it.");
          continue;
        }
        if (r3.splice(n6, 1), i4.nodeIndex === e3) {
          let e4 = this.getNode(r3[0]);
          for (let t9 = 1; t9 < r3.length; t9++) {
            const s5 = this.getNode(r3[t9]);
            (null == e4 || null != s5 && s5.node.level > e4.node.level) && (e4 = s5);
          }
          null != e4 && s4.add(e4);
        }
        1 === r3.length && this._duplicates.delete(t8);
      } else
        this._graphics.delete(t8), n5.push(o4);
    }
    n5.length > 0 && this.emit("change", { added: [], removed: n5 }), s4.forEach((e4) => this._updateForeignGraphics(e4));
  }
  _updateForeignGraphics(e3) {
    const t7 = [], s4 = e3.node.index, n5 = e3.node.level;
    let o4 = 0;
    for (; o4 < e3.graphics.length; ) {
      const i4 = e3.graphics[o4].nodeIndex;
      if (i4 === s4) {
        o4++;
        continue;
      }
      let r3 = 1;
      for (; o4 + r3 < e3.graphics.length && e3.graphics[o4 + r3].nodeIndex === i4; )
        r3++;
      const d2 = this.getNode(i4);
      if (null != d2 && d2.node.level > n5)
        o4 += r3;
      else {
        for (let n6 = o4; n6 < o4 + r3; n6++) {
          const o5 = e3.graphics[n6];
          o5.nodeIndex = s4, this._updateAndCompare(o5, e3, n6) && t7.push(o5);
        }
        o4 += r3;
      }
    }
    this._notifyUpdated(t7);
  }
  toArray() {
    return Array.from(this._graphics.values());
  }
  find(e3) {
    let s4;
    return n(this._graphics, (t7) => !!e3(t7) && (s4 = t7, true)), s4;
  }
  forEach(e3) {
    this._graphics.forEach((t7) => e3(t7));
  }
  forEachNode(e3) {
    this._nodes.forEach((t7, s4) => e3(t7, s4));
  }
  get nodeCount() {
    return this._nodes.size;
  }
  _checkInvariants() {
    const e3 = /* @__PURE__ */ new Map();
    this._nodes.forEach((t8, s4) => {
      s4 !== t8.node.index && console.error("Mismatched node index"), t8.graphics.forEach((t9) => {
        e3.set(t9.objectId, 1 + (e3.get(t9.objectId) ?? 0));
        const n5 = this._duplicates.get(t9.objectId);
        n5 && !n5.includes(s4) && console.error("Node not listed in duplicate list"), n5 || t9.nodeIndex === s4 || console.error("Unique graphic does not reference owning node index");
      });
    }), this._graphics.size !== e3.size && console.error("Mismatch between actual and expected number of graphics");
    let t7 = 0;
    e3.forEach((e4, s4) => {
      t7 += e4 > 1 ? 1 : 0;
      const n5 = this._graphics.get(s4);
      if (!n5)
        return void console.error("Missing graphic entry");
      const o4 = this._nodes.get(n5.nodeIndex);
      if (!o4)
        return void console.error("Graphic references unkown node");
      const i4 = this._duplicates.get(s4);
      i4 ? (i4.length !== e4 && console.error("Wrong number of entries in duplicate list"), i4.forEach((e5) => {
        const t8 = this._nodes.get(e5);
        t8 ? t8.node.level > o4.node.level && console.error("Duplicated graphic does not reference highest level node") : console.error("Unknown node in duplicate list");
      })) : e4 > 1 && console.error("Missing duplicates entry");
    }), this._duplicates.size !== t7 && console.error("Mismatch between expected and actual number of duplicate entries");
  }
};

// node_modules/@arcgis/core/views/3d/layers/SceneLayerGraphicsView3D.js
var J = i3();
var X = class {
  constructor(e3, t7, r3, i4) {
    this.graphics = e3, this.featureIds = t7, this.attributeInfo = r3, this.node = i4;
  }
};
var ee2 = class extends t6(i2(n4(j))) {
  constructor() {
    super(...arguments), this.type = "scene-layer-graphics-3d", this._queryEngine = null, this._memCache = null, this._interactiveEditingSessions = /* @__PURE__ */ new Map(), this.loadedGraphics = new s3((e3, t7, r3) => se(e3, t7, r3), (e3) => this.processor.graphicsCore.recreateGraphics(e3)), this.holeFilling = "always", this.progressiveLoadFactor = 1, this.supportsHeightUnitConversion = true, this._coordinatesOutsideExtentErrors = 0, this._maxCoordinatesOutsideExtentErrors = 20;
  }
  tryRecycleWith(e3, t7) {
    return e3.url === this.layer.url && this._i3sOverrides.isEmpty ? e3.load(t7).then(() => {
      var _a;
      ye(this.layer, e3, this._i3sOverrides), this.layer = e3, this._i3sOverrides.destroy();
      const t8 = (_a = this.view.resourceController) == null ? void 0 : _a.memoryController;
      this._i3sOverrides = new D({ view: this.view, layer: e3, memoryController: t8 }), l(this._queryEngine), this._setupQueryEngine(), this.processor.resetObjectStates();
    }) : null;
  }
  initialize() {
    var _a, _b;
    this.addResolvingPromise(this.layer.indexInfo);
    const e3 = (_a = this.view.resourceController) == null ? void 0 : _a.memoryController;
    this._i3sOverrides = new D({ view: this.view, layer: this.layer, memoryController: e3 }), ge(this.layer, this.view.spatialReference, this.view.viewingMode), this._fieldsHelper = new p({ layerView: this }), this.updatingHandles.add(() => this.layer.rangeInfos, (e4) => this._rangeInfosChanged(e4), h), this.updatingHandles.add(() => this.layer.renderer, (e4, t7) => this._rendererChange(e4, t7)), this.updatingHandles.add(() => [this.parsedDefinitionExpression, this._excludeObjectIdsSorted], () => this._filterChange()), this.handles.add(l2(() => t4.I3S_TREE_SHOW_TILES, (e4) => {
      if (e4 && !this._treeDebugger) {
        const e5 = this._controller.crsIndex;
        import("./I3STreeDebugger-WDRBTLK7.js").then(({ I3STreeDebugger: t7 }) => {
          !this._treeDebugger && t4.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t7({ lv: this, view: this.view, nodeSR: e5 }));
        });
      } else
        e4 || !this._treeDebugger || t4.I3S_TREE_SHOW_TILES || (this._treeDebugger.destroy(), this._treeDebugger = null);
    }, h)), this._set("processor", new _({ owner: this, preferredUpdatePolicy: C.ASYNC, scaleVisibilityEnabled: true, filterVisibilityEnabled: true, timeExtentEnabled: false, frustumVisibilityEnabled: false, elevationAlignmentEnabled: true, elevationFeatureExpressionEnabled: false, setUidToIdOnAdd: false, dataExtent: this.layer.fullExtent, updateClippingExtent: (e4) => this._updateClippingExtent(e4) })), (_b = this.processor.elevationAlignment) == null ? void 0 : _b.events.on("invalidate-elevation", (e4) => this._controller.updateElevationChanged(e4.extent, e4.spatialReference)), this.supportsHeightUnitConversion && (this._verticalScale = t("point", this.layer.spatialReference, this.view.spatialReference)), this.addResolvingPromise(this.processor.initializePromise), this._memCache = this.view.resourceController.memoryController.newCache(`psl-${this.uid}`), this._controller = new ee({ layerView: this, scaleVisibilityEnabled: false }), Z2(this.layer.geometryDefinitions) && (this._worker = new r2((e4) => this.view.resourceController.immediate.schedule(e4))), this.handles.add(this.layer.on("apply-edits", (e4) => this.updatingHandles.addPromise(e4.result))), this.handles.add(this.layer.on("edits", (e4) => this._handleEdits(e4))), this.when(() => {
      this._setupQueryEngine(), this.updatingHandles.add(() => this.maximumNumberOfFeatures, (e4) => this._controller.featureTarget = e4, h), this.updatingHandles.add(() => this.suspended, (e4) => {
        e4 && this._removeAllNodeData();
      });
    });
  }
  destroy() {
    this._treeDebugger = l(this._treeDebugger), this._i3sOverrides = l(this._i3sOverrides), this._set("processor", l(this.processor)), this._controller = l(this._controller), this._queryEngine = l(this._queryEngine), this._worker = l(this._worker), this._memCache = l(this._memCache), this.loadedGraphics.clear(), this._fieldsHelper = l(this._fieldsHelper);
  }
  get i3slayer() {
    return this.layer;
  }
  get updatingProgressValue() {
    var _a;
    return ((_a = this._controller) == null ? void 0 : _a.updatingProgress) ?? 1;
  }
  get requiredFields() {
    var _a;
    return ((_a = this._fieldsHelper) == null ? void 0 : _a.requiredFields) ?? [];
  }
  get maximumNumberOfFeatures() {
    var _a, _b;
    const e3 = (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.displayFeatureLimit;
    return (e3 == null ? void 0 : e3.maximumNumberOfFeatures) ?? 0;
  }
  set maximumNumberOfFeatures(e3) {
    null != e3 ? (this._override("maximumNumberOfFeatures", e3), this._controller.fixedFeatureTarget = true) : (this._clearOverride("maximumNumberOfFeatures"), this._controller.fixedFeatureTarget = false);
  }
  get maximumNumberOfFeaturesExceeded() {
    var _a;
    return !this.suspended && (!!((_a = this._controller) == null ? void 0 : _a.useMaximumNumberOfFeatures) && !this._controller.leavesReached);
  }
  get _excludeObjectIdsSorted() {
    const e3 = this.layer.excludeObjectIds;
    return e3.length ? e3.toArray().sort((e4, t7) => e4 - t7) : null;
  }
  get lodFactor() {
    return "Labels" === this.layer.semantic ? 1 : this.view.qualitySettings.sceneService.point.lodFactor;
  }
  get hasM() {
    return false;
  }
  get hasZ() {
    return true;
  }
  get contentVisible() {
    var _a;
    return !this.suspended && !!((_a = this._controller) == null ? void 0 : _a.rootNodeVisible);
  }
  get legendEnabled() {
    var _a;
    return this.contentVisible && true === ((_a = this.i3slayer) == null ? void 0 : _a.legendEnabled);
  }
  async whenGraphicAttributes(e3, t7) {
    return ne(this.layer, e3, this._getObjectIdField(), t7, () => [...this.loadedGraphics.nodes()]);
  }
  getHit(e3) {
    if (!this.loadedGraphics)
      return null;
    const t7 = c(this.loadedGraphics.find((t8) => t8.uid === e3), this.layer), r3 = this._getObjectIdField();
    return t7 && t7.attributes && t7.attributes[r3] ? (t7.layer = this.layer, t7.sourceLayer = this.layer, { type: "graphic", graphic: t7, layer: t7.layer }) : null;
  }
  whenGraphicBounds(e3, t7) {
    return this.processor.whenGraphicBounds(e3, t7);
  }
  computeAttachmentOrigin(e3, t7) {
    return this.processor.computeAttachmentOrigin(e3, t7);
  }
  isUpdating() {
    var _a, _b, _c;
    return !!(((_a = this._controller) == null ? void 0 : _a.updating) || ((_b = this.processor) == null ? void 0 : _b.updating) || ((_c = this._fieldsHelper) == null ? void 0 : _c.updating) || this.layerFilterUpdating);
  }
  highlight(e3) {
    return this.processor.highlight(e3, this.layer.objectIdField);
  }
  get updatePolicy() {
    return this.processor.graphicsCore.effectiveUpdatePolicy;
  }
  createInteractiveEditSession(e3) {
    return r(this._attributeEditingContext, e3);
  }
  async _decompressBinaryPointData(e3, t7) {
    const r3 = { geometryBuffer: e3.geometryBuffer };
    null == this._worker && (this._worker = new r2((e4) => this.view.resourceController.immediate.schedule(e4)));
    const i4 = await this._worker.invoke(r3, t7);
    if (null == i4)
      throw new Error("Failed to decompress Draco point data");
    return { positionData: i4.positions, featureIds: i4.featureIds };
  }
  async addNode(e3, t7, r3) {
    var _a;
    if (!ie(t7) && !re(t7))
      throw new Error();
    if (this.loadedGraphics.hasNode(e3.index))
      return void s.getLogger(this).error("I3S node " + e3.id + " already added");
    const s4 = null != this.layer.fullExtent ? ae(this.layer.fullExtent.clone(), 0.5) : null, o4 = [], { featureIds: a2, pointPositions: n5 } = ie(t7) ? await this._extractBinaryPointPositions(e3, t7, r3) : this._extractLegacyPointPositions(t7);
    this._validatePositions(e3, a2, n5, s4, o4);
    const l4 = this._controller.crsVertex, d2 = this.view.spatialReference;
    yn(n5, l4, 0, n5, d2, 0, a2.length);
    const u = ie(t7) ? e3.level : 0, h4 = this._createGraphics(a2, n5, e3.index, u), p2 = new X(h4, a2, t7.attributeDataInfo, e3);
    if (await this._i3sOverrides.applyAttributeOverrides(p2.featureIds, t7.attributeDataInfo, r3), e3.numFeatures = p2.graphics.length, this._updateNodeMemory(e3), oe(p2), o4.length > 0 && (this._computeObb(e3, o4, l4), this._controller.updateVisibility(e3.index)), !this._controller.isGeometryVisible(e3))
      return void this._cacheNodeData(p2);
    if (null != this._verticalScale)
      for (const i4 of p2.graphics)
        this._verticalScale(i4.geometry);
    const g = this.view._stage.renderView.objectAndLayerIdRenderHelper;
    if (null != g) {
      const e4 = m2(this.view.map, this.layer.uid);
      for (let t8 = 0; t8 < p2.featureIds.length; t8++) {
        const r4 = p2.featureIds[t8];
        g.setUidToObjectAndLayerId(r4, p2.graphics[t8].uid, this.layer.id, this.layer.uid, this.layer.popupEnabled && !e4 && t3(this.layer, (_a = this.view.popup) == null ? void 0 : _a.defaultPopupTemplateEnabled), p2.node.resources.attributes, t8);
      }
    }
    this.loadedGraphics.addNode(e3.index, p2), this._controller.updateLoadStatus(e3.index, true), this._filterNode(p2), this._treeDebugger && this._treeDebugger.update();
  }
  _computeObb(e3, t7, r3) {
    const i4 = this._controller.crsIndex, s4 = i4.isGeographic ? this.view.renderSpatialReference : i4;
    yn(t7, r3, 0, t7, s4, 0, t7.length / 3), e3.serviceObb = R(new s2(t7, 3)), i4.isGeographic && Hn(e3.serviceObb.center, s4, e3.serviceObb.center, i4);
  }
  isNodeLoaded(e3) {
    return this.loadedGraphics.hasNode(e3);
  }
  isNodeReloading() {
    return false;
  }
  updateNodeState() {
  }
  async _extractBinaryPointPositions(e3, t7, r3) {
    const i4 = await this._decompressBinaryPointData(t7, r3), s4 = i4.positionData, o4 = 3, a2 = s4.length / o4, n5 = t2(3 * a2), l4 = null != e3.serviceObb ? e3.serviceObb.center : [0, 0, 0], d2 = Math.abs(l4[2]) * 2 ** -20;
    for (let u = 0; u < a2; u++) {
      const e4 = u * o4;
      n5[e4] = s4[e4] + l4[0], n5[e4 + 1] = s4[e4 + 1] + l4[1], n5[e4 + 2] = s4[e4 + 2] + l4[2], Math.abs(n5[e4 + 2]) < d2 && (n5[e4 + 2] = 0);
    }
    return { featureIds: i4.featureIds ? e2(i4.featureIds) : [], pointPositions: n5 };
  }
  _extractLegacyPointPositions(e3) {
    var _a, _b;
    const t7 = e3.pointData.length, r3 = t2(3 * t7), i4 = new Array();
    for (let s4 = 0; s4 < t7; s4++) {
      const t8 = e3.pointData[s4], o4 = t8.featureDataPosition, a2 = o4.length, n5 = ((_a = t8.geometries) == null ? void 0 : _a[0]) ?? ne2[a2], l4 = t8.featureIds[0];
      if ("Embedded" !== n5.type || "points" !== n5.params.type || a2 < 2 || a2 > 3)
        continue;
      const d2 = ((_b = n5.params.vertexAttributes) == null ? void 0 : _b.position) ?? [0, 0, 0], u = 3 * i4.length;
      r3[u] = o4[0] + d2[0], r3[u + 1] = o4[1] + d2[1], r3[u + 2] = 3 === a2 ? o4[2] + d2[2] : NaN, i4.push(l4);
    }
    return { featureIds: i4, pointPositions: r3 };
  }
  _validatePositions(e3, t7, r3, s4, o4) {
    if (null == s4 && e3.serviceObb)
      return;
    const a2 = t7.length, n5 = 3;
    for (let l4 = 0; l4 < a2; l4++) {
      const t8 = l4 * n5;
      o2(le, r3[t8], r3[t8 + 1], r3[t8 + 2]);
      const a3 = !Number.isNaN(r3[2]);
      null == s4 || (a3 ? o(s4, le) : i(s4, le)) || (this._coordinatesOutsideExtentErrors < this._maxCoordinatesOutsideExtentErrors && s.getLogger(this).error("Service Error: Coordinates outside of layer extent"), this._coordinatesOutsideExtentErrors + 1 === this._maxCoordinatesOutsideExtentErrors && s.getLogger(this).error("Maximum number of errors reached. Further errors are ignored."), this._coordinatesOutsideExtentErrors++), e3.serviceObb || o4.push(le[0], le[1], le[2]);
    }
  }
  _createGraphics(e3, r3, i4, s4) {
    const o4 = e3.length, a2 = 3, n5 = this._getObjectIdField(), l4 = this.processor.graphicsCore, d2 = new Array(), u = this.view.spatialReference;
    for (let h4 = 0; h4 < o4; h4++) {
      const o5 = e3[h4], c3 = {};
      null != o5 && (c3[n5] = o5);
      const p2 = o5 ?? h3.generateUID(), g = h4 * a2, m3 = isNaN(r3[g + 2]) ? void 0 : r3[g + 2], y2 = Z(r3[g], r3[g + 1], m3, u), f = this.loadedGraphics.get(p2);
      if (null != f)
        (null == f.level || f.level < s4) && (de.property = "geometry", de.graphic = f, de.oldValue = f.geometry, de.newValue = y2, f.geometry = y2, f.level = s4, l4.graphicUpdateHandler(de)), d2.push(f);
      else {
        const e4 = h3.generateUID();
        d2.push({ objectId: p2, uid: e4, geometry: y2, attributes: c3, visible: true, nodeIndex: i4, level: s4 });
      }
    }
    return d2;
  }
  _updateNodeMemory(e3) {
    e3.memory = 4096 + (null != e3.numFeatures ? e3.numFeatures * this.processor.graphicsCore.usedMemoryPerGraphic : 0);
  }
  _cacheNodeData(e3) {
    const t7 = e3.graphics.reduce((e4, t8) => M(t8) + e4, m(e3.featureIds) + 1024);
    this._memCache.put(this._getMemCacheKey(e3.node), e3, t7);
  }
  _getMemCacheKey(e3) {
    return `${e3.index}`;
  }
  _removeAllNodeData() {
    this.loadedGraphics.forEachNode((e3, t7) => {
      if (e3) {
        const t8 = e3.node;
        this._updateNodeMemory(t8), this._cacheNodeData(e3);
      }
      this._controller.updateLoadStatus(t7, false);
    }), this._treeDebugger && this._treeDebugger.update(), this.loadedGraphics.clear();
  }
  removeNode(e3) {
    const t7 = this._removeNodeStageData(e3);
    t7 && (this._updateNodeMemory(t7.node), this._cacheNodeData(t7));
  }
  _removeNodeStageData(e3) {
    const t7 = this.loadedGraphics.getNode(e3);
    return null == t7 ? null : (this._controller.updateLoadStatus(e3, false), this.loadedGraphics.removeNode(e3), this._treeDebugger && this._treeDebugger.update(), t7);
  }
  async loadCachedNodeData(e3) {
    var _a;
    return (_a = this._memCache) == null ? void 0 : _a.pop(this._getMemCacheKey(e3));
  }
  async addCachedNodeData(e3, t7, r3, s4) {
    this.loadedGraphics.hasNode(e3.index) ? s.getLogger(this).error("I3S node " + e3.id + " already added") : (await this._i3sOverrides.applyAttributeOverrides(t7.featureIds, r3, s4), this.loadedGraphics.addNode(e3.index, t7), this._controller.updateLoadStatus(e3.index, true), this._updateNodeMemory(e3), t7.attributeInfo = r3, this._attributeValuesChanged(t7), this._filterNode(t7), this._treeDebugger && this._treeDebugger.update());
  }
  getLoadedNodeIds() {
    const e3 = [];
    return this.loadedGraphics.forEachNode((t7) => e3.push(t7.node.id)), e3.sort();
  }
  getVisibleNodes() {
    const e3 = new Array();
    return this.loadedGraphics.forEachNode((t7) => e3.push(t7.node)), e3;
  }
  getLoadedNodeIndices(e3) {
    this.loadedGraphics.forEachNode((t7, r3) => e3.push(r3));
  }
  getLoadedAttributes(e3) {
    const t7 = this.loadedGraphics.getNode(e3);
    if (null != t7 && null != t7.attributeInfo)
      return t7.attributeInfo.loadedAttributes;
  }
  getAttributeData(e3) {
    const t7 = this.loadedGraphics.getNode(e3);
    if (null != t7 && null != t7.attributeInfo)
      return t7.attributeInfo.attributeData;
  }
  _setAttributeData(e3, t7) {
    const r3 = this.loadedGraphics.getNode(e3);
    null != r3 && null != r3.attributeInfo && (r3.attributeInfo.attributeData = t7, this._attributeValuesChanged(r3));
  }
  async updateAttributes(e3, t7, r3) {
    const i4 = this.loadedGraphics.getNode(e3);
    null != i4 && (await this._i3sOverrides.applyAttributeOverrides(i4.featureIds, t7, r3), i4.attributeInfo = t7, this._attributeValuesChanged(i4));
  }
  _attributeValuesChanged(e3) {
    if (oe(e3), this._filterNode(e3), this.processor.graphicsCore.labelsEnabled) {
      const t7 = e3.graphics.map((e4) => e4.uid);
      this.processor.graphicsCore.updateLabelingInfo(t7);
    }
  }
  _updateClippingExtent(e3) {
    return this._controller && this._controller.updateClippingArea(e3), false;
  }
  _getObjectIdField() {
    return this.layer.objectIdField || o3;
  }
  _getGlobalIdField() {
    var _a;
    return (_a = this.layer.associatedLayer) == null ? void 0 : _a.globalIdField;
  }
  async _rendererChange(e3, t7) {
    const { layer: { fieldsIndex: r3 } } = this, i4 = /* @__PURE__ */ new Set();
    let s4, o4;
    e3 ? (await e3.collectRequiredFields(i4, r3), s4 = Array.from(i4).sort()) : s4 = [], i4.clear(), t7 ? (await t7.collectRequiredFields(i4, r3), o4 = Array.from(i4).sort()) : o4 = [], s4.length === o4.length && s4.every((e4, t8) => s4[t8] === o4[t8]) || this._reloadAllNodes();
  }
  _rangeInfosChanged(e3) {
    null != e3 && e3.length > 0 && s.getLogger(this).warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.");
  }
  _filterChange() {
    this.loadedGraphics.forEachNode((e3) => this._filterNode(e3));
  }
  _reloadAllNodes() {
    this._removeAllNodeData(), this._controller && this._controller.restartNodeLoading();
  }
  _filterNode(e3) {
    const t7 = this.parsedDefinitionExpression, i4 = this._excludeObjectIdsSorted, s4 = this._getObjectIdField();
    for (const o4 of e3.graphics) {
      const e4 = o4.visible, a2 = !t7 || this._evaluateClause(t7, o4), n5 = null == i4 || x(i4, o4.attributes[s4]) < 0;
      o4.visible = a2 && n5, e4 !== o4.visible && (de.graphic = o4, de.property = "visible", de.oldValue = e4, de.newValue = o4.visible, this.processor.graphicsCore.graphicUpdateHandler(de));
    }
  }
  createQuery() {
    const e3 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
    return null != this.filter ? this.filter.createQuery(e3) : new b(e3);
  }
  queryFeatures(e3, t7) {
    return this._queryEngine.executeQuery(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  queryObjectIds(e3, t7) {
    return this._queryEngine.executeQueryForIds(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  queryFeatureCount(e3, t7) {
    return this._queryEngine.executeQueryForCount(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  queryExtent(e3, t7) {
    return this._queryEngine.executeQueryForExtent(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  _ensureQuery(e3) {
    return this._addDefinitionExpressionToQuery(null == e3 ? this.createQuery() : b.from(e3));
  }
  _setupQueryEngine() {
    const e3 = () => this.processor.featureStore;
    this._queryEngine = new c2({ context: { spatialReference: this.view.spatialReference, layer: this.layer, scheduler: this.view.resourceController.scheduler, get featureStore() {
      return e3();
    }, hasZ: this.hasZ, hasM: this.hasM }, priority: I.FEATURE_QUERY_ENGINE });
  }
  get usedMemory() {
    var _a, _b;
    return ((_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.usedMemory) ?? 0;
  }
  get unloadedMemory() {
    var _a, _b, _c;
    return 0.8 * ((((_a = this._controller) == null ? void 0 : _a.unloadedMemoryEstimate) ?? 0) + (((_c = (_b = this.processor) == null ? void 0 : _b.graphicsCore) == null ? void 0 : _c.unprocessedMemoryEstimate) ?? 0));
  }
  get ignoresMemoryFactor() {
    return this._controller && this._controller.fixedFeatureTarget;
  }
  _handleEdits(e3) {
    l3(this._attributeEditingContext, e3);
  }
  get _attributeEditingContext() {
    const e3 = this._getObjectIdField(), t7 = this._getGlobalIdField();
    return { sessions: this._interactiveEditingSessions, fieldsIndex: this.layer.fieldsIndex, objectIdField: e3, globalIdField: t7, forEachNode: (e4) => this.loadedGraphics.forEachNode((t8) => e4(t8.node, t8.featureIds)), attributeStorageInfo: this.i3slayer.attributeStorageInfo ?? [], i3sOverrides: this._i3sOverrides, getAttributeData: (e4) => this.getAttributeData(e4), setAttributeData: (t8, r3, i4) => {
      this._setAttributeData(t8, r3);
      const s4 = this.loadedGraphics.getNode(t8);
      if (null != i4) {
        const t9 = this.loadedGraphics.get(i4.attributes[e3]);
        null != t9 && this.processor.graphicsCore.recreateGraphics([t9]);
      } else
        null != s4 && this.processor.graphicsCore.recreateGraphics(s4.graphics);
    }, clearMemCache: () => {
    } };
  }
  get performanceInfo() {
    const e3 = { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: this.maximumNumberOfFeatures, totalNumberOfFeatures: -1, nodes: this.loadedGraphics.nodeCount, core: this.processor.graphicsCore.performanceInfo };
    return this._controller && this._controller.updateStats(e3), e3;
  }
  get test() {
    return { controller: this._controller, numNodes: this.loadedGraphics.nodeCount, loadedGraphics: this.loadedGraphics };
  }
};
e([y()], ee2.prototype, "processor", void 0), e([y({ type: d })], ee2.prototype, "filter", void 0), e([y()], ee2.prototype, "loadedGraphics", void 0), e([y()], ee2.prototype, "i3slayer", null), e([y()], ee2.prototype, "_controller", void 0), e([y()], ee2.prototype, "updating", void 0), e([y()], ee2.prototype, "suspended", void 0), e([y()], ee2.prototype, "holeFilling", void 0), e([y(t5)], ee2.prototype, "updatingProgress", void 0), e([y()], ee2.prototype, "updatingProgressValue", null), e([y(J.requiredFields)], ee2.prototype, "requiredFields", null), e([y(J.availableFields)], ee2.prototype, "availableFields", void 0), e([y()], ee2.prototype, "_fieldsHelper", void 0), e([y({ type: Number })], ee2.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true })], ee2.prototype, "maximumNumberOfFeaturesExceeded", null), e([y()], ee2.prototype, "_excludeObjectIdsSorted", null), e([y({ readOnly: true })], ee2.prototype, "lodFactor", null), e([y({ readOnly: true })], ee2.prototype, "hasM", null), e([y({ readOnly: true })], ee2.prototype, "hasZ", null), e([y()], ee2.prototype, "contentVisible", null), e([y({ readOnly: true })], ee2.prototype, "legendEnabled", null), ee2 = e([a("esri.views.3d.layers.SceneLayerGraphicsView3D")], ee2);
var te = ee2;
function re(e3) {
  return "pointData" in e3;
}
function ie(e3) {
  return "geometryBuffer" in e3 && null !== e3.geometryBuffer;
}
function se(e3, t7, r3) {
  const i4 = t7.attributeInfo;
  if (null == i4 || null == i4.loadedAttributes || null == i4.attributeData)
    return false;
  let s4 = false;
  for (const { name: o4 } of i4.loadedAttributes)
    if (i4.attributeData[o4]) {
      const t8 = fe(i4.attributeData[o4], r3);
      t8 !== e3.attributes[o4] && (e3.attributes[o4] = t8, s4 = true);
    }
  return s4;
}
function oe(e3) {
  const t7 = e3.attributeInfo, r3 = e3.node.index;
  if (null != t7 && null != t7.loadedAttributes && null != t7.attributeData)
    for (let i4 = 0; i4 < e3.graphics.length; i4++) {
      const s4 = e3.graphics[i4];
      if (s4.nodeIndex === r3) {
        s4.attributes || (s4.attributes = {});
        for (const { name: e4 } of t7.loadedAttributes)
          t7.attributeData[e4] && (s4.attributes[e4] = fe(t7.attributeData[e4], i4));
      }
    }
}
function ae(e3, t7) {
  return e3.xmin -= t7, e3.ymin -= t7, e3.xmax += t7, e3.ymax += t7, null != e3.zmin && null != e3.zmax && (e3.zmin -= t7, e3.zmax += t7), null != e3.mmin && null != e3.mmax && (e3.mmin -= t7, e3.mmax += t7), e3;
}
var ne2 = { 2: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0] } } }, 3: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0, 0] } } } };
var le = n2();
var de = { graphic: null, property: null, oldValue: null, newValue: null };
export {
  te as default
};
//# sourceMappingURL=SceneLayerGraphicsView3D-ETQDPCQC.js.map
