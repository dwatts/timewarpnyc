import {
  v
} from "./chunk-D4OUCQGI.js";
import {
  T,
  e2 as e
} from "./chunk-XFZB3R5P.js";
import {
  n
} from "./chunk-63ERNIOV.js";
import {
  D,
  G,
  L,
  P,
  U
} from "./chunk-HLBPEADQ.js";
import {
  f
} from "./chunk-SS3YG6J3.js";
import {
  t
} from "./chunk-UYRCWUYQ.js";

// node_modules/@arcgis/core/views/webgl/rasterUtils.js
function c2(e2, s, c3 = "nearest", m3 = false) {
  var _a;
  const l2 = !(m3 && "u8" === s.pixelType), _2 = l2 ? U.FLOAT : U.UNSIGNED_BYTE, p2 = null == s.pixels || 0 === s.pixels.length ? null : l2 ? s.getAsRGBAFloat() : s.getAsRGBA(), g = (_a = e2.capabilities.textureFloat) == null ? void 0 : _a.textureFloatLinear, A2 = new e();
  return A2.width = s.width, A2.height = s.height, A2.internalFormat = e2.type === n.WEBGL2 && l2 ? P.RGBA32F : G.RGBA, A2.samplingMode = !g || "bilinear" !== c3 && "cubic" !== c3 ? L.NEAREST : L.LINEAR, A2.dataType = _2, A2.wrapMode = D.CLAMP_TO_EDGE, new T(e2, A2, p2);
}
function m(e2, s) {
  const { spacing: c3, offsets: m3, coefficients: l2, size: [_2, p2] } = s, g = c3[0] > 1, A2 = new e();
  A2.width = g ? 4 * _2 : _2, A2.height = p2, A2.internalFormat = e2.type === n.WEBGL2 ? P.RGBA32F : G.RGBA, A2.dataType = U.FLOAT, A2.samplingMode = L.NEAREST, A2.wrapMode = D.CLAMP_TO_EDGE;
  const T3 = new Float32Array(g ? _2 * p2 * 16 : 2 * m3.length);
  if (g && null != l2)
    for (let t2 = 0, n2 = 0; t2 < l2.length; t2++)
      T3[n2++] = l2[t2], t2 % 3 == 2 && (T3[n2++] = 1);
  else
    for (let t2 = 0; t2 < p2; t2++)
      for (let e3 = 0; e3 < _2; e3++) {
        const n2 = 4 * (t2 * _2 + e3), r = 2 * (e3 * p2 + t2);
        T3[n2] = m3[r], T3[n2 + 1] = m3[r + 1], T3[n2 + 3] = -1 === m3[r] ? 0 : 1;
      }
  return new T(e2, A2, T3);
}
function l(e2, t2) {
  const n2 = new e();
  return n2.internalFormat = G.RGBA, n2.width = t2.length / 4, n2.height = 1, n2.samplingMode = L.NEAREST, n2.wrapMode = D.CLAMP_TO_EDGE, new T(e2, n2, t2);
}
function _(t2, n2, r, a = 1, i = true) {
  return { u_flipY: i, u_applyTransform: !!t2, u_opacity: a, u_transformSpacing: t2 ? t2.spacing : f, u_transformGridSize: t2 ? t2.size : f, u_targetImageSize: n2, u_srcImageSize: r };
}
function p(e2, t2) {
  return { u_colormapOffset: t2 || 0, u_colormapMaxIndex: e2 ? e2.length / 4 - 1 : 0 };
}
function A(e2) {
  return { u_bandCount: e2.bandCount, u_minOutput: e2.outMin, u_maxOutput: e2.outMax, u_minCutOff: e2.minCutOff, u_maxCutOff: e2.maxCutOff, u_factor: e2.factor, u_useGamma: e2.useGamma, u_gamma: e2.gamma, u_gammaCorrection: e2.gammaCorrection };
}
function T2(e2) {
  return { u_hillshadeType: e2.hillshadeType, u_sinZcosAs: e2.sinZcosAs, u_sinZsinAs: e2.sinZsinAs, u_cosZs: e2.cosZs, u_weights: e2.weights, u_factor: e2.factor, u_minValue: e2.minValue, u_maxValue: e2.maxValue };
}

// node_modules/@arcgis/core/views/3d/terrain/RasterTile.js
var u = { bandCount: 3, outMin: 0, outMax: 1, minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255], factor: [1 / 255, 1 / 255, 1 / 255], useGamma: false, gamma: [1, 1, 1], gammaCorrection: [1, 1, 1], colormap: null, colormapOffset: null, stretchType: "none", type: "stretch" };
var m2 = class {
  constructor(t2, e2, r = null, s = null) {
    this.type = "raster-tile", this._memoryUsed = null, this._source = null, this._symbolizerParameters = null, this._bandIds = null, this._interpolation = null, this._dirty = false, this._transformGrid = null, this.isRendereredSource = false, this.symbolizerRenderer = null, this.rawPixelData = null, this.lij = null, this.opacity = 1, this.lij = t2, this.source = e2, this.width = r || e2.width, this.height = s || e2.height;
  }
  get source() {
    return this._source;
  }
  set source(e2) {
    this._source = e2, this._rasterTexture = t(this._rasterTexture), this._memoryUsed = null;
  }
  get symbolizerParameters() {
    return this.isRendereredSource ? { ...u, maxCutOff: [1, 1, 1], factor: [1, 1, 1] } : this._symbolizerParameters || u;
  }
  set symbolizerParameters(t2) {
    this._symbolizerParameters = t2;
  }
  get bandIds() {
    return this._bandIds;
  }
  set bandIds(t2) {
    if (null != t2 && t2.length > 0) {
      this._bandIds && t2.every((t3, e2) => {
        var _a;
        return !!((_a = this._bandIds) == null ? void 0 : _a[e2]) && t3 === this._bandIds[e2];
      }) || (this._bandIds = t2, this._dirty = true);
    } else
      this._bandIds = null;
  }
  get interpolation() {
    return this._interpolation || "nearest";
  }
  set interpolation(t2) {
    if (this._interpolation = t2, null != this._rasterTexture) {
      const e2 = this._getRasterTextureInterpolation(t2);
      this._rasterTexture.setSamplingMode("bilinear" === e2 ? L.LINEAR : L.NEAREST);
    }
  }
  get transformGrid() {
    return this._transformGrid;
  }
  set transformGrid(e2) {
    this._transformGrid = e2, this._transformGridTexture = t(this._transformGridTexture), this._memoryUsed = null;
  }
  bind(t2) {
    return !!(this.source && this.source.pixels && this.source.pixels.length > 0) && ((null == this._rasterTexture || this._dirty) && this._updateRasterTexture(t2, this.bandIds), null != this._rasterTexture && (this._updateColormapTexture(t2), this.transformGrid && null == this._transformGridTexture && (this._transformGridTexture = m(t2, this.transformGrid))), true);
  }
  getUniforms() {
    const { symbolizerParameters: t2, transformGrid: r, width: s, height: h, opacity: n2 } = this, u2 = _(r, [s, h], [this.source.width, this.source.height], n2), m3 = p(t2.colormap, t2.colormapOffset), d = "stretch" === this.symbolizerParameters.type ? A(this.symbolizerParameters) : null, _2 = "hillshade" === this.symbolizerParameters.type ? T2(this.symbolizerParameters) : null;
    return new v(u2, m3, d || _2, this._rasterTexture, this._transformGridTexture, this._colormapTexture);
  }
  get isBilinearWithStretchColorRamp() {
    const { symbolizerParameters: t2 } = this;
    return "bilinear" === this.interpolation && null != t2.colormap && "stretch" === t2.type;
  }
  get memoryUsage() {
    if (null == this._memoryUsed) {
      const t2 = [this._rasterTexture, this._transformGridTexture, this._colormapTexture];
      this._memoryUsed = t2.map((t3) => null != t3 ? t3.descriptor.width * t3.descriptor.height * 4 : 0).reduce((t3, e2) => t3 + e2, 0);
    }
    return this._memoryUsed;
  }
  release() {
    return this._rasterTexture = t(this._rasterTexture), this._transformGridTexture = t(this._transformGridTexture), this._colormapTexture = t(this._colormapTexture), this.source = null, this.transformGrid = null, this.rawPixelData = null, true;
  }
  _updateRasterTexture(e2, r) {
    const s = this.source ? this.source.extractBands(r) : null;
    if (!(s && s.pixels && s.pixels.length > 0))
      return void (this._rasterTexture = t(this._rasterTexture));
    const i = null == r && null == this.bandIds || null != r && null != this.bandIds && r.join("") === this.bandIds.join("");
    if (null != this._rasterTexture && i)
      return;
    this._rasterTexture = t(this._rasterTexture);
    const o = this._getRasterTextureInterpolation(this.interpolation);
    this._rasterTexture = c2(e2, s, o, this.isRendereredSource || this.hasStretchTypeNone());
  }
  hasStretchTypeNone() {
    return "stretchType" in this.symbolizerParameters && "none" === this.symbolizerParameters.stretchType && !this.symbolizerParameters.useGamma && "u8" === this.source.pixelType;
  }
  _getRasterTextureInterpolation(t2) {
    return "lut" === this.symbolizerParameters.type || "nearest" === t2 || "majority" === t2 || this.isBilinearWithStretchColorRamp ? "nearest" : "bilinear";
  }
  _updateColormapTexture(e2) {
    const r = this._colormap, s = this.symbolizerParameters.colormap;
    return s ? r ? s.length !== r.length || s.some((t2, e3) => t2 !== r[e3]) ? (this._colormapTexture = t(this._colormapTexture), this._colormapTexture = l(e2, s), void (this._colormap = s)) : void 0 : (this._colormapTexture = l(e2, s), void (this._colormap = s)) : (this._colormapTexture = t(this._colormapTexture), void (this._colormap = null));
  }
};

export {
  m2 as m
};
//# sourceMappingURL=chunk-HM64G5CG.js.map
