import {
  _,
  i
} from "./chunk-J2NHIS7S.js";
import {
  $,
  d,
  k
} from "./chunk-7FY52GZ6.js";
import {
  I,
  L2 as L,
  R2 as R,
  U2 as U,
  W,
  f2 as f,
  h2 as h,
  j,
  m2 as m,
  s5 as s2,
  u2 as u,
  u4 as u2
} from "./chunk-F5EKF66B.js";
import "./chunk-2735WBYK.js";
import "./chunk-V4EIGIRT.js";
import {
  s2 as s
} from "./chunk-2NXAWKLI.js";
import "./chunk-AUKNAK3D.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-W3WHCGIQ.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import {
  M
} from "./chunk-T35GN7EL.js";
import {
  x2 as x
} from "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import "./chunk-453UIKKW.js";
import "./chunk-5BLDWPLW.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import "./chunk-UYRCWUYQ.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var N = class {
  convertVectorFieldData(r) {
    const t = u.fromJSON(r.pixelBlock), s3 = f(t, r.type);
    return Promise.resolve(null != s3 ? s3.toJSON() : null);
  }
  computeStatisticsHistograms(r) {
    const t = u.fromJSON(r.pixelBlock), s3 = m(t);
    return Promise.resolve(s3);
  }
  async decode(r) {
    const e = await j(r.data, r.options);
    return e && e.toJSON();
  }
  symbolize(r) {
    r.pixelBlock = u.fromJSON(r.pixelBlock), r.extent = r.extent ? M.fromJSON(r.extent) : null;
    const t = this.symbolizer.symbolize(r);
    return Promise.resolve(null != t ? t.toJSON() : null);
  }
  async updateSymbolizer(r) {
    var _a;
    this.symbolizer = L.fromJSON(r.symbolizerJSON), r.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r.histograms);
  }
  async updateRasterFunction(r) {
    this.rasterFunction = _(r.rasterFunctionJSON);
  }
  async process(r) {
    var _a;
    const t = this.rasterFunction.process({ extent: M.fromJSON(r.extent), primaryPixelBlocks: r.primaryPixelBlocks.map((r2) => null != r2 ? u.fromJSON(r2) : null), primaryPixelSizes: (_a = r.primaryPixelSizes) == null ? void 0 : _a.map((r2) => null != r2 ? x.fromJSON(r2) : null), primaryRasterIds: r.primaryRasterIds });
    return null != t ? t.toJSON() : null;
  }
  stretch(r) {
    const t = this.symbolizer.simpleStretch(u.fromJSON(r.srcPixelBlock), r.stretchParams);
    return Promise.resolve(null != t && t.toJSON());
  }
  estimateStatisticsHistograms(r) {
    const t = h(u.fromJSON(r.srcPixelBlock));
    return Promise.resolve(t);
  }
  split(r) {
    const t = W(u.fromJSON(r.srcPixelBlock), r.tileSize, r.maximumPyramidLevel);
    return t && t.forEach((r2, e) => {
      t.set(e, r2 == null ? void 0 : r2.toJSON());
    }), Promise.resolve(t);
  }
  async mosaicAndTransform(r) {
    const t = r.srcPixelBlocks.map((r2) => r2 ? new u(r2) : null), s3 = U(t, r.srcMosaicSize, { blockWidths: r.blockWidths, alignmentInfo: r.alignmentInfo, clipOffset: r.clipOffset, clipSize: r.clipSize });
    let a, l = s3;
    return r.coefs && (l = R(s3, r.destDimension, r.coefs, r.sampleSpacing, r.interpolation)), r.projectDirections && r.gcsGrid && (a = I(r.destDimension, r.gcsGrid), l = u2(l, r.isUV ? "vector-uv" : "vector-magdir", a)), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: a };
  }
  async createFlowMesh(r, e) {
    const t = { data: new Float32Array(r.flowData.buffer), mask: new Uint8Array(r.flowData.maskBuffer), width: r.flowData.width, height: r.flowData.height }, { vertexData: s3, indexData: o } = await s2(r.meshType, r.simulationSettings, t, e.signal);
    return { result: { vertexBuffer: s3.buffer, indexBuffer: o.buffer }, transferList: [s3.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(e) {
    const t = M.fromJSON(e.projectedExtent), s3 = M.fromJSON(e.srcBufferExtent);
    let o = null;
    e.datumTransformationSteps && (o = new s({ steps: e.datumTransformationSteps })), (e.includeGCSGrid || d(t.spatialReference, s3.spatialReference, o)) && await k();
    const i2 = e.rasterTransform ? i(e.rasterTransform) : null;
    return $({ ...e, projectedExtent: t, srcBufferExtent: s3, datumTransformation: o, rasterTransform: i2 });
  }
};
export {
  N as default
};
//# sourceMappingURL=RasterWorker-Y3WCJVFO.js.map
