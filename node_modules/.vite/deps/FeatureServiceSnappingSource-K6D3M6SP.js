import {
  y as y3
} from "./chunk-6ALQHUYM.js";
import {
  i,
  o as o4
} from "./chunk-AEMRJSQ4.js";
import "./chunk-7DIOPW5T.js";
import "./chunk-3W7W7IYY.js";
import "./chunk-G5CIXSEF.js";
import "./chunk-VIDC736D.js";
import {
  m as m2
} from "./chunk-KGLSZSEH.js";
import {
  s as s2
} from "./chunk-GFS62Z72.js";
import "./chunk-A47VN5MA.js";
import {
  $,
  W,
  as
} from "./chunk-ZFRKFGUZ.js";
import "./chunk-6YRYWMPZ.js";
import {
  h as h2
} from "./chunk-WT7BDUIR.js";
import "./chunk-TLBJBU3X.js";
import {
  Z
} from "./chunk-MXVQCJ4K.js";
import "./chunk-G4LSNP77.js";
import {
  p as p3
} from "./chunk-CUZNACFZ.js";
import {
  r
} from "./chunk-ZHUFARKQ.js";
import "./chunk-L3FCQBVC.js";
import "./chunk-NLWV7Q6F.js";
import {
  j as j2,
  p as p2
} from "./chunk-JPAY3V43.js";
import {
  t as t2
} from "./chunk-Y2ZDD3I4.js";
import "./chunk-7FNOSSSO.js";
import "./chunk-LLQMBVBO.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-MNR4BIGQ.js";
import "./chunk-IHCIS6PT.js";
import "./chunk-OHH3UAUS.js";
import {
  n
} from "./chunk-YGUWDSEH.js";
import "./chunk-WIQR3T32.js";
import "./chunk-C2EHS6UI.js";
import {
  a as a4,
  d
} from "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-C3PCK5WU.js";
import "./chunk-HE256ZWN.js";
import "./chunk-7EG7BYWF.js";
import {
  t as t3
} from "./chunk-VYGC2LVC.js";
import "./chunk-POEWD5LS.js";
import "./chunk-HTVQN75V.js";
import "./chunk-W3WHCGIQ.js";
import {
  U,
  a as a3,
  h,
  l
} from "./chunk-HPWZ2OON.js";
import "./chunk-WAPUHORU.js";
import "./chunk-HXDFHMRK.js";
import "./chunk-5HSVWQOA.js";
import "./chunk-C2BBLDPU.js";
import "./chunk-GWA3PLGA.js";
import "./chunk-FXWSVUF2.js";
import "./chunk-CNS4YGGN.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-UHAU5IXU.js";
import "./chunk-3U2FS2TT.js";
import "./chunk-CEXY22SC.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7JNPZC53.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import {
  o as o3
} from "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import "./chunk-UNJDKTFU.js";
import "./chunk-DH42JQZX.js";
import "./chunk-674HAVOZ.js";
import "./chunk-MHGDFNBE.js";
import "./chunk-J2V5CZSS.js";
import "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import "./chunk-OBGBLQQX.js";
import {
  j
} from "./chunk-FXYPEAR7.js";
import {
  a as a2,
  c
} from "./chunk-V3CNLYUD.js";
import "./chunk-TEHNQYQD.js";
import {
  o as o2
} from "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import {
  x2 as x
} from "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  m,
  t2 as t,
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import {
  e as e2,
  o
} from "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  p2 as p,
  s2 as s,
  y as y2
} from "./chunk-UYRCWUYQ.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function c2(n2, o5) {
  return $(o5.extent, e3), as(e3, o2(a5, n2.x, n2.y, 0));
}
var e3 = W();
var a5 = n();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p4 = class extends m {
  get tiles() {
    const e4 = this.tilesCoveringView, t4 = null != this.pointOfInterest ? this.pointOfInterest : this.view.center;
    return e4.sort((e5, r2) => c2(t4, e5) - c2(t4, r2)), e4;
  }
  _scaleEnabled() {
    return t3(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || null == this.tileInfo)
      return [];
    if (!this._scaleEnabled)
      return [];
    const { spans: e4, lodInfo: t4 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: r2 } = t4, i2 = [];
    for (const { row: o5, colFrom: s3, colTo: n2 } of e4)
      for (let e5 = s3; e5 <= n2; e5++) {
        const s4 = t4.normalizeCol(e5), n3 = new t2(null, r2, o5, s4);
        this.tileInfo.updateTileInfo(n3), i2.push(n3);
      }
    return i2;
  }
  get tileInfo() {
    var _a;
    return ((_a = this.view.featuresTilingScheme) == null ? void 0 : _a.tileInfo) ?? null;
  }
  get tileSize() {
    return null != this.tileInfo ? this.tileInfo.size[0] : 256;
  }
  constructor(e4) {
    super(e4), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(l(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.state) == null ? void 0 : _b.viewpoint;
    }, () => this.notifyChange("tilesCoveringView"), U));
  }
};
e([y({ readOnly: true })], p4.prototype, "tiles", null), e([y({ readOnly: true })], p4.prototype, "_scaleEnabled", null), e([y({ readOnly: true })], p4.prototype, "tilesCoveringView", null), e([y({ readOnly: true })], p4.prototype, "tileInfo", null), e([y({ readOnly: true })], p4.prototype, "tileSize", null), e([y({ constructOnly: true })], p4.prototype, "view", void 0), e([y({ constructOnly: true })], p4.prototype, "layer", void 0), e([y()], p4.prototype, "pointOfInterest", void 0), p4 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p4);

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var a6 = class extends d {
  get tiles() {
    const e4 = this.tilesCoveringView, t4 = this._effectivePointOfInterest;
    if (null != t4) {
      const r2 = e4.map((e5) => c2(t4, e5));
      for (let i2 = 1; i2 < r2.length; i2++)
        if (r2[i2 - 1] > r2[i2])
          return e4.sort((e5, r3) => c2(t4, e5) - c2(t4, r3)), e4.slice();
    }
    return e4;
  }
  get tilesCoveringView() {
    var _a, _b;
    return this._filterTiles((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tiles) == null ? void 0 : _b.toArray()).map(u);
  }
  get tileInfo() {
    var _a;
    return ((_a = this.view.featureTiles) == null ? void 0 : _a.tilingScheme.toTileInfo()) ?? null;
  }
  get tileSize() {
    var _a;
    return ((_a = this.view.featureTiles) == null ? void 0 : _a.tileSize) ?? 256;
  }
  get _effectivePointOfInterest() {
    var _a;
    const e4 = this.pointOfInterest;
    return null != e4 ? e4 : (_a = this.view.pointsOfInterest) == null ? void 0 : _a.focus.location;
  }
  constructor(e4) {
    super(e4), this.pointOfInterest = null;
  }
  initialize() {
    this.handles.add(l(() => this.view.featureTiles, (e4) => {
      this.handles.remove(f), e4 && this.handles.add(e4.addClient(), f);
    }, h));
  }
  _filterTiles(e4) {
    if (null == e4)
      return [];
    return e4.filter((e5) => Math.abs(e5.measures.screenRect[3] - e5.measures.screenRect[1]) > c3 && e5.measures.visibility === s2.VISIBLE_ON_SURFACE);
  }
};
function u({ lij: [e4, t4, r2], extent: i2 }) {
  return new t2(`${e4}/${t4}/${r2}`, e4, t4, r2, i2);
}
e([y({ readOnly: true })], a6.prototype, "tiles", null), e([y({ readOnly: true })], a6.prototype, "tilesCoveringView", null), e([y({ readOnly: true })], a6.prototype, "tileInfo", null), e([y({ readOnly: true })], a6.prototype, "tileSize", null), e([y({ constructOnly: true })], a6.prototype, "view", void 0), e([y()], a6.prototype, "pointOfInterest", void 0), e([y()], a6.prototype, "_effectivePointOfInterest", null), a6 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], a6);
var c3 = 50;
var f = "feature-tiles";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var d2 = class extends y3 {
  constructor(e4) {
    super(e4), this._handles = new t();
  }
  initialize() {
    const e4 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this._handles.add(e2(() => clearInterval(e4)));
  }
  destroy() {
    this._handles.destroy();
  }
  getTiles() {
    if (!this._debugInfo)
      return [];
    const e4 = /* @__PURE__ */ new Map(), t4 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t5) => {
      e4.set(t5.data.id, t5.featureCount);
    }), this._debugInfo.pendingTiles.forEach((r3) => {
      e4.set(r3.data.id, r3.featureCount), t4.set(r3.data.id, r3.state);
    });
    const r2 = (r3) => {
      const o6 = t4.get(r3), s3 = e4.get(r3) ?? "?";
      return o6 ? `${o6}:${s3}
${r3}` : `store:${s3}
${r3}`;
    }, o5 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e5) => {
      o5.set(e5.data.id, e5.data);
    }), this._debugInfo.pendingTiles.forEach((e5) => {
      o5.set(e5.data.id, e5.data);
    }), Array.from(o5.values()).map((e5) => ({ lij: [e5.level, e5.row, e5.col], geometry: j.fromExtent(c(e5.extent, this.view.spatialReference)), label: r2(e5.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e4) => {
      this._debugInfo = e4, this.update();
    });
  }
};
e([y({ constructOnly: true })], d2.prototype, "handle", void 0), d2 = e([a("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], d2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var l2 = class extends d {
  get updating() {
    return this.updatingHandles.updating || this._workerHandleUpdating;
  }
  constructor(e4) {
    super(e4), this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = async (e5) => {
      const t4 = [];
      for (const { points: i2 } of e5)
        for (const { z: e6 } of i2)
          t4.push(e6);
      return { elevations: t4, drapedObjectIds: /* @__PURE__ */ new Set(), failedObjectIds: /* @__PURE__ */ new Set() };
    }, this.queryForSymbologySnapping = async () => ({ candidates: [], sourceCandidateIndices: [] }), this.availability = 0, this._workerHandleUpdating = true, this._editId = 0;
  }
  destroy() {
    this._workerHandle.destroy();
  }
  initialize() {
    this._workerHandle = new p5(this.schedule, { alignElevation: async (e4, { signal: t4 }) => ({ result: await this.elevationAlignPointsInFeatures(e4.points, t4) }), getSymbologyCandidates: async (e4, { signal: t4 }) => ({ result: await this.queryForSymbologySnapping(e4, t4) }) }), this.handles.add([this._workerHandle.on("notify-updating", ({ updating: e4 }) => this._workerHandleUpdating = e4), this._workerHandle.on("notify-availability", ({ availability: e4 }) => this._set("availability", e4))]);
  }
  async setup(e4, t4) {
    var _a;
    const i2 = this._serviceInfoFromLayer(e4.layer);
    if (null == i2)
      return;
    const o5 = { configuration: this._convertConfiguration(e4.configuration), serviceInfo: i2, spatialReference: e4.spatialReference.toJSON(), hasZ: this.hasZ, elevationInfo: (_a = e4.layer.elevationInfo) == null ? void 0 : _a.toJSON() };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", o5, t4)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async configure(e4, t4) {
    const i2 = this._convertConfiguration(e4);
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", i2, t4)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async refresh(e4) {
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e4)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e4));
  }
  async fetchCandidates(e4, t4) {
    const i2 = e4.point, o5 = { distance: e4.distance, mode: e4.mode, point: Z(i2[0], i2[1], i2[2], e4.coordinateHelper.spatialReference.toJSON()), returnEdge: e4.returnEdge, returnVertex: e4.returnVertex, filter: null != e4.filter ? e4.filter.toJSON() : null };
    return this._workerHandle.invoke(o5, t4);
  }
  async updateTiles(e4, t4) {
    const i2 = { tiles: e4.tiles, tileInfo: null != e4.tileInfo ? e4.tileInfo.toJSON() : null, tileSize: e4.tileSize };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", i2, t4)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async applyEdits(e4, i2) {
    var _a, _b, _c;
    const a8 = this._editId++, r2 = { id: a8 };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits", r2, i2));
    const n2 = await this.updatingHandles.addPromise(p(e4.result, i2)), s3 = { id: a8, edits: { addedFeatures: ((_a = n2.addedFeatures) == null ? void 0 : _a.map(({ objectId: e5 }) => e5).filter(R)) ?? [], deletedFeatures: ((_b = n2.deletedFeatures) == null ? void 0 : _b.map(({ objectId: e5, globalId: t4 }) => ({ objectId: e5, globalId: t4 }))) ?? [], updatedFeatures: ((_c = n2.updatedFeatures) == null ? void 0 : _c.map(({ objectId: e5 }) => e5).filter(R)) ?? [] } };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits", s3, i2)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, i2));
  }
  getDebugInfo(e4) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e4);
  }
  async notifyElevationSourceChange() {
    await this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
  }
  async notifySymbologyChange() {
    await this._workerHandle.invokeMethod("notifySymbologyChange", {});
  }
  async setSymbologySnappingSupported(e4) {
    await this._workerHandle.invokeMethod("setSymbologySnappingSupported", e4);
  }
  _convertConfiguration(e4) {
    return { filter: null != e4.filter ? e4.filter.toJSON() : null, customParameters: e4.customParameters, viewType: e4.viewType };
  }
  _serviceInfoFromLayer(e4) {
    var _a, _b;
    return "multipatch" === e4.geometryType || "mesh" === e4.geometryType ? null : { url: ((_a = e4.parsedUrl) == null ? void 0 : _a.path) ?? "", fields: e4.fields.map((e5) => e5.toJSON()), geometryType: o3.toJSON(e4.geometryType), capabilities: e4.capabilities, objectIdField: e4.objectIdField, globalIdField: e4.globalIdField, spatialReference: e4.spatialReference.toJSON(), timeInfo: (_b = e4.timeInfo) == null ? void 0 : _b.toJSON() };
  }
};
e([y({ constructOnly: true })], l2.prototype, "schedule", void 0), e([y({ constructOnly: true })], l2.prototype, "hasZ", void 0), e([y({ constructOnly: true })], l2.prototype, "elevationAlignPointsInFeatures", void 0), e([y({ constructOnly: true })], l2.prototype, "queryForSymbologySnapping", void 0), e([y({ readOnly: true })], l2.prototype, "updating", null), e([y({ readOnly: true })], l2.prototype, "availability", void 0), e([y()], l2.prototype, "_workerHandleUpdating", void 0), l2 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], l2);
var p5 = class extends h2 {
  constructor(e4, t4) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e4, { strategy: "dedicated", client: t4 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a7 = class extends m {
  get tiles() {
    return [new t2("0/0/0", 0, 0, 0, a2(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new j2({ origin: new x({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new p2({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
  constructor(e4) {
    super(e4), this.pointOfInterest = null;
  }
};
e([y({ readOnly: true })], a7.prototype, "tiles", null), e([y({ readOnly: true })], a7.prototype, "tileInfo", null), e([y({ readOnly: true })], a7.prototype, "tileSize", null), e([y({ constructOnly: true })], a7.prototype, "layer", void 0), e([y()], a7.prototype, "pointOfInterest", void 0), a7 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a7);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var b = class extends a4(m) {
  get _updateTilesParameters() {
    return { tiles: this._tilesOfInterest.tiles, tileInfo: this._tilesOfInterest.tileInfo, tileSize: this._tilesOfInterest.tileSize };
  }
  get updating() {
    var _a;
    return ((_a = this._workerHandle) == null ? void 0 : _a.updating) || this.updatingHandles.updating;
  }
  get configuration() {
    const { view: e4 } = this, t4 = null != e4 ? e4.type : "2d";
    return { filter: this._layer.createQuery(), customParameters: this._layer.customParameters, viewType: t4 };
  }
  get availability() {
    var _a;
    return ((_a = this._workerHandle) == null ? void 0 : _a.availability) ?? 0;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  constructor(e4) {
    super(e4), this._workerHandle = null, this._debug = null;
  }
  initialize() {
    let e4;
    const t4 = this.view;
    if (null != t4)
      switch (t4.type) {
        case "2d":
          this._tilesOfInterest = new p4({ view: t4, layer: this._layer }), e4 = this._workerHandle = new l2();
          break;
        case "3d": {
          const { resourceController: r2 } = t4, i2 = this._layer, u2 = t4.whenLayerView(i2);
          this._tilesOfInterest = new a6({ view: t4 }), e4 = this._workerHandle = new l2({ schedule: (e5) => r2.immediate.schedule(e5), hasZ: this._layer.hasZ && (this._layer.returnZ ?? true), elevationAlignPointsInFeatures: async (e5, t5) => {
            const r3 = await u2;
            return s(t5), r3.elevationAlignPointsInFeatures(e5, t5);
          }, queryForSymbologySnapping: async (e5, t5) => {
            const r3 = await u2;
            return s(t5), r3.queryForSymbologySnapping(e5, t5);
          } });
          const c4 = r(null);
          u2.then((e5) => c4.value = e5), this.addHandles([t4.elevationProvider.on("elevation-change", ({ context: t5 }) => {
            const { elevationInfo: r3 } = i2;
            m2(t5, r3) && y2(e4.notifyElevationSourceChange());
          }), l(() => i2.elevationInfo, () => y2(e4.notifyElevationSourceChange()), h), l(() => {
            var _a, _b;
            return (_b = (_a = c4.value) == null ? void 0 : _a.processor) == null ? void 0 : _b.renderer;
          }, () => y2(e4.notifySymbologyChange()), h), l(() => {
            var _a;
            return ((_a = c4.value) == null ? void 0 : _a.symbologySnappingSupported) ?? false;
          }, (t5) => y2(e4.setSymbologySnappingSupported(t5)), h), a3(() => {
            var _a;
            return (_a = c4.value) == null ? void 0 : _a.layer;
          }, ["edits", "apply-edits", "graphic-update"], () => e4.notifySymbologyChange())]);
          break;
        }
      }
    else
      this._tilesOfInterest = new a7({ layer: this._layer }), e4 = this._workerHandle = new l2();
    this.handles.add([o(e4)]), y2(e4.setup({ layer: this._layer, spatialReference: this.spatialReference, configuration: this.configuration }, null)), this.updatingHandles.add(() => this._updateTilesParameters, () => y2(e4.updateTiles(this._updateTilesParameters, null)), h), this.handles.add([l(() => this.configuration, (t5) => y2(e4.configure(t5, null)), U)]), null != t4 && this.handles.add(l(() => p3.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (r2) => {
      r2 && !this._debug ? (this._debug = new d2({ view: t4, handle: e4 }), this.handles.add(o(this._debug), "debug")) : !r2 && this._debug && this.handles.remove("debug");
    }, h)), this.handles.add(this.layerSource.layer.on("apply-edits", (t5) => {
      y2(e4.applyEdits(t5, null));
    }));
  }
  refresh() {
    var _a;
    (_a = this._workerHandle) == null ? void 0 : _a.refresh(null);
  }
  async fetchCandidates(e4, t4) {
    const { coordinateHelper: r2, point: i2 } = e4;
    this._tilesOfInterest.pointOfInterest = r2.arrayToPoint(i2);
    const s3 = this._getGroundElevation;
    return (await this._workerHandle.fetchCandidates({ ...e4 }, t4)).candidates.map((e5) => i(e5, s3));
  }
  getDebugInfo(e4) {
    return this._workerHandle.getDebugInfo(e4);
  }
  get _getGroundElevation() {
    return o4(this.view);
  }
};
e([y({ constructOnly: true })], b.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], b.prototype, "layerSource", void 0), e([y({ constructOnly: true })], b.prototype, "view", void 0), e([y()], b.prototype, "_tilesOfInterest", void 0), e([y({ readOnly: true })], b.prototype, "_updateTilesParameters", null), e([y({ readOnly: true })], b.prototype, "updating", null), e([y({ readOnly: true })], b.prototype, "configuration", null), e([y({ readOnly: true })], b.prototype, "availability", null), e([y()], b.prototype, "_getGroundElevation", null), b = e([a("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], b);
export {
  b as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-K6D3M6SP.js.map
