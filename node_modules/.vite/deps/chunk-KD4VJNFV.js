import {
  e as e3
} from "./chunk-D5NSNTGJ.js";
import {
  u
} from "./chunk-MUDJ2KE7.js";
import {
  c
} from "./chunk-EVSMDRIW.js";
import {
  e as e2
} from "./chunk-NHV3P5PD.js";
import {
  E
} from "./chunk-JIDIC5HA.js";
import {
  e
} from "./chunk-6M3QJVKB.js";
import {
  F
} from "./chunk-HLBPEADQ.js";
import {
  M,
  f,
  h,
  i,
  r,
  s
} from "./chunk-OTNLRAEN.js";
import {
  n
} from "./chunk-J2V5CZSS.js";
import {
  C,
  t
} from "./chunk-UYRCWUYQ.js";
import {
  has,
  m
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t2 = class {
  constructor(t3) {
    this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t3;
  }
};
var s2 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function s3(t3, e4, s5, o3, l3, i4) {
  const r4 = s5 - l3;
  if (r4 >= 0)
    return (e4 >> r4) + (o3 - (i4 << r4)) * (t3 >> r4);
  const n2 = -r4;
  return e4 - (i4 - (o3 << n2)) * (t3 >> n2) << n2;
}
var o = class {
  constructor(t3, e4, s5) {
    this._rows = Math.ceil(e4 / s5), this._columns = Math.ceil(t3 / s5), this._cellSize = s5, this.cells = new Array(this._rows);
    for (let o3 = 0; o3 < this._rows; o3++) {
      this.cells[o3] = new Array(this._columns);
      for (let t4 = 0; t4 < this._columns; t4++)
        this.cells[o3][t4] = [];
    }
  }
  getCell(t3, e4) {
    const s5 = Math.min(Math.max(Math.floor(e4 / this._cellSize), 0), this._rows - 1), o3 = Math.min(Math.max(Math.floor(t3 / this._cellSize), 0), this._columns - 1);
    return this.cells[s5] && this.cells[s5][o3] || null;
  }
  getCellSpan(t3, e4, s5, o3) {
    return [Math.min(Math.max(Math.floor(t3 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e4 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s5 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o3 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l(t3, s5, o3, l3, i4, r4) {
  const n2 = s5[l3++];
  for (let a = 0; a < n2; a++) {
    const n3 = new t2(r4);
    n3.xTile = s5[l3++], n3.yTile = s5[l3++], n3.hash = s5[l3++], n3.priority = s5[l3++];
    const a2 = s5[l3++];
    for (let t4 = 0; t4 < a2; t4++) {
      const t5 = s5[l3++], e4 = s5[l3++], i5 = s5[l3++], r5 = s5[l3++], a3 = !!s5[l3++], c4 = s5[l3++], h4 = o3[l3++], f3 = o3[l3++], u3 = s5[l3++], m3 = s5[l3++];
      n3.colliders.push({ xTile: t5, yTile: e4, dxPixels: i5, dyPixels: r5, hard: a3, partIndex: c4, width: u3, height: m3, minLod: h4, maxLod: f3 });
    }
    const c3 = t3[l3++];
    for (let e4 = 0; e4 < c3; e4++)
      n3.textVertexRanges.push([t3[l3++], t3[l3++]]);
    const h3 = t3[l3++];
    for (let e4 = 0; e4 < h3; e4++)
      n3.iconVertexRanges.push([t3[l3++], t3[l3++]]);
    i4.push(n3);
  }
  return l3;
}
function i2(t3, e4, s5) {
  for (const [o3, l3] of t3.symbols)
    r2(t3, e4, s5, l3, o3);
}
function r2(e4, s5, o3, l3, i4) {
  const r4 = e4.layerData.get(i4);
  if (r4.type === E.SYMBOL) {
    for (const t3 of l3) {
      const s6 = t3.unique;
      let l4;
      if (t3.selectedForRendering) {
        const t4 = s6.parts[0], i5 = t4.startOpacity, r5 = t4.targetOpacity;
        e4.allSymbolsFadingOut = e4.allSymbolsFadingOut && 0 === r5;
        const n2 = o3 ? Math.floor(127 * i5) | r5 << 7 : r5 ? 255 : 0;
        l4 = n2 << 24 | n2 << 16 | n2 << 8 | n2;
      } else
        l4 = 0;
      for (const [e5, o4] of t3.iconVertexRanges)
        for (let t4 = e5; t4 < e5 + o4; t4 += 4)
          r4.iconOpacity[t4 / 4] = l4;
      if (t3.selectedForRendering) {
        const t4 = s6.parts[1], i5 = t4.startOpacity, r5 = t4.targetOpacity;
        e4.allSymbolsFadingOut = e4.allSymbolsFadingOut && 0 === r5;
        const n2 = o3 ? Math.floor(127 * i5) | r5 << 7 : r5 ? 255 : 0;
        l4 = n2 << 24 | n2 << 16 | n2 << 8 | n2;
      } else
        l4 = 0;
      for (const [e5, o4] of t3.textVertexRanges)
        for (let t4 = e5; t4 < e5 + o4; t4 += 4)
          r4.textOpacity[t4 / 4] = l4;
    }
    r4.lastOpacityUpdate = s5, r4.opacityChanged = true;
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var o2 = class {
  constructor(t3, e4) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t3;
    let r4 = 1;
    const n2 = new Uint32Array(t3);
    this.layerUIDs = [];
    const s5 = n2[r4++];
    for (let i4 = 0; i4 < s5; i4++)
      this.layerUIDs[i4] = n2[r4++];
    this.bufferDataOffset = r4, e4 && (this.layer = e4.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this.isDestroyed = true);
  }
  prepareForRendering(t3) {
    null != this._data && (this.doPrepareForRendering(t3, this._data, this.bufferDataOffset), this._data = null);
  }
};
var h2 = class extends o2 {
  constructor(t3, e4) {
    super(t3, e4), this.type = E.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const n2 = new Uint32Array(t3);
    let s5 = this.bufferDataOffset;
    this.lineIndexStart = n2[s5++], this.lineIndexCount = n2[s5++];
    const i4 = n2[s5++];
    if (i4 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t4 = 0; t4 < i4; t4++) {
        const t5 = n2[s5++], e5 = n2[s5++], r4 = n2[s5++];
        this.patternMap.set(t5, [e5, r4]);
      }
    }
    this.bufferDataOffset = s5;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = t(this.vao);
  }
  doPrepareForRendering(t3, e4, r4) {
    const n2 = new Uint32Array(e4), o3 = new Int32Array(n2.buffer), h3 = n2[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n2[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n2.buffer, 4 * r4, c3));
    r4 += c3;
    const y = this.layer.lineMaterial;
    this.vao = new u(t3, y.getAttributeLocations(), y.getLayoutInfo(), { geometry: f3 }, l3);
  }
};
var f2 = class extends o2 {
  constructor(t3, e4) {
    super(t3, e4), this.type = E.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const n2 = new Uint32Array(t3);
    let s5 = this.bufferDataOffset;
    this.fillIndexStart = n2[s5++], this.fillIndexCount = n2[s5++], this.outlineIndexStart = n2[s5++], this.outlineIndexCount = n2[s5++];
    const i4 = n2[s5++];
    if (i4 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t4 = 0; t4 < i4; t4++) {
        const t5 = n2[s5++], e5 = n2[s5++], r4 = n2[s5++];
        this.patternMap.set(t5, [e5, r4]);
      }
    }
    this.bufferDataOffset = s5;
  }
  get memoryUsed() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.memoryEstimate) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = t(this.fillVAO), this.outlineVAO = t(this.outlineVAO);
  }
  doPrepareForRendering(t3, e4, r4) {
    const n2 = new Uint32Array(e4), o3 = new Int32Array(n2.buffer), h3 = n2[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n2[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n2.buffer, 4 * r4, c3));
    r4 += c3;
    const y = n2[r4++], u3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, y));
    r4 += y;
    const A = n2[r4++], d2 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n2.buffer, 4 * r4, A));
    r4 += A;
    const I = this.layer, g = I.fillMaterial, p = I.outlineMaterial;
    this.fillVAO = new u(t3, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: f3 }, l3), this.outlineVAO = new u(t3, p.getAttributeLocations(), p.getLayoutInfo(), { geometry: u3 }, d2);
  }
};
var c2 = class extends o2 {
  constructor(t3, e4, s5) {
    super(t3, e4), this.type = E.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const i4 = new Uint32Array(t3), a = new Int32Array(t3), o3 = new Float32Array(t3);
    let h3 = this.bufferDataOffset;
    this.isIconSDF = !!i4[h3++];
    const f3 = i4[h3++];
    for (let r4 = 0; r4 < f3; r4++) {
      const t4 = i4[h3++], e5 = i4[h3++], r5 = i4[h3++];
      this.iconPerPageElementsMap.set(t4, [e5, r5]);
    }
    const c3 = i4[h3++];
    for (let r4 = 0; r4 < c3; r4++) {
      const t4 = i4[h3++], e5 = i4[h3++], r5 = i4[h3++];
      this.glyphPerPageElementsMap.set(t4, [e5, r5]);
    }
    const l3 = i4[h3++], y = i4[h3++];
    this.iconOpacity = new Int32Array(l3), this.textOpacity = new Int32Array(y), h3 = l(i4, a, o3, h3, this.symbols, s5), this.bufferDataOffset = h3;
  }
  get memoryUsed() {
    var _a, _b, _c2;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.memoryEstimate) ?? 0) + (((_c2 = this.textVAO) == null ? void 0 : _c2.memoryEstimate) ?? 0) + m(this.iconOpacity) + m(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t3 = 0;
    for (const [e4, r4] of this.iconPerPageElementsMap)
      t3 += r4[1];
    for (const [e4, r4] of this.glyphPerPageElementsMap)
      t3 += r4[1];
    return t3 / 3;
  }
  doDestroy() {
    this.iconVAO = t(this.iconVAO), this.textVAO = t(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged)
      return;
    this.opacityChanged = false;
    const t3 = this.iconOpacity, e4 = this.iconVAO.vertexBuffers.opacity;
    t3.length > 0 && t3.byteLength === e4.byteLength && e4.setSubData(t3, 0, 0, t3.length);
    const r4 = this.textOpacity, n2 = this.textVAO.vertexBuffers.opacity;
    r4.length > 0 && r4.byteLength === n2.byteLength && n2.setSubData(r4, 0, 0, r4.length);
  }
  doPrepareForRendering(t3, e4, r4) {
    const n2 = new Uint32Array(e4), o3 = new Int32Array(n2.buffer), h3 = n2[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n2[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n2.buffer, 4 * r4, c3));
    r4 += c3;
    const y = n2[r4++], u3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, y));
    r4 += y;
    const A = n2[r4++], d2 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n2.buffer, 4 * r4, A));
    r4 += A;
    const I = c.createVertex(t3, F.STATIC_DRAW, this.iconOpacity.buffer), g = c.createVertex(t3, F.STATIC_DRAW, this.textOpacity.buffer), p = this.layer, m3 = p.iconMaterial, x = p.textMaterial;
    this.iconVAO = new u(t3, m3.getAttributeLocations(), m3.getLayoutInfo(), { geometry: f3, opacity: I }, l3), this.textVAO = new u(t3, x.getAttributeLocations(), x.getLayoutInfo(), { geometry: u3, opacity: g }, d2);
  }
};
var l2 = class extends o2 {
  constructor(t3, e4) {
    super(t3, e4), this.type = E.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const n2 = new Uint32Array(t3);
    let s5 = this.bufferDataOffset;
    this.circleIndexStart = n2[s5++], this.circleIndexCount = n2[s5++], this.bufferDataOffset = s5;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = t(this.vao);
  }
  doPrepareForRendering(t3, e4, r4) {
    const n2 = new Uint32Array(e4), o3 = new Int32Array(n2.buffer), h3 = n2[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n2[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n2.buffer, 4 * r4, c3));
    r4 += c3;
    const y = this.layer.circleMaterial;
    this.vao = new u(t3, y.getAttributeLocations(), y.getLayoutInfo(), { geometry: f3 }, l3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/DisplayObject.js
var s4 = 1 / has("mapview-transitions-duration");
var i3 = class extends n {
  constructor() {
    super(...arguments), this._fadeOutResolver = null, this._fadeInResolver = null, this._clips = null, this.computedVisible = true, this.computedOpacity = 1, this.fadeTransitionEnabled = false, this.inFadeTransition = false, this._isReady = false, this._opacity = 1, this.parent = null, this._stage = null, this._visible = true;
  }
  get clips() {
    return this._clips;
  }
  set clips(e4) {
    this._clips = e4, this.requestRender();
  }
  get isReady() {
    return this._isReady;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e4) {
    this._opacity !== e4 && (this._opacity = Math.min(1, Math.max(e4, 0)), this.requestRender());
  }
  get stage() {
    return this._stage;
  }
  set stage(e4) {
    var _a;
    if (this._stage === e4)
      return;
    const t3 = this._stage;
    this._stage = e4, e4 ? ((_a = this._stage) == null ? void 0 : _a.untrashDisplayObject(this)) || (this.onAttach(), this.emit("attach")) : t3 == null ? void 0 : t3.trashDisplayObject(this);
  }
  get transforms() {
    return this._getTransforms();
  }
  _getTransforms() {
    return null == this._transforms && (this._transforms = this._createTransforms()), this._transforms;
  }
  get visible() {
    return this._visible;
  }
  set visible(e4) {
    this._visible !== e4 && (this._visible = e4, this.requestRender());
  }
  fadeIn() {
    return this._fadeInResolver || (this._fadeOutResolver && (this._fadeOutResolver(), this._fadeOutResolver = null), this.opacity = 1, this.computedOpacity = 0, this.fadeTransitionEnabled = true, this._fadeInResolver = C(), this.requestRender()), this._fadeInResolver.promise;
  }
  fadeOut() {
    return this._fadeOutResolver || (this.opacity = 0, this._fadeInResolver && (this._fadeInResolver(), this._fadeInResolver = null), this.fadeTransitionEnabled = true, this._fadeOutResolver = C(), this.requestRender()), this._fadeOutResolver.promise;
  }
  endTransitions() {
    var _a, _b;
    (_a = this._fadeInResolver) == null ? void 0 : _a.call(this), this._fadeInResolver = null, (_b = this._fadeOutResolver) == null ? void 0 : _b.call(this), this._fadeOutResolver = null, this.computedOpacity = this.visible ? this.opacity : 0, this.requestRender();
  }
  beforeRender(e4) {
    this.updateTransitionProperties(e4.deltaTime, e4.state.scale);
  }
  afterRender(e4) {
    this._fadeInResolver && this.computedOpacity === this.opacity ? (this._fadeInResolver(), this._fadeInResolver = null) : this._fadeOutResolver && 0 === this.computedOpacity && (this._fadeOutResolver(), this._fadeOutResolver = null);
  }
  remove() {
    var _a;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  }
  setTransform(e4) {
  }
  processRender(e4) {
    this.stage && this.computedVisible && this.doRender(e4);
  }
  requestRender() {
    this.stage && this.stage.requestRender();
  }
  processDetach() {
    this._fadeInResolver && (this._fadeInResolver(), this._fadeInResolver = null), this._fadeOutResolver && (this._fadeOutResolver(), this._fadeOutResolver = null), this.onDetach(), this.emit("detach");
  }
  updateTransitionProperties(e4, t3) {
    if (this.fadeTransitionEnabled) {
      const t4 = this._fadeOutResolver || !this.visible ? 0 : this.opacity, i4 = this.computedOpacity;
      if (i4 === t4)
        this.computedVisible = this.visible;
      else {
        const r4 = e4 * s4;
        this.computedOpacity = i4 > t4 ? Math.max(t4, i4 - r4) : Math.min(t4, i4 + r4), this.computedVisible = this.computedOpacity > 0;
        const a = t4 === this.computedOpacity;
        this.inFadeTransition = !a, a || this.requestRender();
      }
    } else
      this.computedOpacity = this.opacity, this.computedVisible = this.visible;
  }
  onAttach() {
  }
  onDetach() {
  }
  doRender(e4) {
  }
  ready() {
    this._isReady || (this._isReady = true, this.emit("isReady"), this.requestRender());
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TiledDisplayObject.js
var r3 = class extends i3 {
  constructor(t3, s5, i4, r4, h3, o3, n2 = h3, a = o3) {
    super(), this.triangleCountReportedInDebug = 0, this.triangleCount = 0, this.texture = null, this.key = new e(t3), this.resolution = s5, this.x = i4, this.y = r4, this.width = h3, this.height = o3, this.rangeX = n2, this.rangeY = a;
  }
  destroy() {
    this.texture && (this.texture.dispose(), this.texture = null);
  }
  setTransform(i4) {
    const e4 = this.resolution / (i4.resolution * i4.pixelRatio), r4 = this.transforms.tileMat3, [h3, o3] = i4.toScreenNoRotation([0, 0], [this.x, this.y]), n2 = this.width / this.rangeX * e4, a = this.height / this.rangeY * e4;
    s(r4, n2, 0, 0, 0, a, 0, h3, o3, 1), i(this.transforms.dvs, i4.displayViewMat3, r4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var d = class _d extends r3 {
  constructor(e4, t3, s5, a, r4, i4, o3, h3 = null) {
    super(e4, t3, s5, a, r4, i4, 4096, 4096), this.styleRepository = o3, this._memCache = h3, this.type = "vector-tile", this._referenced = 0, this._hasSymbolBuckets = false, this._memoryUsedByLayerData = 0, this.layerData = /* @__PURE__ */ new Map(), this.layerCount = 0, this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.invalidating = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this._processed = false, this._referenced = 1, this.id = e4.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e2;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e2);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e4) {
    this.changeDataImpl(e4), this.requestRender(), this.ready(), this.invalidating = false, this._processed = true;
  }
  deleteLayerData(e4) {
    var _a;
    let t3 = false;
    for (const s5 of e4)
      if (this.layerData.has(s5)) {
        const e5 = this.layerData.get(s5);
        this._memoryUsedByLayerData -= e5.memoryUsed, e5.type === E.SYMBOL && this.symbols.has(s5) && (this.symbols.delete(s5), t3 = true), e5.destroy(), this.layerData.delete(s5), this.layerCount--;
      }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this._memoryUsedByLayerData), t3 && this.emit("symbols-changed"), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerCount > 0;
  }
  dispose() {
    "unloaded" !== this.status && (m2.delete(this), _d._destroyRenderBuckets(this.layerData), this.layerData = null, this.layerCount = 0, this._memoryUsedByLayerData = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    return 0 == --this._referenced && (this.dispose(), this.stage = null, true);
  }
  retain() {
    ++this._referenced;
  }
  get referenced() {
    return this._referenced;
  }
  get memoryUsed() {
    return this._memoryUsedByLayerData + 256;
  }
  changeDataImpl(e4) {
    var _a;
    let t3 = false;
    if (e4) {
      const { bucketsWithData: s5, emptyBuckets: a } = e4, r4 = this._createRenderBuckets(s5);
      if (a && a.byteLength > 0) {
        const e5 = new Uint32Array(a);
        for (const t4 of e5)
          this._deleteLayerData(t4);
      }
      for (const [e5, o3] of r4)
        this._deleteLayerData(e5), o3.type === E.SYMBOL && (this.symbols.set(e5, o3.symbols), t3 = true), this._memoryUsedByLayerData += o3.memoryUsed, this.layerData.set(e5, o3), this.layerCount++;
      (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this.memoryUsed);
    }
    this._hasSymbolBuckets = false;
    for (const [s5, a] of this.layerData)
      a.type === E.SYMBOL && (this._hasSymbolBuckets = true);
    t3 && this.emit("symbols-changed");
  }
  attachWithContext(e4) {
    this.stage = { context: e4, trashDisplayObject(e5) {
      e5.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(r4) {
    super.setTransform(r4);
    const i4 = this.resolution / (r4.resolution * r4.pixelRatio), o3 = this.width / this.rangeX * i4, h3 = this.height / this.rangeY * i4, n2 = [0, 0];
    r4.toScreen(n2, [this.x, this.y]);
    const l3 = this.transforms.tileUnitsToPixels;
    r(l3), M(l3, l3, n2), h(l3, l3, Math.PI * r4.rotation / 180), f(l3, l3, [o3, h3, 1]);
  }
  _createTransforms() {
    return { dvs: e3(), tileMat3: e3(), tileUnitsToPixels: e3() };
  }
  static _destroyRenderBuckets(e4) {
    if (!e4)
      return;
    const t3 = /* @__PURE__ */ new Set();
    e4.forEach((e5) => {
      t3.has(e5) || (e5.destroy(), t3.add(e5));
    }), e4.clear();
  }
  _createRenderBuckets(e4) {
    const t3 = /* @__PURE__ */ new Map(), s5 = /* @__PURE__ */ new Map();
    for (const a of e4) {
      const e5 = this._deserializeBucket(a, s5);
      for (const s6 of e5.layerUIDs)
        t3.set(s6, e5);
    }
    return t3;
  }
  _deserializeBucket(e4, t3) {
    let s5 = t3.get(e4);
    if (s5)
      return s5;
    switch (new Uint32Array(e4)[0]) {
      case E.FILL:
        s5 = new f2(e4, this.styleRepository);
        break;
      case E.LINE:
        s5 = new h2(e4, this.styleRepository);
        break;
      case E.SYMBOL:
        s5 = new c2(e4, this.styleRepository, this);
        break;
      case E.CIRCLE:
        s5 = new l2(e4, this.styleRepository);
    }
    return t3.set(e4, s5), s5;
  }
  _deleteLayerData(e4) {
    if (!this.layerData.has(e4))
      return;
    const t3 = this.layerData.get(e4);
    this._memoryUsedByLayerData -= t3.memoryUsed, t3.destroy(), this.layerData.delete(e4), this.layerCount--;
  }
};
var m2 = /* @__PURE__ */ new Map();
function u2() {
  m2.forEach((e4, t3) => {
    console.log(`
${t3.key}:`), e4[0].forEach((e5) => console.log(e5)), console.log("========"), e4[1].forEach((e5) => console.log(e5));
  });
}

export {
  s2 as s,
  s3 as s2,
  o,
  i2 as i,
  d,
  u2 as u
};
//# sourceMappingURL=chunk-KD4VJNFV.js.map
