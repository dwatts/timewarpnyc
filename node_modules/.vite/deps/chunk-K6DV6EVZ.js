import {
  s as s3
} from "./chunk-4RU6WIRN.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/interfaces.js
var t = class {
};
var n = t;
function o(t2, ...n3) {
  let o3 = "";
  for (let r = 0; r < n3.length; r++)
    o3 += t2[r] + n3[r];
  return o3 += t2[t2.length - 1], o3;
}
!function(t2) {
  function n3(t3) {
    return Math.round(t3).toString();
  }
  function o3(t3) {
    return t3.toPrecision(8);
  }
  t2.int = n3, t2.float = o3;
}(o || (o = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/BindType.js
var a;
!function(a3) {
  a3[a3.Pass = 0] = "Pass", a3[a3.Draw = 1] = "Draw";
}(a || (a = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Uniform.js
var i = class {
  constructor(i3, s5, t2, r, a3 = null) {
    this.name = i3, this.type = s5, this.arraySize = a3, this.bind = { [a.Pass]: null, [a.Draw]: null }, null != t2 && null != r && (this.bind[t2] = r);
  }
  equals(e) {
    return this.type === e.type && this.name === e.name && this.arraySize === e.arraySize;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js
var n2 = s.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");
var s4 = class {
  constructor() {
    this._includedModules = /* @__PURE__ */ new Map();
  }
  include(e, t2) {
    if (this._includedModules.has(e)) {
      const r = this._includedModules.get(e);
      if (r !== t2) {
        n2.error("Trying to include shader module multiple times with different sets of options.");
        const t3 = /* @__PURE__ */ new Set();
        for (const n3 of Object.keys(r))
          r[n3] !== e[n3] && t3.add(n3);
        for (const n3 of Object.keys(e))
          r[n3] !== e[n3] && t3.add(n3);
        t3.forEach((t4) => console.error(`  ${t4}: current ${r[t4]} new ${e[t4]}`));
      }
    } else
      this._includedModules.set(e, t2), e(this.builder, t2);
  }
};
var i2 = class extends s4 {
  constructor() {
    super(...arguments), this.vertex = new c(), this.fragment = new c(), this.attributes = new u(), this.varyings = new l(), this.extensions = new m(), this.constants = new h();
  }
  get fragmentUniforms() {
    return this.fragment.uniforms.entries;
  }
  get builder() {
    return this;
  }
  generate(e) {
    const t2 = this.extensions.generateSource(e), r = this.attributes.generateSource(e), n3 = this.varyings.generateSource(e), s5 = "vertex" === e ? this.vertex : this.fragment, i3 = s5.uniforms.generateSource(), o3 = s5.code.generateSource(), a3 = "vertex" === e ? _ : d, c2 = this.constants.generateSource().concat(s5.constants.generateSource());
    return `#version 300 es
${t2.join("\n")}

${a3}

${c2.join("\n")}

${i3.join("\n")}

${r.join("\n")}

${n3.join("\n")}

${o3.join("\n")}`;
  }
  generateBind(e, t2) {
    const r = /* @__PURE__ */ new Map();
    this.vertex.uniforms.entries.forEach((t3) => {
      const n4 = t3.bind[e];
      null != n4 && r.set(t3.name, n4);
    }), this.fragment.uniforms.entries.forEach((t3) => {
      const n4 = t3.bind[e];
      null != n4 && r.set(t3.name, n4);
    });
    const n3 = Array.from(r.values()), s5 = n3.length;
    return (e2, r2, i3) => {
      for (let o3 = 0; o3 < s5; ++o3)
        n3[o3](t2, e2, r2, i3);
    };
  }
};
var o2 = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  add(...e) {
    for (const t2 of e)
      this._add(t2);
  }
  get(e) {
    return this._entries.get(e);
  }
  _add(t2) {
    if (null != t2) {
      if (this._entries.has(t2.name) && !this._entries.get(t2.name).equals(t2))
        throw new s2(`Duplicate uniform name ${t2.name} for different uniform type`);
      this._entries.set(t2.name, t2);
    } else
      n2.error(`Trying to add null Uniform from ${new Error().stack}.`);
  }
  generateSource() {
    return Array.from(this._entries.values()).map((e) => null != e.arraySize ? `uniform ${e.type} ${e.name}[${e.arraySize}];` : `uniform ${e.type} ${e.name};`);
  }
  get entries() {
    return Array.from(this._entries.values());
  }
};
var a2 = class {
  constructor() {
    this._entries = new Array();
  }
  add(e) {
    this._entries.push(e);
  }
  generateSource() {
    return this._entries;
  }
};
var c = class extends s4 {
  constructor() {
    super(...arguments), this.uniforms = new o2(), this.code = new a2(), this.constants = new h();
  }
  get builder() {
    return this;
  }
};
var u = class {
  constructor() {
    this._entries = new Array();
  }
  add(e, t2) {
    this._entries.push([e, t2]);
  }
  generateSource(e) {
    return "fragment" === e ? [] : this._entries.map((e2) => `in ${e2[1]} ${e2[0]};`);
  }
};
var l = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  add(e, t2) {
    this._entries.has(e) && s3(this._entries.get(e) === t2), this._entries.set(e, t2);
  }
  generateSource(e) {
    const t2 = new Array();
    return this._entries.forEach((r, n3) => t2.push("vertex" === e ? `out ${r} ${n3};` : `in ${r} ${n3};`)), t2;
  }
};
var m = class _m {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e) {
    this._entries.add(e);
  }
  generateSource(e) {
    const t2 = "vertex" === e ? _m.ALLOWLIST_VERTEX : _m.ALLOWLIST_FRAGMENT;
    return Array.from(this._entries).filter((e2) => t2.includes(e2)).map((e2) => `#extension ${e2} : enable`);
  }
};
m.ALLOWLIST_FRAGMENT = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives"], m.ALLOWLIST_VERTEX = [];
var h = class _h {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e, t2, r) {
    let n3 = "ERROR_CONSTRUCTOR_STRING";
    switch (t2) {
      case "float":
        n3 = _h._numberToFloatStr(r);
        break;
      case "int":
        n3 = _h._numberToIntStr(r);
        break;
      case "bool":
        n3 = r.toString();
        break;
      case "vec2":
        n3 = `vec2(${_h._numberToFloatStr(r[0])},                            ${_h._numberToFloatStr(r[1])})`;
        break;
      case "vec3":
        n3 = `vec3(${_h._numberToFloatStr(r[0])},                            ${_h._numberToFloatStr(r[1])},                            ${_h._numberToFloatStr(r[2])})`;
        break;
      case "vec4":
        n3 = `vec4(${_h._numberToFloatStr(r[0])},                            ${_h._numberToFloatStr(r[1])},                            ${_h._numberToFloatStr(r[2])},                            ${_h._numberToFloatStr(r[3])})`;
        break;
      case "ivec2":
        n3 = `ivec2(${_h._numberToIntStr(r[0])},                             ${_h._numberToIntStr(r[1])})`;
        break;
      case "ivec3":
        n3 = `ivec3(${_h._numberToIntStr(r[0])},                             ${_h._numberToIntStr(r[1])},                             ${_h._numberToIntStr(r[2])})`;
        break;
      case "ivec4":
        n3 = `ivec4(${_h._numberToIntStr(r[0])},                             ${_h._numberToIntStr(r[1])},                             ${_h._numberToIntStr(r[2])},                             ${_h._numberToIntStr(r[3])})`;
        break;
      case "mat2":
      case "mat3":
      case "mat4":
        n3 = `${t2}(${Array.prototype.map.call(r, (e2) => _h._numberToFloatStr(e2)).join(", ")})`;
    }
    return this._entries.add(`const ${t2} ${e} = ${n3};`), this;
  }
  static _numberToIntStr(e) {
    return e.toFixed(0);
  }
  static _numberToFloatStr(e) {
    return Number.isInteger(e) ? e.toFixed(1) : e.toString();
  }
  generateSource() {
    return Array.from(this._entries);
  }
};
var d = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif\n\nout vec4 fragColor;";
var _ = "precision highp float;\nprecision highp sampler2D;";

export {
  n,
  o,
  a,
  i,
  i2
};
//# sourceMappingURL=chunk-K6DV6EVZ.js.map
