import {
  c as c5
} from "./chunk-GOA7OKM7.js";
import {
  G as G2,
  S as S2,
  V,
  a as a7,
  g,
  i as i4,
  l as l2
} from "./chunk-2RY5Y75R.js";
import {
  c as c6,
  i as i6,
  r as r3
} from "./chunk-AYYUAD5Z.js";
import "./chunk-PX3Q44FM.js";
import "./chunk-XYJMHUDA.js";
import {
  e as e6,
  t as t3
} from "./chunk-CSLWFQJE.js";
import {
  C as C2,
  N,
  O,
  P,
  U,
  Z,
  b as b3,
  f as f4,
  w as w4
} from "./chunk-SI6VNZBP.js";
import {
  a as a6,
  c as c4,
  i as i8,
  n as n4,
  o as o4,
  r as r4,
  s as s6
} from "./chunk-VUIQFLG6.js";
import {
  G,
  R as R2,
  f as f3,
  k,
  o as o5,
  p as p3,
  t as t2,
  u2 as u3
} from "./chunk-LDJZGB4X.js";
import "./chunk-5ARHJ4BH.js";
import {
  w as w3,
  x
} from "./chunk-A4HFWKMU.js";
import {
  E,
  S
} from "./chunk-YRFMBPVS.js";
import {
  o as o2,
  p as p2
} from "./chunk-S65MUXI3.js";
import {
  $,
  a as a5,
  ae,
  b as b2,
  be,
  c as c3,
  ce,
  de,
  fe,
  ge,
  h as h2,
  i as i3,
  je,
  ke,
  le,
  me,
  ne,
  pe,
  q,
  ue,
  ve,
  w as w2,
  we,
  xe,
  ye
} from "./chunk-ZS33I7QE.js";
import {
  s as s7
} from "./chunk-YYE6WDO2.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-QNBIVGAZ.js";
import {
  e as e5,
  h as h3,
  i as i7,
  n as n2,
  n2 as n3
} from "./chunk-EUYJEZD4.js";
import {
  n as n5,
  t as t4
} from "./chunk-5KLICR5E.js";
import {
  e as e7,
  t as t5
} from "./chunk-RSPVLZNN.js";
import "./chunk-PR2OEILG.js";
import {
  e as e3
} from "./chunk-6M3QJVKB.js";
import {
  e as e4,
  i as i5,
  o as o3
} from "./chunk-PH45YSDU.js";
import {
  t
} from "./chunk-M5UHI5WR.js";
import "./chunk-L3FCQBVC.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-HLBPEADQ.js";
import {
  m as m2,
  r as r2,
  z
} from "./chunk-NLWV7Q6F.js";
import {
  h
} from "./chunk-RR3IDPQP.js";
import {
  a as a3,
  c
} from "./chunk-QOWAKGE4.js";
import {
  a as a4,
  s as s4
} from "./chunk-VYG5A4VI.js";
import {
  r,
  s as s5,
  y as y2
} from "./chunk-CGJNVOU3.js";
import "./chunk-OHH3UAUS.js";
import {
  e as e2
} from "./chunk-E2PV5YTZ.js";
import "./chunk-GLVTFP5O.js";
import {
  b2 as b,
  c as c2,
  d as d2,
  p,
  w
} from "./chunk-7BMUKKBX.js";
import "./chunk-DKCDRJ5N.js";
import "./chunk-ZEMUATMN.js";
import "./chunk-RG2YRACH.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-W3WHCGIQ.js";
import "./chunk-HPWZ2OON.js";
import "./chunk-5HSVWQOA.js";
import "./chunk-C2BBLDPU.js";
import "./chunk-GWA3PLGA.js";
import "./chunk-FXWSVUF2.js";
import "./chunk-CNS4YGGN.js";
import {
  o,
  u as u2
} from "./chunk-DOQ3SAAR.js";
import {
  n as n6
} from "./chunk-UHAU5IXU.js";
import {
  i as i2
} from "./chunk-3U2FS2TT.js";
import "./chunk-ZXXKE5XP.js";
import "./chunk-MATER45R.js";
import "./chunk-6UW2VZVV.js";
import "./chunk-GAARA5JM.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-EHNCW2SL.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-REPJV7SP.js";
import "./chunk-F42HXUMI.js";
import "./chunk-BAMKEIAF.js";
import "./chunk-CZNLCEZN.js";
import {
  j
} from "./chunk-UNJDKTFU.js";
import "./chunk-DH42JQZX.js";
import "./chunk-674HAVOZ.js";
import "./chunk-MHGDFNBE.js";
import "./chunk-J2V5CZSS.js";
import "./chunk-7D57YBLP.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-ZF5PVI2P.js";
import "./chunk-EQK73KLU.js";
import {
  L
} from "./chunk-OBGBLQQX.js";
import "./chunk-FXYPEAR7.js";
import "./chunk-V3CNLYUD.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-T35GN7EL.js";
import {
  f as f2
} from "./chunk-7U6V6KY2.js";
import "./chunk-NFY4EX6G.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-ULGEYK3G.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-CHTUPHTO.js";
import {
  m,
  y
} from "./chunk-453UIKKW.js";
import {
  a2 as a
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-7G6CKDLW.js";
import "./chunk-FFUMVAL2.js";
import "./chunk-3JQ6N63Z.js";
import "./chunk-U3J7253Q.js";
import "./chunk-FWH3QSBQ.js";
import "./chunk-2UENN434.js";
import {
  C,
  a2,
  d,
  f2 as f,
  l,
  n,
  s2 as s3,
  u
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R
} from "./chunk-JZJWZ6DN.js";
import "./chunk-6TJCVOLN.js";

// node_modules/@arcgis/core/views/2d/tiling/PagedTileQueue.js
function u4(e12, t12) {
  return e12.length = 0, t12.forEach((t13) => e12.push(t13)), e12;
}
var a8 = /* @__PURE__ */ new Set();
var c7 = [];
var h4 = /* @__PURE__ */ new Map();
var l3 = [0, 0];
var p4 = class extends m {
  constructor(e12) {
    super(e12), this._keyToItem = /* @__PURE__ */ new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: e12, process: t12 } = this;
    this._queue = new u3({ concurrency: e12, process: (e13, s11) => {
      const r13 = this._keyToItem.get(e13);
      return t12(r13, { signal: s11 });
    }, peeker: (e13) => e13.values().next().value });
  }
  destroy() {
    this.clear(), this._queue = l(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(e12) {
    const t12 = "string" == typeof e12 ? e12 : e12.id;
    this._queue.abort(t12);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(e12) {
    return "string" == typeof e12 ? this._keyToItem.has(e12) : this._keyToItem.has(e12.id);
  }
  isOngoing(e12) {
    const t12 = "string" == typeof e12 ? e12 : e12.id;
    return this.has(t12) && this._queue.isOngoing(t12);
  }
  pause() {
    this._queue.pause();
  }
  push(e12, t12) {
    const s11 = e12.key.id + "-" + t12;
    if (this.has(s11))
      return this.get(s11);
    const r13 = this._queue.push(s11), o12 = () => {
      this._keyToItem.delete(s11), this.notifyChange("updating");
    };
    return this._keyToItem.set(s11, e12), r13.then(o12, o12), this.notifyChange("updating"), r13;
  }
  reset() {
    this._queue.reset(), this.notifyChange("updating");
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(e12) {
    if (!this.state)
      return e12.values().next().value;
    const t12 = this.tileInfoView;
    let s11 = Number.NEGATIVE_INFINITY, r13 = Number.POSITIVE_INFINITY;
    e12.forEach((e13) => {
      const t13 = this._keyToItem.get(e13), o13 = this.tileInfoView.getTileScale(t13.key);
      h4.has(o13) || (h4.set(o13, []), s11 = Math.max(o13, s11), r13 = Math.min(o13, r13)), h4.get(o13).push(t13.key), a8.add(o13);
    });
    let o12 = this.state.scale;
    h4.has(o12) || (u4(c7, a8), c7.sort((e13, t13) => e13 - t13), o12 = c7.reduce((e13, t13) => Math.abs(t13 - o12) < Math.abs(e13 - o12) ? t13 : e13, c7[0])), o12 = Math.min(o12, s11), o12 = Math.max(o12, r13);
    const i19 = h4.get(o12), n12 = t12.getClosestInfoForScale(o12), l11 = n12.getColumnForX(this.state.center[0]), p15 = n12.getRowForY(this.state.center[1]);
    return i19.sort((e13, t13) => {
      const s12 = n12.denormalizeCol(e13.col, e13.world), r14 = n12.denormalizeCol(t13.col, t13.world);
      return Math.sqrt((l11 - s12) * (l11 - s12) + (p15 - e13.row) * (p15 - e13.row)) - Math.sqrt((l11 - r14) * (l11 - r14) + (p15 - t13.row) * (p15 - t13.row));
    }), a8.clear(), h4.clear(), i19[0].id;
  }
  _peekByCenterFirst(e12) {
    if (!this.state)
      return e12.values().next().value;
    const t12 = this.tileInfoView, s11 = this.state.center;
    let r13, o12 = Number.POSITIVE_INFINITY;
    return e12.forEach((e13) => {
      const n12 = this._keyToItem.get(e13);
      t12.getTileCoords(l3, n12.key);
      const u14 = m2(l3, s11);
      u14 < o12 && (o12 = u14, r13 = n12.key);
    }), r13.id;
  }
};
e([y({ constructOnly: true })], p4.prototype, "concurrency", void 0), e([y({ constructOnly: true })], p4.prototype, "process", void 0), e([y()], p4.prototype, "state", void 0), e([y({ constructOnly: true })], p4.prototype, "strategy", void 0), e([y({ constructOnly: true })], p4.prototype, "tileInfoView", void 0), e([y({ readOnly: true })], p4.prototype, "updating", null), p4 = e([a("esri.views.2d.tiling.PagedTileQueue")], p4);

// node_modules/@arcgis/core/views/2d/tiling/TileQueue.js
function u5(e12, t12) {
  return e12.length = 0, t12.forEach((t13) => e12.push(t13)), e12;
}
var c8 = /* @__PURE__ */ new Set();
var a9 = [];
var h5 = /* @__PURE__ */ new Map();
var l4 = [0, 0];
var p5 = class extends m {
  constructor(e12) {
    super(e12), this._keyToItem = /* @__PURE__ */ new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: e12, process: t12, strategy: s11 } = this;
    this._queue = new u3({ concurrency: e12, process: (e13, s12) => {
      const r13 = this._keyToItem.get(e13);
      return t12(r13, { signal: s12 });
    }, peeker: "scale-first" === s11 ? (e13) => this._peekByScaleFirst(e13) : (e13) => this._peekByCenterFirst(e13) });
  }
  destroy() {
    this.clear(), this._queue = l(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(e12) {
    const t12 = "string" == typeof e12 ? e12 : e12.id;
    this._queue.abort(t12);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(e12) {
    return "string" == typeof e12 ? this._keyToItem.has(e12) : this._keyToItem.has(e12.id);
  }
  isOngoing(e12) {
    const t12 = "string" == typeof e12 ? e12 : e12.id;
    return this.has(t12) && this._queue.isOngoing(t12);
  }
  pause() {
    this._queue.pause();
  }
  push(e12) {
    const t12 = e12.key.id;
    if (this._queue.has(t12))
      return this._queue.get(t12);
    const s11 = this._queue.push(t12), r13 = () => {
      this._keyToItem.delete(t12), this.notifyChange("updating");
    };
    return this._keyToItem.set(t12, e12), s11.then(r13, r13), this.notifyChange("updating"), s11;
  }
  reset() {
    this._queue.reset();
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(e12) {
    if (!this.state)
      return e12.values().next().value;
    const t12 = this.tileInfoView;
    let s11 = Number.NEGATIVE_INFINITY, r13 = Number.POSITIVE_INFINITY;
    e12.forEach((e13) => {
      const t13 = this._keyToItem.get(e13), o13 = this.tileInfoView.getTileScale(t13.key);
      h5.has(o13) || (h5.set(o13, []), s11 = Math.max(o13, s11), r13 = Math.min(o13, r13)), h5.get(o13).push(t13.key), c8.add(o13);
    });
    let o12 = this.state.scale;
    h5.has(o12) || (u5(a9, c8), a9.sort((e13, t13) => e13 - t13), o12 = a9.reduce((e13, t13) => Math.abs(t13 - o12) < Math.abs(e13 - o12) ? t13 : e13, a9[0])), o12 = Math.min(o12, s11), o12 = Math.max(o12, r13);
    const i19 = h5.get(o12), n12 = t12.getClosestInfoForScale(o12), l11 = n12.getColumnForX(this.state.center[0]), p15 = n12.getRowForY(this.state.center[1]);
    return i19.sort((e13, t13) => {
      const s12 = n12.denormalizeCol(e13.col, e13.world), r14 = n12.denormalizeCol(t13.col, t13.world);
      return Math.sqrt((l11 - s12) * (l11 - s12) + (p15 - e13.row) * (p15 - e13.row)) - Math.sqrt((l11 - r14) * (l11 - r14) + (p15 - t13.row) * (p15 - t13.row));
    }), c8.clear(), h5.clear(), i19[0].id;
  }
  _peekByCenterFirst(e12) {
    if (!this.state)
      return e12.values().next().value;
    const t12 = this.tileInfoView, s11 = this.state.center;
    let r13, o12 = Number.POSITIVE_INFINITY;
    return e12.forEach((e13) => {
      const n12 = this._keyToItem.get(e13);
      t12.getTileCoords(l4, n12.key);
      const u14 = m2(l4, s11);
      u14 < o12 && (o12 = u14, r13 = n12.key);
    }), r13.id;
  }
};
e([y({ constructOnly: true })], p5.prototype, "concurrency", void 0), e([y({ constructOnly: true })], p5.prototype, "process", void 0), e([y()], p5.prototype, "state", void 0), e([y({ constructOnly: true })], p5.prototype, "strategy", void 0), e([y({ constructOnly: true })], p5.prototype, "tileInfoView", void 0), e([y({ readOnly: true })], p5.prototype, "updating", null), p5 = e([a("esri.views.2d.tiling.TileQueue")], p5);

// node_modules/@arcgis/core/views/2d/tiling/TileStrategy.js
var o6 = new e3(0, 0, 0, 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/heuristics.js
var i10 = /* @__PURE__ */ new Map();
function t7(r13, t12, c15) {
  const { indicesPerRecord: s11, multiplier: o12, verticesPerRecord: d11 } = i10.get(r13);
  return { recordBytes: c15 * de * Uint32Array.BYTES_PER_ELEMENT, indexBytes: o12 * s11 * c15 * Uint32Array.BYTES_PER_ELEMENT, vertexBytes: o12 * d11 * c15 * t12 };
}
i10.set(E.MARKER, { multiplier: 1, indicesPerRecord: 6, verticesPerRecord: 4 }), i10.set(E.LINE, { multiplier: 1, indicesPerRecord: 24, verticesPerRecord: 8 }), i10.set(E.FILL, { multiplier: 1, indicesPerRecord: 10, verticesPerRecord: 10 }), i10.set(E.TEXT, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 }), i10.set(E.LABEL, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 });

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t8 = 1.25;
var e8 = class {
  get length() {
    return this._pos;
  }
  constructor(t12, e12) {
    this._pos = 0;
    const r13 = e12 ? this._roundToNearest(e12, t12.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(r13), this._buffer = new t12(this._array), this._ctor = t12, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t12, e12) {
    const r13 = Math.round(t12);
    return 1 === e12 ? r13 : r13 + (e12 - r13 % e12);
  }
  _ensureSize(e12) {
    if (this._pos + e12 >= this._buffer.length) {
      const r13 = this._roundToNearest((this._array.byteLength + e12 * this._buffer.BYTES_PER_ELEMENT) * t8, this._buffer.BYTES_PER_ELEMENT), s11 = new ArrayBuffer(r13), i19 = new this._ctor(s11);
      i19.set(this._buffer, 0), this._array = s11, this._buffer = i19, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t12) {
    this._ensureSize(t12);
  }
  writeF32(t12) {
    this._ensureSize(1);
    const e12 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t12, this._pos++, e12;
  }
  push(t12) {
    this._ensureSize(1);
    const e12 = this._pos;
    return this._buffer[this._pos++] = t12, e12;
  }
  writeFixed(t12) {
    this._buffer[this._pos++] = t12;
  }
  setValue(t12, e12) {
    this._buffer[t12] = e12;
  }
  i1616Add(t12, e12, r13) {
    this._i16View[2 * t12] += e12, this._i16View[2 * t12 + 1] += r13;
  }
  getValue(t12) {
    return this._buffer[t12];
  }
  incr(t12) {
    if (this._buffer.length < t12)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t12]++;
  }
  decr(t12) {
    this._buffer[t12]--;
  }
  writeRegion(t12) {
    this._ensureSize(t12.length);
    const e12 = this._pos;
    return this._buffer.set(t12, this._pos), this._pos += t12.length, e12;
  }
  writeManyFrom(t12, e12, r13) {
    this._ensureSize(r13 - e12);
    for (let s11 = e12; s11 !== r13; s11++)
      this.writeFixed(t12._buffer[s11]);
  }
  buffer() {
    const t12 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t12;
  }
  toArray() {
    return [...this._buffer];
  }
  seek(t12) {
    this._pos = t12;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var r5 = class {
  constructor(e12, r13, i19) {
    this._start = { index: 0, vertex: 0 };
    const h10 = t7(e12, r13, i19), c15 = r13 / 4;
    this.geometryType = e12, this._records = new e8(Int32Array, h10.recordBytes), this._indices = new e8(Uint32Array, h10.indexBytes), this._vertices = new e8(Uint32Array, h10.vertexBytes), this._metrics = new e8(Float32Array, 0), this._strideInt = c15;
  }
  serialize(e12) {
    const t12 = this._records.buffer(), s11 = this._indices.buffer(), r13 = this._vertices.buffer(), i19 = this._metrics.length ? this._metrics.buffer() : null, h10 = 4 * this._strideInt;
    return e12.push(t12, s11, r13), { stride: h10, records: t12, indices: s11, vertices: r13, metrics: i19 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get recordCount() {
    return this._records.length / de;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(e12) {
    this._vertices.ensureSize(e12);
  }
  indexEnsureSize(e12) {
    this._indices.ensureSize(e12);
  }
  recordStart() {
    this._start.index = this._indices.length, this._start.vertex = this._vertices.length;
  }
  recordEnd(e12, t12, s11, r13, i19, h10, c15, n12) {
    this._records.push(e12), this._records.push(t12 ?? 0), this._records.push(s11), this._records.push(r13), this._records.push(i19), this._records.push(h10), this._records.push(c15), this._records.writeF32(n12);
  }
  writeIndex(e12) {
    this._indices.push(e12);
  }
  writeVertex(e12) {
    this._vertices.push(e12);
  }
  writeVertexF32(e12) {
    this._vertices.writeF32(e12);
  }
  copyLastFrom(t12, s11, r13) {
    const i19 = t12._records.length - de, h10 = t12._records.getValue(i19), c15 = t12._records.getValue(i19 + 1), n12 = t12._records.getValue(i19 + 2), _5 = t12._records.getValue(i19 + 4), d11 = t12._records.getValue(i19 + 6), o12 = t12._records.getValue(i19 + 7), u14 = this._vertices.length, l11 = (t12._start.vertex - this._vertices.length) / this._strideInt, g7 = this._indices.length, p15 = this.vertexCount;
    for (let e12 = t12._start.index; e12 !== t12._indices.length; e12++) {
      const s12 = t12._indices.getValue(e12);
      this._indices.push(s12 - l11);
    }
    for (let e12 = t12._start.vertex; e12 !== t12._vertices.length; e12++) {
      const s12 = t12._vertices.getValue(e12);
      this._vertices.push(s12);
    }
    for (let e12 = u14; e12 <= this._vertices.length; e12 += this._strideInt)
      this._vertices.i1616Add(e12, s11, r13);
    this._records.push(h10), this._records.push(c15), this._records.push(n12), this._records.push(g7), this._records.push(_5), this._records.push(p15), this._records.push(d11), this._records.push(o12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var u6 = 1;
var c9 = 2;
var o7 = 4;
var _ = 8;
var l6 = 16;
var d3 = 32;
var g2 = 64;
var p6 = 128;
function x2(e12) {
  switch (e12) {
    case u6:
    case _:
    case d3:
      return -1;
    case c9:
    case g2:
      return 0;
    case o7:
    case l6:
    case p6:
      return 1;
  }
}
function m3(e12) {
  switch (e12) {
    case u6:
    case c9:
    case o7:
      return -1;
    case _:
    case l6:
      return 0;
    case d3:
    case g2:
    case p6:
      return 1;
  }
}
var f5 = u6 | _ | d3;
var y3 = o7 | l6 | p6;
var w5 = u6 | c9 | o7;
var v = d3 | g2 | p6;
var E3 = class {
  constructor(e12, t12, r13, i19, s11, n12 = 0) {
    this._hasAggregate = false, this.hasRecords = false, this._data = { self: /* @__PURE__ */ new Map(), neighbors: new Array() }, this._version = 0, this._current = { geometryType: 0, writer: null, overlaps: 0, start: 0, insertAfter: 0, sortKey: 0, id: 0, materialKey: 0, indexStart: 0, vertStart: 0, isDotDensity: false, bufferingEnabled: false, metricBoxLenPointer: 0 }, this.hint = t12, this.tileKey = e12, this._hasAggregate = i19, this._pixelBufferEnabled = s11, this._version = n12, this._symbologyType = r13;
  }
  get hasAggregates() {
    return this._hasAggregate;
  }
  get hasPixelBufferEnabled() {
    return this._pixelBufferEnabled;
  }
  serialize(t12) {
    const r13 = [];
    return r13.push(this._serializeTileVertexData(this.tileKey, this.tileKey, this._data.self)), this._data.neighbors.forEach((i19, s11) => {
      const n12 = 1 << s11, a15 = x2(n12), u14 = m3(n12), c15 = o2(new e3(this.tileKey), a15, u14, t12), o12 = this._serializeTileVertexData(this.tileKey, c15.id, i19.vertexData);
      o12.message.bufferIds = i19.displayIds, r13.push(o12);
    }), r13;
  }
  _serializeTileVertexData(e12, t12, r13) {
    var _a, _b, _c, _d, _e;
    const i19 = new Array();
    return { message: { tileKeyOrigin: e12, tileKey: t12, data: { [E.MARKER]: (_a = r13.get(E.MARKER)) == null ? void 0 : _a.serialize(i19), [E.FILL]: (_b = r13.get(E.FILL)) == null ? void 0 : _b.serialize(i19), [E.LINE]: (_c = r13.get(E.LINE)) == null ? void 0 : _c.serialize(i19), [E.TEXT]: (_d = r13.get(E.TEXT)) == null ? void 0 : _d.serialize(i19), [E.LABEL]: (_e = r13.get(E.LABEL)) == null ? void 0 : _e.serialize(i19) }, version: this._version }, transferList: i19 };
  }
  featureStart(e12, t12) {
    this._current.insertAfter = e12, this._current.sortKey = t12;
  }
  featureEnd() {
  }
  recordStart(e12, t12, r13, i19) {
    this._current.writer = this._getVertexWriter(r13), this._current.overlaps = 0, this._current.indexStart = this._current.writer.indexCount, this._current.vertStart = this._current.writer.vertexCount, this._current.bufferingEnabled = i19, this._current.id = e12, this._current.materialKey = t12, this._current.geometryType = r13, this._current.isDotDensity = false, this._current.writer.recordStart();
  }
  recordCount() {
    return this._current.writer.recordCount;
  }
  vertexCount() {
    return this._current.writer.vertexCount;
  }
  indexCount() {
    return this._current.writer.indexCount;
  }
  vertexEnsureSize(e12) {
    this._current.writer.vertexEnsureSize(e12);
  }
  indexEnsureSize(e12) {
    this._current.writer.indexEnsureSize(e12);
  }
  vertexBounds(e12, t12, r13, i19) {
    this._current.bufferingEnabled && this._addOverlap(e12, t12, r13, i19);
  }
  vertexWrite(e12) {
    this._current.writer.writeVertex(e12);
  }
  vertexWriteF32(e12) {
    this._current.writer.writeVertexF32(e12);
  }
  vertexEnd() {
  }
  vertexWriter() {
    return this._current.writer.vertexWriter;
  }
  indexWrite(e12) {
    this._current.writer.writeIndex(e12);
  }
  indexWriter() {
    return this._current.writer.indexWriter;
  }
  metricWriter() {
    return this._current.writer.metricWriter;
  }
  metricStart(e12, t12, r13, n12, a15, h10, u14, c15) {
    this._current.writer = this._getVertexWriter(E.LABEL);
    const o12 = this._current.writer.metricWriter;
    o12.push(f3(e12)), o12.push(t12), o12.push(r13), o12.push(n12), o12.push(a15), o12.push(h10), o12.push(u14), o12.push(c15), o12.push(255), this._current.metricBoxLenPointer = o12.push(0);
  }
  metricEnd() {
    const e12 = this._current.writer.metricWriter;
    0 === e12.getValue(this._current.metricBoxLenPointer) && e12.seek(e12.length - 10);
  }
  metricBoxWrite(e12, t12, r13, i19) {
    const s11 = this._current.writer.metricWriter;
    s11.incr(this._current.metricBoxLenPointer), s11.push(0), s11.push(0), s11.push(e12), s11.push(t12), s11.push(r13), s11.push(i19);
  }
  recordEnd() {
    const e12 = this._current.vertStart, r13 = this._current.writer.vertexCount - e12;
    if (!r13)
      return false;
    this.hasRecords = true;
    const i19 = this._current.indexStart, h10 = this._current.writer.indexCount - i19;
    if (this._current.writer.recordEnd(this._current.id, this._current.materialKey, this._current.insertAfter, i19, h10, e12, r13, this._current.sortKey), !this._pixelBufferEnabled || this._hasAggregate || 0 === this._current.overlaps || this._current.geometryType === E.LABEL)
      return true;
    const u14 = this._current.writer;
    for (let s11 = 0; s11 < 8; s11++) {
      const e13 = 1 << s11;
      if (!!(this._current.overlaps & e13)) {
        this._data.neighbors[s11] || (this._data.neighbors[s11] = { vertexData: /* @__PURE__ */ new Map(), displayIds: /* @__PURE__ */ new Set() });
        const r14 = this._data.neighbors[s11], i20 = this._current.geometryType;
        if (!r14.vertexData.has(i20)) {
          const e14 = R2(i20, this._symbologyType).geometry, s12 = new r5(i20, e14, fe);
          r14.vertexData.set(i20, s12);
        }
        const h11 = r14.vertexData.get(this._current.geometryType), c15 = 8, o12 = 512 * -x2(e13) * c15, _5 = 512 * -m3(e13) * c15;
        h11 == null ? void 0 : h11.copyLastFrom(u14, o12, _5), r14.displayIds.add(this._current.id);
      }
    }
    return true;
  }
  _addOverlap(e12, t12, i19, s11) {
    const n12 = 255 ^ ((e12 < 0 + i19 ? y3 : e12 >= c3 - i19 ? f5 : y3 | f5) | (t12 < 0 + s11 ? v : t12 >= c3 - s11 ? w5 : v | w5));
    this._current.overlaps |= n12;
  }
  _getVertexWriter(e12) {
    if (!this._data.self.has(e12)) {
      const t12 = this._data.self, r13 = R2(e12, this._symbologyType).geometry;
      t12.set(e12, new r5(e12, r13, this.hint.records));
    }
    return this._data.self.get(e12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/util.js
var n7 = 0;
var o8 = 100;
function t9(n12, o12, t12) {
  return n12[0] = o12[0] - t12[0], n12[1] = o12[1] - t12[1], n12;
}
function i11(n12, o12) {
  return Math.sqrt(n12 * n12 + o12 * o12);
}
function r6(n12) {
  const o12 = i11(n12[0], n12[1]);
  n12[0] /= o12, n12[1] /= o12;
}
function u7(n12, o12) {
  return i11(n12[0] - o12[0], n12[1] - o12[1]);
}
function c10(n12 = 2) {
  return 1 / Math.max(n12, 1);
}
function v2(t12, i19) {
  return [!!(t12 == null ? void 0 : t12.minScale) && i19.scaleToZoom(t12.minScale) || n7, !!(t12 == null ? void 0 : t12.maxScale) && i19.scaleToZoom(t12.maxScale) || o8];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function n8(t12, e12) {
  return t12[e12 + 1];
}
function i12(t12) {
  return t12.length - 1;
}
function r7(t12) {
  let e12 = 0;
  for (let s11 = 0; s11 < i12(t12); s11++)
    e12 += h6(t12, s11);
  return e12;
}
function h6(t12, e12, s11 = 1) {
  const [i19, r13] = n8(t12, e12);
  return Math.sqrt(i19 * i19 + r13 * r13) * s11;
}
var a10 = class _a {
  constructor(t12, e12, s11, n12, i19) {
    this._segments = t12, this._index = e12, this._distance = s11, this._xStart = n12, this._yStart = i19, this._done = false;
  }
  static create(t12) {
    return new _a(t12, 0, 0, t12[0][0], t12[0][1]);
  }
  clone() {
    return new _a(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t12) {
    return this._index === t12._index || t12._index === this._index - 1 && (0 === this._distance || 1 === t12._distance) || t12._index === this._index + 1 && (1 === this._distance || 0 === t12._distance);
  }
  leq(t12) {
    return this._index < t12._index || this._index === t12._index && this._distance <= t12._distance;
  }
  geq(t12) {
    return this._index > t12._index || this._index === t12._index && this._distance >= t12._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t12 = this.dy, e12 = (0 * t12 + -1 * -this.dx) / (1 * this.length);
    let s11 = Math.acos(e12);
    return t12 > 0 && (s11 = 2 * Math.PI - s11), s11;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t12, dy: e12 } = this;
    return Math.sqrt(t12 * t12 + e12 * e12);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < i12(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t12, e12) {
    const s11 = this.backwardLength;
    if (t12 <= s11)
      return this._distance = (s11 - t12) / this.length, this;
    let n12 = this.backwardLength;
    for (; this.prev(); ) {
      if (n12 + this.length > t12)
        return this._seekBackwards(t12 - n12);
      n12 += this.length;
    }
    return this._distance = 0, e12 ? this : null;
  }
  seek(t12, e12 = false) {
    if (t12 < 0)
      return this._seekBackwards(Math.abs(t12), e12);
    if (t12 <= this.remainingLength)
      return this._distance = (this.backwardLength + t12) / this.length, this;
    let s11 = this.remainingLength;
    for (; this.next(); ) {
      if (s11 + this.length > t12)
        return this.seek(t12 - s11, e12);
      s11 += this.length;
    }
    return this._distance = 1, e12 ? this : null;
  }
};
function d4(t12, e12, s11, n12 = true) {
  const i19 = r7(t12), h10 = a10.create(t12), d11 = i19 / 2;
  if (!n12)
    return h10.seek(d11), void s11(h10.clone(), 0, d11 + 0 * e12, i19);
  const c15 = Math.max((i19 - e12) / 2, 0), u14 = Math.floor(c15 / e12), o12 = d11 - u14 * e12;
  h10.seek(o12);
  for (let r13 = -u14; r13 <= u14; r13++)
    h10.x < 512 && h10.x >= 0 && h10.y < 512 && h10.y >= 0 && s11(h10.clone(), r13, d11 + r13 * e12, i19), h10.seek(e12);
}
function o9(t12, e12) {
  const s11 = e12;
  for (let n12 = 0; n12 < t12.length; n12++) {
    let e13 = t12[n12];
    _2(e13, s11);
    const i19 = [];
    i19.push(e13[0]);
    for (let t13 = 1; t13 < e13.length; t13++) {
      const [s12, n13] = e13[t13 - 1], [r13, h10] = e13[t13], a15 = Math.round(r13 - s12), d11 = Math.round(h10 - n13);
      i19.push([a15, d11]);
    }
    t12[n12] = i19, e13 = i19;
  }
  return t12;
}
function _2(n12, i19) {
  const r13 = 1e-6;
  if (i19 <= 0)
    return;
  const h10 = n12.length;
  if (h10 < 3)
    return;
  const a15 = [];
  let d11 = 0;
  a15.push(0);
  for (let e12 = 1; e12 < h10; e12++)
    d11 += u7(n12[e12], n12[e12 - 1]), a15.push(d11);
  i19 = Math.min(i19, 0.2 * d11);
  const c15 = [];
  c15.push(n12[0][0]), c15.push(n12[0][1]);
  const u14 = n12[h10 - 1][0], o12 = n12[h10 - 1][1], _5 = t9([0, 0], n12[0], n12[1]);
  r6(_5), n12[0][0] += i19 * _5[0], n12[0][1] += i19 * _5[1], t9(_5, n12[h10 - 1], n12[h10 - 2]), r6(_5), n12[h10 - 1][0] += i19 * _5[0], n12[h10 - 1][1] += i19 * _5[1];
  for (let t12 = 1; t12 < h10; t12++)
    a15[t12] += i19;
  a15[h10 - 1] += i19;
  const l11 = 0.5 * i19;
  for (let t12 = 1; t12 < h10 - 1; t12++) {
    let e12 = 0, s11 = 0, d12 = 0;
    for (let h11 = t12 - 1; h11 >= 0 && !(a15[h11 + 1] < a15[t12] - l11); h11--) {
      const c16 = l11 + a15[h11 + 1] - a15[t12], u15 = a15[h11 + 1] - a15[h11], o13 = a15[t12] - a15[h11] < l11 ? 1 : c16 / u15;
      if (Math.abs(o13) < r13)
        break;
      const _6 = o13 * o13, g7 = o13 * c16 - 0.5 * _6 * u15, x10 = o13 * u15 / i19, f12 = n12[h11 + 1], y11 = n12[h11][0] - f12[0], k6 = n12[h11][1] - f12[1];
      e12 += x10 / g7 * (f12[0] * o13 * c16 + 0.5 * _6 * (c16 * y11 - u15 * f12[0]) - _6 * o13 * u15 * y11 / 3), s11 += x10 / g7 * (f12[1] * o13 * c16 + 0.5 * _6 * (c16 * k6 - u15 * f12[1]) - _6 * o13 * u15 * k6 / 3), d12 += x10;
    }
    for (let c16 = t12 + 1; c16 < h10 && !(a15[c16 - 1] > a15[t12] + l11); c16++) {
      const h11 = l11 - a15[c16 - 1] + a15[t12], u15 = a15[c16] - a15[c16 - 1], o13 = a15[c16] - a15[t12] < l11 ? 1 : h11 / u15;
      if (Math.abs(o13) < r13)
        break;
      const _6 = o13 * o13, g7 = o13 * h11 - 0.5 * _6 * u15, x10 = o13 * u15 / i19, f12 = n12[c16 - 1], y11 = n12[c16][0] - f12[0], k6 = n12[c16][1] - f12[1];
      e12 += x10 / g7 * (f12[0] * o13 * h11 + 0.5 * _6 * (h11 * y11 - u15 * f12[0]) - _6 * o13 * u15 * y11 / 3), s11 += x10 / g7 * (f12[1] * o13 * h11 + 0.5 * _6 * (h11 * k6 - u15 * f12[1]) - _6 * o13 * u15 * k6 / 3), d12 += x10;
    }
    c15.push(e12 / d12), c15.push(s11 / d12);
  }
  c15.push(u14), c15.push(o12);
  for (let t12 = 0, e12 = 0; t12 < h10; t12++)
    n12[t12][0] = c15[e12++], n12[t12][1] = c15[e12++];
}

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e9 = class {
  static getPlacement(e12, r13, n12, s11, c15, o12) {
    const a15 = g(n12);
    if (!a15)
      return null;
    -1 === r13 && e12.invertY();
    return a15.execute(e12, n12, s11, c15, o12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseTextTemplate.js
var a11 = 8;
var x3 = w3(4, 4);
var _3 = w3(16, 4);
var c11 = w3(4, 2);
var l7 = w3(4, 6);
var u8 = [c11, c11, l7, l7];
var g3 = [c11, l7, c11, l7];
var m4 = [l7, l7, x3, x3];
var f6 = [x3, x3, l7, l7];
var y4 = [l7, x3, l7, x3];
var p7 = [x3, l7, x3, l7];
var w6 = (x10) => class extends x10 {
  constructor(...e12) {
    super(...e12), this._isCIM = false, this._vertexBoundsScale = 1, this.geometryType = E.TEXT, this._aux = x(0, 0, this._referenceSize, this._bitset);
  }
  bindTextInfo(e12, t12) {
    e12 && e12.length ? this._shapingInfo = S2(e12, t12, { scale: this._scale, angle: this._angle, xOffset: this._xOffset, yOffset: this._yOffset, hAlign: this._xAlignD, vAlign: this._yAlignD, maxLineWidth: Math.max(32, Math.min(this._lineWidth, 512)), lineHeight: w2 * Math.max(0.25, Math.min(this._lineHeight, 4)), decoration: this._decoration, isCIM: this._isCIM, hasBackground: !!this._backgroundColor, borderLineSize: this._borderLineSize }) : this._shapingInfo = null;
  }
  _write(e12, t12, r13, i19) {
    const o12 = t12.getDisplayId();
    this._writeGeometry(e12, t12, o12, r13, i19);
  }
  _writeGeometry(e12, t12, r13, i19, o12) {
    const s11 = this._shapingInfo;
    if (null == s11)
      return;
    if (this._textPlacement)
      return this._writePlacedText(e12, r13, s11, i19, t12, o12);
    const n12 = o12 ? o12.asOptimized() : "esriGeometryPolygon" === t12.geometryType ? t12.readCentroid() : t12.readGeometryForDisplay();
    if (null != n12) {
      if (n12.isPoint) {
        const [t13, i20] = n12.coords;
        if (!e12.hasAggregates && e12.hasPixelBufferEnabled && (t13 < 0 || t13 >= 512 || i20 < 0 || i20 >= 512))
          return;
        return this._writeGlyphs(e12, r13, { x: t13, y: i20 }, s11);
      }
      n12.forEachVertex((t13, i20) => this._writeGlyphs(e12, r13, { x: t13, y: i20 }, s11));
    }
  }
  _writePlacedText(i19, o12, s11, n12, h10, d11) {
    const a15 = this._textPlacement, x11 = d11 || a7.fromFeatureSetReaderCIM(h10);
    if (!x11)
      return;
    const _5 = -1, c15 = e9.getPlacement(x11, _5, a15, u2(1), i19.tileKey, n12.geometryEngine);
    if (!c15)
      return;
    const l11 = s11.bounds, u14 = Math.sqrt(l11.height * l11.height + l11.width * l11.width);
    let g7, m8, f12;
    for (; g7 = c15.next(); )
      if (m8 = g7.tx, f12 = -g7.ty, m8 + u14 >= 0 && m8 - u14 < 512 && f12 + u14 >= 0 && f12 - u14 < 512) {
        const e12 = -g7.getAngle();
        s11.setRotation(e12), this._writeGlyphs(i19, o12, { x: m8, y: f12 }, s11), s11.setRotation(-e12);
      }
  }
  _writeGlyphs(e12, t12, r13, i19) {
    const o12 = U.load(this._materialKey), s11 = w3(Math.round(a11 * r13.x), Math.round(a11 * r13.y)), d11 = this._vertexBoundsScale, { bounds: x11, background: _5, glyphs: c15 } = i19;
    c15.length > 0 && (this._borderLineColor || this._backgroundColor) && (o12.textureBinding = c15[0].textureBinding, e12.recordStart(t12, o12.data, this.geometryType, true), this._writeBackgroundGeometry(e12, t12, r13, x11, _5), e12.recordEnd());
    const l11 = 2 * Math.max(x11.width, x11.height);
    for (const n12 of i19.glyphs)
      o12.textureBinding = n12.textureBinding, e12.recordStart(t12, o12.data, this.geometryType, true), e12.vertexBounds(r13.x + x11.x + this._xOffset, r13.y + x11.y - this._yOffset, l11 * d11, l11 * d11), this._writeVertices(e12, t12, s11, n12), e12.recordEnd();
  }
  _writeGlyph(e12, t12, r13, i19, o12) {
    const s11 = U.load(this._materialKey), d11 = w3(Math.round(a11 * r13), Math.round(a11 * i19));
    s11.textureBinding = o12.textureBinding, e12.recordStart(t12, s11.data, this.geometryType, true);
    const x11 = o12.bounds, _5 = this._vertexBoundsScale;
    e12.vertexBounds(r13 + x11.x * _5, i19 + x11.y * _5, x11.width * _5, x11.height * _5), this._writeVertices(e12, t12, d11, o12), e12.recordEnd();
  }
  _writeVertices(e12, t12, r13, i19) {
    const o12 = e12.vertexCount();
    this._writeVertexCommon(e12, t12, r13, i19), e12.vertexWrite(i19.offsets.upperLeft), e12.vertexWrite(i19.texcoords.upperLeft), e12.vertexEnd(), this._writeVertexCommon(e12, t12, r13, i19), e12.vertexWrite(i19.offsets.upperRight), e12.vertexWrite(i19.texcoords.upperRight), e12.vertexEnd(), this._writeVertexCommon(e12, t12, r13, i19), e12.vertexWrite(i19.offsets.lowerLeft), e12.vertexWrite(i19.texcoords.lowerLeft), e12.vertexEnd(), this._writeVertexCommon(e12, t12, r13, i19), e12.vertexWrite(i19.offsets.lowerRight), e12.vertexWrite(i19.texcoords.lowerRight), e12.vertexEnd(), e12.indexWrite(o12 + 0), e12.indexWrite(o12 + 1), e12.indexWrite(o12 + 2), e12.indexWrite(o12 + 1), e12.indexWrite(o12 + 3), e12.indexWrite(o12 + 2);
  }
  _writeVertexCommon(e12, t12, r13, i19) {
    const o12 = this._color, n12 = this._haloColor, h10 = x(0, 0, this._referenceSize, this._bitset), d11 = x(0, 0, this._size, this._haloSize);
    e12.vertexWrite(r13), e12.vertexWrite(t12), e12.vertexWrite(o12), e12.vertexWrite(n12), e12.vertexWrite(d11), e12.vertexWrite(h10), e12.vertexWrite(this._minMaxZoom);
  }
  _writeBackgroundVertex(e12, t12, r13, i19, o12, n12) {
    const h10 = x(0, 1, this._referenceSize, this._bitset), d11 = x(0, 0, this._size, this._haloSize), a15 = x(0, 0, 0, 0);
    e12.vertexWrite(r13), e12.vertexWrite(t12), e12.vertexWrite(i19), e12.vertexWrite(a15), e12.vertexWrite(d11), e12.vertexWrite(h10), e12.vertexWrite(this._minMaxZoom), e12.vertexWrite(o12), e12.vertexWrite(n12), e12.vertexEnd();
  }
  _writeBackgroundQuad(e12, t12, r13, i19, o12, s11) {
    const n12 = e12.vertexCount();
    this._writeBackgroundVertex(e12, t12, r13, i19, o12.upperLeft, s11[0]), this._writeBackgroundVertex(e12, t12, r13, i19, o12.upperRight, s11[1]), this._writeBackgroundVertex(e12, t12, r13, i19, o12.lowerLeft, s11[2]), this._writeBackgroundVertex(e12, t12, r13, i19, o12.lowerRight, s11[3]), e12.indexWrite(n12 + 0), e12.indexWrite(n12 + 1), e12.indexWrite(n12 + 2), e12.indexWrite(n12 + 1), e12.indexWrite(n12 + 3), e12.indexWrite(n12 + 2);
  }
  _writeBackgroundGeometry(e12, t12, r13, i19, o12) {
    const s11 = w3(Math.round(a11 * r13.x), Math.round(a11 * r13.y)), { x: h10, y: d11, width: x11, height: c15 } = i19, l11 = 2 * Math.max(x11, c15);
    if (e12.vertexBounds(r13.x + h10 + this._xOffset, r13.y + d11 - this._yOffset, l11 * this._vertexBoundsScale, l11 * this._vertexBoundsScale), this._backgroundColor) {
      const r14 = [_3, _3, _3, _3];
      this._writeBackgroundQuad(e12, t12, s11, this._backgroundColor, o12.main, r14);
    }
    if (this._borderLineColor || this._backgroundColor) {
      const r14 = !!this._borderLineColor && !!this._borderLineSize && this._borderLineSize > 0, [i20, n12, h11, d12, a15] = r14 ? [u8, u8, g3, g3, this._borderLineColor] : [m4, f6, y4, p7, this._backgroundColor];
      this._writeBackgroundQuad(e12, t12, s11, a15, o12.top, i20), this._writeBackgroundQuad(e12, t12, s11, a15, o12.bot, n12), this._writeBackgroundQuad(e12, t12, s11, a15, o12.left, h11), this._writeBackgroundQuad(e12, t12, s11, a15, o12.right, d12);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMeshTemplate.js
var r8 = class {
  constructor() {
    this._materialKey = null;
  }
  bindFeature(e12, t12, r13) {
  }
  write(r13, s11, i19, f12) {
    if (this._effects && this._effects.length > 0) {
      let i20 = a7.fromFeatureSetReaderCIM(s11);
      if (i20) {
        i20.invertY();
        const e12 = l2.executeEffects(this._effects, i20, r13.tileKey, f12.geometryEngine);
        for (; i20 = e12.next(); )
          i20.invertY(), this._write(r13, s11, f12, i20);
      }
    } else
      this._write(r13, s11, f12);
  }
  _write(e12, t12, r13, s11) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTextTemplate.js
var z2 = 5;
var g4 = class _g extends w6(r8) {
  constructor(e12, l11, a15, d11, _5, u14, b9, x10, g7, C6, M3, p15, S6, j5, L5, y11, T, V2, k6, A3, v6, I2, K3, R3) {
    super(), this._xOffset = u2(S6), this._yOffset = u2(j5), this._decoration = C6 || "none", this._backgroundColor = I2, this._borderLineColor = K3, this._borderLineSize = R3, this._color = _5, this._haloColor = u14, this._haloSize = Math.min(Math.floor(z2 * u2(o(a15))), 127), this._size = Math.min(Math.round(u2(l11)), 127);
    const W = Math.min(Math.round(u2(d11 || l11)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * W)), this._scale = this._size / b2, this._angle = p15, this._justify = s6(b9 || "center"), this._xAlignD = r4(b9 || "center"), this._yAlignD = n4(x10 || "baseline"), this._baseline = "baseline" === (x10 || "baseline"), this._bitset = (g7 === i5.MAP ? 1 : 0) | (M3 ? 1 : 0) << 1;
    const B3 = U.load(e12);
    B3.sdf = true, this._materialKey = B3.data, this._lineWidth = u2(L5) || 512, this._lineHeight = y11 || 1, this._textPlacement = T, this._effects = V2, this._isCIM = k6 ?? false, this._minMaxZoom = w3(Math.round(A3 * me), Math.round(v6 * me));
  }
  static fromText(o12, t12) {
    var _a, _b;
    const r13 = (_a = o12.font) == null ? void 0 : _a.size, n12 = new _g(o12.materialKey, r13, o12.haloSize || 0, r13, o12.color && o5(o12.color) || 0, o12.haloColor && o5(o12.haloColor) || 0, o12.horizontalAlignment, o12.verticalAlignment, i5.SCREEN, (_b = o12.font) == null ? void 0 : _b.decoration, false, o12.angle || 0, o12.xoffset || 0, o12.yoffset || 0, o12.lineWidth || 0, o12.lineHeight || 0, null, null, false, n7, o8, o12.backgroundColor && o5(o12.backgroundColor), o12.borderLineColor && o5(o12.borderLineColor), o12.borderLineSize), [, s11] = i4(o12.text);
    return n12.bindTextInfo(t12 ?? [], s11), n12._vertexBoundsScale = o12.maxVVSize && r13 ? o12.maxVVSize / r13 : 1, n12;
  }
  static fromCIMText(o12, t12, i19) {
    const r13 = o12.scaleFactor || 1, n12 = o12.size * o12.sizeRatio * r13, [s11, l11] = v2(o12.scaleInfo, i19), m8 = new _g(o12.materialKey, n12, o12.outlineSize * o12.sizeRatio, o12.referenceSize, t2(o12.color), t2(o12.outlineColor), o12.horizontalAlignment, o12.verticalAlignment, o12.alignment, o12.decoration, o12.colorLocked ?? false, o12.angle, o12.offsetX * o12.sizeRatio * r13, o12.offsetY * o12.sizeRatio * r13, 512, 1, o12.markerPlacement, o12.effects, true, s11, l11, o12.backgroundColor ? t2(o12.backgroundColor) : void 0, o12.borderLineColor ? t2(o12.borderLineColor) : void 0, o12.borderLineWidth), [, h10] = i4(o12.text);
    return m8.bindTextInfo(t12, h10), m8._vertexBoundsScale = o12.maxVVSize ? o12.maxVVSize / n12 : 1, m8;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLabelTemplate.js
var y5 = s.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate");
var x4 = (t12, i19 = "mapview-labeling") => y5.error(new s2(i19, t12));
var L2 = 1;
var S3 = 0;
var v3 = 4;
var P2 = 25;
function w7(e12, t12) {
  const o12 = !!e12.minScale && t12.scaleToZoom(e12.minScale) || 0;
  return i(o12, 0, 25.5);
}
function M(e12, t12) {
  const o12 = !!e12.maxScale && t12.scaleToZoom(e12.maxScale) || 255;
  return i(o12, 0, 25.5);
}
function Z2(e12) {
  const t12 = /* @__PURE__ */ new Map();
  return (i19) => (t12.has(i19) || t12.set(i19, e12(i19)), t12.get(i19));
}
var k2 = Z2((e12) => {
  let t12 = 0;
  if (0 === e12)
    return 1 / 0;
  for (; !(e12 % 2); )
    t12++, e12 /= 2;
  return t12;
});
var A = (e12) => Math.floor(127 * e12 + 127);
var B = (e12) => Math.floor(10 * e12);
var z3 = (e12) => Math.round(e12 * (254 / 360));
var C3 = class _C extends g4 {
  constructor(e12, t12, i19, r13) {
    var _a, _b, _c;
    super(e12, (_a = i19.font) == null ? void 0 : _a.size, i19.haloSize || 0, (_b = i19.font) == null ? void 0 : _b.size, i19.color && o5(i19.color) || 0, i19.haloColor && o5(i19.haloColor) || 0, i19.horizontalAlignment, i19.verticalAlignment, i8(t12.labelPlacement) ? i5.MAP : i5.SCREEN, (_c = i19.font) == null ? void 0 : _c.decoration, false, i19.angle || 0, i19.xoffset, i19.yoffset, i19.lineWidth, i19.lineHeight, null, null, false, null, null, i19.backgroundColor && o5(i19.backgroundColor), i19.borderLineColor && o5(i19.borderLineColor), i19.borderLineSize), this._outLineLabelAngle = 0, this._refPlacementPadding = 0, this._refPlacementDirX = 0, this._refPlacementDirY = 0, this._refOffsetX = 0, this._refOffsetY = 0, this._zoomLevel = 0, this.geometryType = E.LABEL, this._allowOverrun = t12.allowOverrun ?? false, this._repeatLabel = t12.repeatLabel ?? true, this._labelPosition = t12.labelPosition ?? "curved";
    const n12 = w7(t12, r13), h10 = M(t12, r13), c15 = t12.labelPlacement, [d11, u14] = a6(c15);
    this._xAlignD = d11, this._yAlignD = u14, this._minZoom = n12, this._maxZoom = h10, this._minBackgroundZoom = n12, this._maxBackgroundZoom = h10, this._refPlacementPadding = u2(i19.haloSize) + q, this._repeatLabelDistance = t12.repeatLabelDistance ? u2(t12.repeatLabelDistance) : 128;
    const p15 = Z.load(e12);
    p15.sdf = true, this._materialKey = p15.data;
  }
  static fromLabelClass(e12, t12) {
    if ("esriServerLinePlacementCenterAlong" === e12.labelPlacement) {
      const t13 = e12.symbol;
      t13.xoffset = 0, t13.yoffset = 0, t13.angle = 0, t13.font.decoration = "none";
    }
    return new _C(e12.materialKey, e12, e12.symbol, t12);
  }
  get _shapedBox() {
    return this._shapingInfo.bounds;
  }
  setZoomLevel(e12) {
    this._zoomLevel = e12;
  }
  bindReferenceTemplate(e12) {
    let t12 = c4(this._xAlignD), i19 = o4(this._yAlignD);
    if (this._refOffsetX = 0, this._refOffsetY = 0, null == e12)
      return void (this._refSymbolAndPlacementOffset = x(0, 0, A(t12), A(i19)));
    if ("circle" === e12.boundsType && (t12 || i19)) {
      const e13 = Math.sqrt(t12 * t12 + i19 * i19);
      t12 /= e13, i19 /= e13;
    }
    const o12 = Math.max(e12.height, e12.width), r13 = this._refPlacementPadding * v3;
    this._refSymbolAndPlacementOffset = x(r13, o12, A(t12), A(i19)), this._referenceSize = o12, this._refPlacementDirX = t12, this._refPlacementDirY = i19, this._refOffsetX = e12.xOffset, this._refOffsetY = e12.yOffset;
  }
  _write(e12, t12) {
    if (null == this._shapingInfo)
      return;
    const i19 = this._shapingInfo, o12 = t12.getDisplayId(), r13 = "esriGeometryPolygon" === t12.geometryType ? t12.readLegacyCentroid() : t12.readLegacyGeometry();
    if (r13)
      switch (this._current = { out: e12, inId: o12, inShaping: i19, zoomLevel: this._zoomLevel }, "esriGeometryPolyline" === t12.geometryType && "curved" === this._labelPosition && (this._borderLineColor || this._backgroundColor) && y5.warnOnce("TextSymbol properties 'borderLineColor', 'borderLineSize', and 'backgroundColor' are not supported in curved labels"), t12.geometryType) {
        case "esriGeometryPolyline":
          this._placeLineLabels(r13);
          break;
        case "esriGeometryPoint":
        case "esriGeometryPolygon":
          this._placePointLabels(r13);
          break;
        default:
          x4(`Geometry of type ${t12.geometryType} is not supported`);
      }
  }
  _isVisible(e12, t12) {
    const i19 = B(this._current.zoomLevel);
    return B(e12) <= i19 && i19 <= B(t12);
  }
  _placePointLabels(e12) {
    const { out: t12, inId: i19, inShaping: o12 } = this._current;
    this._writeGlyphs(t12, i19, e12, o12);
  }
  _placeLineLabels(e12) {
    const t12 = o9(e12.paths, this._current.inShaping.bounds.width), i19 = this._placeSubdivGlyphs.bind(this), o12 = (this._shapedBox.width + this._repeatLabelDistance) / (1 << L2);
    for (const r13 of t12)
      d4(r13, o12, i19, this._repeatLabel);
  }
  _placeSubdivGlyphs(e12, t12, i19, o12) {
    const r13 = k2(t12), n12 = this._shapedBox.width / (1 << L2), s11 = Math.sqrt(this._repeatLabelDistance) / (1 << L2), a15 = Math.min(i19, o12 - i19), l11 = this._current.inShaping.isMultiline ? P2 : Math.log2(a15 / (s11 + n12 / 2)), h10 = 0 === t12 ? l11 : Math.min(r13, l11), c15 = Math.max(this._minZoom, this._current.zoomLevel + L2 - h10), m8 = this._current.zoomLevel - c15, _5 = this._shapedBox.width / 2 * 2 ** m8;
    this._current.inShaping.isMultiline ? 0 === t12 && this._placeStraight(e12, c15) : this._allowOverrun && m8 < 0 ? this._placeStraightAlong(e12, this._minZoom) : "parallel" === this._labelPosition ? this._placeStraightAlong(e12, c15) : "curved" === this._labelPosition && this._placeCurved(e12, c15, _5);
  }
  _placeStraight(e12, t12) {
    const { out: i19, inId: o12, inShaping: r13 } = this._current, n12 = Math.ceil(e12.angle * (180 / Math.PI) % 360), s11 = Math.ceil((e12.angle * (180 / Math.PI) + 180) % 360);
    this._outLineLabelAngle = z3(n12), this._writeGlyphs(i19, o12, e12, r13, t12), this._outLineLabelAngle = z3(s11), this._writeGlyphs(i19, o12, e12, r13, t12);
  }
  _placeCurved(e12, t12, i19) {
    const { out: o12, inId: r13 } = this._current;
    o12.metricStart(r13, t12, e12.x, e12.y, 0, 0, 0, 0);
    const n12 = e12.clone(), s11 = e12.angle * (180 / Math.PI) % 360, a15 = (e12.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = z3(s11), this._placeFirst(n12, t12, 1), this._placeBack(e12, n12, t12, i19, 1), this._placeForward(e12, n12, t12, i19, 1), this._outLineLabelAngle = z3(a15), this._placeFirst(n12, t12, 0), this._placeBack(e12, n12, t12, i19, 0), this._placeForward(e12, n12, t12, i19, 0), o12.metricEnd();
  }
  _placeStraightAlong(e12, t12) {
    const { out: i19, inId: o12, inShaping: s11 } = this._current;
    i19.metricStart(o12, t12, e12.x, e12.y, 0, 0, 0, 0);
    const a15 = e12.clone(), l11 = e12.angle * (180 / Math.PI) % 360, h10 = (e12.angle * (180 / Math.PI) + 180) % 360, c15 = s11.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor);
    if (this._maxBackgroundZoom = P2, this._minBackgroundZoom = Math.max(t12, 0), c15) {
      const t13 = Z.load(this._materialKey);
      t13.textureBinding = s11.glyphs[0].textureBinding;
      const a16 = h3(n3(), -e12.angle), [c16, m8] = s11.shapeBackground(a16);
      this._outLineLabelAngle = z3(l11), i19.recordStart(o12, t13.data, this.geometryType, true), this._writeBackgroundGeometry(i19, o12, e12, c16, m8), i19.recordEnd(), this._outLineLabelAngle = z3(h10), i19.recordStart(o12, t13.data, this.geometryType, true), this._writeBackgroundGeometry(i19, o12, e12, c16, m8), i19.recordEnd();
    }
    this._outLineLabelAngle = z3(l11), this._placeFirst(a15, t12, 1, true), this._outLineLabelAngle = z3(h10), this._placeFirst(a15, t12, 0, true), i19.metricEnd();
  }
  _placeBack(e12, t12, i19, o12, r13) {
    const n12 = e12.clone();
    let s11 = e12.backwardLength + S3;
    for (; n12.prev() && !(s11 >= o12); )
      this._placeOnSegment(n12, t12, s11, i19, -1, r13), s11 += n12.length + S3;
  }
  _placeForward(e12, t12, i19, o12, r13) {
    const n12 = e12.clone();
    let s11 = e12.remainingLength + S3;
    for (; n12.next() && !(s11 >= o12); )
      this._placeOnSegment(n12, t12, s11, i19, 1, r13), s11 += n12.length + S3;
  }
  _placeFirst(e12, t12, i19, o12 = false) {
    const r13 = e12, n12 = this._current.inShaping, s11 = n12.glyphs, a15 = this._current.zoomLevel, { out: l11, inId: h10 } = this._current;
    for (const c15 of s11) {
      const s12 = c15.x > n12.bounds.x ? i19 : 1 - i19, m8 = s12 * e12.remainingLength + (1 - s12) * e12.backwardLength, _5 = Math.abs(c15.x + c15.width / 2 - n12.bounds.x), g7 = Math.max(0, a15 + Math.log2(_5 / (m8 + S3))), d11 = Math.max(t12, o12 ? 0 : g7);
      if (c15.maxZoom = P2, c15.angle = e12.angle + (1 - i19) * Math.PI, c15.minZoom = d11, this._writeGlyph(l11, h10, r13.x, r13.y, c15), i19 && this._isVisible(c15.minZoom, c15.maxZoom)) {
        const e13 = c15.bounds;
        l11.metricBoxWrite(e13.center[0], e13.center[1], e13.width, e13.height);
      }
    }
  }
  _placeOnSegment(e12, t12, i19, o12, r13, n12) {
    const s11 = this._current.inShaping.glyphs, { out: a15, inId: l11 } = this._current, h10 = this._current.inShaping, c15 = this._current.zoomLevel, m8 = e12.dx / e12.length, _5 = e12.dy / e12.length, g7 = { x: e12.x + i19 * -r13 * m8, y: e12.y + i19 * -r13 * _5 };
    for (const d11 of s11) {
      const s12 = d11.x > h10.bounds.x ? n12 : 1 - n12;
      if (!(s12 && 1 === r13 || !s12 && -1 === r13))
        continue;
      const m9 = Math.abs(d11.x + d11.width / 2 - h10.bounds.x), _6 = Math.max(0, c15 + Math.log2(m9 / i19) - 0.1), f12 = Math.max(o12, c15 + Math.log2(m9 / (i19 + e12.length + S3)));
      if (0 !== _6 && (d11.angle = e12.angle + (1 - n12) * Math.PI, d11.minZoom = f12, d11.maxZoom = _6, this._writeGlyph(a15, l11, g7.x, g7.y, d11), n12 && this._isVisible(d11.minZoom, d11.maxZoom))) {
        const i20 = d11.bounds, o13 = e12.x - t12.x, r14 = e12.y - t12.y;
        a15.metricBoxWrite(i20.center[0] + o13, i20.center[1] + r14, i20.width, i20.height);
      }
    }
  }
  _writeGlyphs(e12, t12, i19, o12, r13 = this._minZoom) {
    if (i19.x < 0 || i19.x >= 512 || i19.y < 0 || i19.y >= 512)
      return;
    if (o12.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor)) {
      const r14 = Z.load(this._materialKey);
      r14.textureBinding = o12.glyphs[0].textureBinding, e12.recordStart(t12, r14.data, this.geometryType, true), this._writeBackgroundGeometry(e12, t12, i19, o12.bounds, o12.background), e12.recordEnd();
    }
    const n12 = i19.x + this._refOffsetX, s11 = i19.y - this._refOffsetY;
    for (const c15 of o12.glyphs)
      c15.minZoom = r13, c15.maxZoom = this._maxZoom, this._writeGlyph(e12, t12, n12, s11, c15);
    const a15 = this._refPlacementDirX, l11 = this._refPlacementDirY, h10 = o12.boundsT;
    e12.metricStart(t12, r13, n12, s11, a15, l11, this._referenceSize, this._materialKey), e12.metricBoxWrite(h10.center[0], h10.center[1], h10.width, h10.height), e12.metricEnd();
  }
  _writeVertexCommon(e12, t12, i19, o12) {
    const r13 = this._color, n12 = this._haloColor, s11 = x(0, 0, this._size, this._haloSize), a15 = Math.max(o12.minZoom, this._minZoom), l11 = Math.min(o12.maxZoom, this._maxZoom), h10 = x(B(a15), B(l11), this._outLineLabelAngle, 0);
    e12.vertexWrite(i19), e12.vertexWrite(t12), e12.vertexWrite(r13), e12.vertexWrite(n12), e12.vertexWrite(s11), e12.vertexWrite(this._refSymbolAndPlacementOffset), e12.vertexWrite(h10);
  }
  _writeBackgroundVertex(e12, t12, i19, o12, r13, n12) {
    const s11 = x(0, 0, this._size, this._haloSize), a15 = x(0, 0, 0, 0), l11 = x(B(this._minBackgroundZoom), B(this._maxBackgroundZoom), this._outLineLabelAngle, 1);
    e12.vertexWrite(i19), e12.vertexWrite(t12), e12.vertexWrite(o12), e12.vertexWrite(a15), e12.vertexWrite(s11), e12.vertexWrite(this._refSymbolAndPlacementOffset), e12.vertexWrite(l11), e12.vertexWrite(r13), e12.vertexWrite(n12), e12.vertexEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseMarkerTemplate.js
var g5 = 3.14159265359 / 180;
var u9 = 8;
var y6 = (y11) => class extends y11 {
  constructor(...t12) {
    super(...t12), this.angle = 0, this.xOffset = 0, this.yOffset = 0, this.width = 0, this.height = 0, this.boundsType = "square", this._anchorX = 0, this._anchorY = 0, this._computedWidth = 0, this._computedHeight = 0, this._allowBorrowing = true, this._vertexBoundsScaleX = 1, this._vertexBoundsScaleY = 1, this.geometryType = E.MARKER;
  }
  _write(t12, e12, i19, r13) {
    const s11 = e12.getDisplayId();
    t12.recordStart(s11, this._materialKey, this.geometryType, true), this._writeGeometry(t12, e12, s11, i19, r13), t12.recordEnd();
  }
  _writeGeometry(t12, e12, i19, r13, s11) {
    if (null != this._markerPlacement)
      return this._writePlacedMarkers(t12, e12, r13, s11);
    if (this._allowBorrowing = true, !s11 && "esriGeometryPoint" === e12.geometryType) {
      const r14 = e12.getX(), s12 = e12.getY();
      if (!t12.hasAggregates && t12.hasPixelBufferEnabled && (r14 < 0 || r14 >= 513 || s12 < 0 || s12 >= 513))
        return;
      return this._writeVertices(t12, i19, this._getPos(r14, s12), r14, s12);
    }
    const o12 = s11 ? s11.asOptimized() : "esriGeometryPolygon" === e12.geometryType ? e12.readCentroid() : e12.readGeometryForDisplay();
    if (null != o12) {
      if (o12.isPoint) {
        const [e13, r14] = o12.coords;
        if (!t12.hasAggregates && t12.hasPixelBufferEnabled && (e13 < 0 || e13 >= 512 || r14 < 0 || r14 >= 512))
          return;
        return this._writeVertices(t12, i19, this._getPos(e13, r14), e13, r14);
      }
      o12.forEachVertex((e13, r14) => {
        const s12 = 2 * c3;
        e13 < -s12 || e13 >= s12 || r14 < -s12 || r14 >= s12 || this._writeVertices(t12, i19, this._getPos(e13, r14), e13, r14);
      });
    }
  }
  _writePlacedMarkers(e12, i19, r13, s11) {
    const h10 = s11 || a7.fromFeatureSetReaderCIM(i19);
    if (!h10)
      return;
    const n12 = -1, a15 = e9.getPlacement(h10, n12, this._markerPlacement, u2(1), e12.tileKey, r13.geometryEngine);
    if (!a15)
      return;
    this._allowBorrowing = "esriGeometryPolygon" !== i19.geometryType;
    const _5 = i19.getDisplayId(), l11 = n5(), c15 = n3(), d11 = -128, v6 = 640;
    let W = a15.next();
    for (; null != W; ) {
      const t12 = W.tx, i20 = -W.ty;
      t12 >= d11 && t12 <= v6 && i20 >= d11 && i20 <= v6 && (this._applyTransformation(c15, l11, -W.getAngle() / g5), this._writeVertices(e12, _5, this._getPos(t12, i20), t12, i20)), W = a15.next();
    }
  }
  _writeVertices(t12, e12, i19, r13, s11) {
    const o12 = N.load(this._materialKey);
    return o12.symbologyType === S.HEATMAP ? this._writeHeatmapVertices(t12, e12, i19) : this._writeMarkerVertices(t12, e12, o12, i19, r13, s11);
  }
  _writeMarkerVertices(t12, e12, i19, r13, s11, o12) {
    const h10 = i19.vvRotation, n12 = t12.vertexCount();
    let a15 = this._computedWidth * this._vertexBoundsScaleX, x10 = this._computedHeight * this._vertexBoundsScaleY;
    if (this.angle) {
      const t13 = Math.max(a15, x10);
      a15 = t13, x10 = t13;
    }
    if (h10) {
      const t13 = Math.max(this.xOffset, this.yOffset);
      a15 += t13, x10 += t13;
    }
    this._allowBorrowing && t12.vertexBounds(s11 + this.xOffset, o12 - this.yOffset, a15, x10), t12.vertexWrite(r13), t12.vertexWrite(this._offsetUpperLeft), t12.vertexWrite(this._texUpperLeft), t12.vertexWrite(this._bitestAndDistRatio), t12.vertexWrite(e12), t12.vertexWrite(this._fillColor), t12.vertexWrite(this._outlineColor), t12.vertexWrite(this._sizeOutlineWidth), t12.vertexWrite(this._minMaxZoom), t12.vertexEnd(), t12.vertexWrite(r13), t12.vertexWrite(this._offsetUpperRight), t12.vertexWrite(this._texUpperRight), t12.vertexWrite(this._bitestAndDistRatio), t12.vertexWrite(e12), t12.vertexWrite(this._fillColor), t12.vertexWrite(this._outlineColor), t12.vertexWrite(this._sizeOutlineWidth), t12.vertexWrite(this._minMaxZoom), t12.vertexEnd(), t12.vertexWrite(r13), t12.vertexWrite(this._offsetBottomLeft), t12.vertexWrite(this._texBottomLeft), t12.vertexWrite(this._bitestAndDistRatio), t12.vertexWrite(e12), t12.vertexWrite(this._fillColor), t12.vertexWrite(this._outlineColor), t12.vertexWrite(this._sizeOutlineWidth), t12.vertexWrite(this._minMaxZoom), t12.vertexEnd(), t12.vertexWrite(r13), t12.vertexWrite(this._offsetBottomRight), t12.vertexWrite(this._texBottomRight), t12.vertexWrite(this._bitestAndDistRatio), t12.vertexWrite(e12), t12.vertexWrite(this._fillColor), t12.vertexWrite(this._outlineColor), t12.vertexWrite(this._sizeOutlineWidth), t12.vertexWrite(this._minMaxZoom), t12.vertexEnd(), this._writeIndices(t12, n12);
  }
  _writeHeatmapVertices(t12, e12, i19) {
    const r13 = t12.vertexCount();
    t12.vertexWrite(i19), t12.vertexWrite(this._offsetUpperLeft), t12.vertexWrite(e12), t12.vertexEnd(), t12.vertexWrite(i19), t12.vertexWrite(this._offsetUpperRight), t12.vertexWrite(e12), t12.vertexEnd(), t12.vertexWrite(i19), t12.vertexWrite(this._offsetBottomLeft), t12.vertexWrite(e12), t12.vertexEnd(), t12.vertexWrite(i19), t12.vertexWrite(this._offsetBottomRight), t12.vertexWrite(e12), t12.vertexEnd(), this._writeIndices(t12, r13);
  }
  _writeIndices(t12, e12) {
    t12.indexWrite(e12 + 0), t12.indexWrite(e12 + 1), t12.indexWrite(e12 + 2), t12.indexWrite(e12 + 1), t12.indexWrite(e12 + 3), t12.indexWrite(e12 + 2);
  }
  _applyTransformation(t12, o12, x10 = 0) {
    x10 ? h3(t12, g5 * x10) : n2(t12), i7(t12, t12, t4(this.xOffset, -this.yOffset)), this.angle && e5(t12, t12, g5 * this.angle);
    const f12 = this._computedWidth, m8 = this._computedHeight, _5 = -(0.5 + this._anchorX) * f12, l11 = -(0.5 - this._anchorY) * m8;
    r2(o12, _5, l11), z(o12, o12, t12), this._offsetUpperLeft = w3(16 * o12[0], 16 * o12[1]), r2(o12, _5 + f12, l11), z(o12, o12, t12), this._offsetUpperRight = w3(16 * o12[0], 16 * o12[1]), r2(o12, _5, l11 + m8), z(o12, o12, t12), this._offsetBottomLeft = w3(16 * o12[0], 16 * o12[1]), r2(o12, _5 + f12, l11 + m8), z(o12, o12, t12), this._offsetBottomRight = w3(16 * o12[0], 16 * o12[1]);
  }
  _computeSize(t12, e12, i19, r13, s11, o12, h10, n12) {
    const a15 = t12 * i19, x10 = e12 * i19;
    if (!!o12.sdf && !h10) {
      const i20 = n12 && t12 > e12 ? a15 : t12, s12 = e12, o13 = r13 + 2 * 1;
      t12 = Math.min(i20 + o13, a15), e12 = Math.min(s12 + o13, x10);
    } else
      t12 = a15, e12 = x10;
    const f12 = ce / Math.max(a15, x10), m8 = 0.5 * (a15 - t12) * f12, l11 = 0.5 * (x10 - e12) * f12, d11 = o12.rect.x + ae + m8, v6 = o12.rect.y + ae + l11, p15 = d11 + o12.width - 2 * m8, g7 = v6 + o12.height - 2 * l11, u14 = Math.floor(d11), y12 = Math.floor(v6), w11 = Math.ceil(p15), M3 = Math.ceil(g7);
    t12 *= (w11 - u14) / (p15 - d11), e12 *= (M3 - y12) / (g7 - v6), this._texUpperLeft = w3(u14, y12), this._texUpperRight = w3(w11, y12), this._texBottomLeft = w3(u14, M3), this._texBottomRight = w3(w11, M3), this._anchorX *= a15 / t12, this._anchorY *= x10 / e12, t12 *= s11, e12 *= s11, this._computedWidth = t12, this._computedHeight = e12;
  }
  _getPos(t12, e12) {
    return w3(Math.round(u9 * t12), Math.round(u9 * e12));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMarkerTemplate.js
var z4 = class _z extends y6(r8) {
  constructor(t12, r13, s11, a15, d11, p15, y11, V2, _5, g7, z6, b9, k6, w11, B3, j5, C6, P4, v6, E5, T, A3, L5, R3) {
    super(), this.angle = a15, this.height = y11, this.width = p15, this.xOffset = r13 * v6, this.yOffset = s11 * v6, this._markerPlacement = E5 || void 0, this._effects = T || void 0, this._anchorX = j5, this._anchorY = C6, this._minMaxZoom = w3(Math.round(A3 * me), Math.round(L5 * me));
    const K3 = (w11 === i5.MAP ? ne : le) | (z6 ? pe : 0) | (k6 ? we : 0) | (b9 ? xe : 0), W = B3 && B3.sdf, X = N.load(t12);
    X.sdf = W, X.pattern = true, X.textureBinding = B3.textureBinding, this._materialKey = X.data, this._fillColor = d11, this._outlineColor = _5, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * p15), 255)), Math.round(Math.min(Math.sqrt(128 * y11), 255)), Math.round(Math.min(Math.sqrt(128 * g7), 255)), Math.round(Math.min(Math.sqrt(128 * V2), 255))), X.symbologyType === S.PIE_CHART ? (p15 *= P4 * v6, y11 *= P4 * v6, this._computedWidth = p15, this._computedHeight = y11, this._texUpperLeft = w3(0, 1), this._texUpperRight = w3(1, 1), this._texBottomLeft = w3(0, 0), this._texBottomRight = w3(1, 0)) : this._computeSize(p15, y11, P4, g7, v6, B3, X.hasSizeVV(), R3);
    const q3 = Math.round(64 * P4);
    this._bitestAndDistRatio = w3(K3, q3);
    const Y = n5(), H = n3();
    this._applyTransformation(H, Y);
  }
  static fromCIMMarker(e12, o12, r13) {
    const a15 = o12 && o12.width || 1, n12 = o12 && o12.height || 1, l11 = e12.size, h10 = a15 / n12 * e12.scaleX, m8 = e12.scaleSymbolsProportionally && e12.frameHeight ? l11 / e12.frameHeight : 1, c15 = t2(e12.color), u14 = t2(e12.outlineColor), d11 = u2(l11), f12 = d11 * h10, M3 = u2(e12.offsetX || 0), S6 = u2(e12.offsetY || 0), x10 = u2(e12.outlineWidth || 0) * m8, y11 = e12.alignment || i5.SCREEN, V2 = u2(e12.referenceSize), [_5, g7] = v2(e12.scaleInfo, r13);
    let b9 = e12.rotation || 0;
    e12.rotateClockwise || (b9 = -b9);
    let k6 = 0, w11 = 0;
    const B3 = e12.anchorPoint;
    B3 && (e12.isAbsoluteAnchorPoint ? l11 && (k6 = B3.x / (l11 * h10), w11 = B3.y / l11) : (k6 = B3.x, w11 = B3.y));
    const j5 = new _z(e12.materialKey, M3, S6, b9, c15, f12, d11, V2, u14, x10, e12.colorLocked, e12.scaleSymbolsProportionally, false, y11, o12, k6, w11, e12.sizeRatio, e12.scaleFactor ?? 1, e12.markerPlacement, e12.effects, _5, g7, true);
    return j5._vertexBoundsScaleX = e12.maxVVSize ? e12.maxVVSize / f12 : 1, j5._vertexBoundsScaleY = e12.maxVVSize ? e12.maxVVSize / d11 : 1, j5;
  }
  static fromPictureMarker(e12, o12) {
    const r13 = Math.round(u2(e12.width)), s11 = Math.round(u2(e12.height)), a15 = a5, n12 = Math.round(u2(e12.xoffset || 0)), l11 = Math.round(u2(e12.yoffset || 0)), h10 = new _z(e12.materialKey, n12, l11, e12.angle, a15, r13, s11, s11, 0, 0, false, false, false, i5.SCREEN, o12, 0, 0, 1, 1, null, null, n7, o8, false);
    return h10._vertexBoundsScaleX = e12.maxVVSize ? e12.maxVVSize / e12.width : 1, h10._vertexBoundsScaleY = e12.maxVVSize ? e12.maxVVSize / e12.height : 1, h10;
  }
  static fromSimpleMarker(e12, o12) {
    const r13 = e12.style, s11 = o5(e12.color), n12 = Math.round(u2(e12.size));
    let l11 = n12;
    "esriSMSTriangle" === r13 && (l11 *= o12.height / o12.width);
    const h10 = Math.round(u2(e12.xoffset || 0)), m8 = Math.round(u2(e12.yoffset || 0)), c15 = e12.outline, u14 = 0 | ((c15 == null ? void 0 : c15.color) && o5(c15.color)), d11 = 0 | ((c15 == null ? void 0 : c15.width) && Math.round(u2(c15.width))), f12 = new _z(e12.materialKey, h10, m8, e12.angle ?? 0, s11, n12, l11, l11, u14, d11, false, false, "esriSMSCross" === r13 || "esriSMSX" === r13, i5.SCREEN, o12, 0, 0, 2, 1, null, null, n7, o8, false);
    return f12.boundsType = "esriSMSCircle" === r13 ? "circle" : "square", f12._vertexBoundsScaleX = e12.maxVVSize ? e12.maxVVSize / e12.size : 1, f12._vertexBoundsScaleY = e12.maxVVSize ? e12.maxVVSize / e12.size : 1, f12;
  }
  static fromLineSymbolMarker(e12, o12) {
    const s11 = o5(e12.color), n12 = 6, l11 = Math.round(u2(n12 * e12.lineWidth)), h10 = l11, m8 = "cross" === e12.style || "x" === e12.style;
    let c15;
    switch (e12.placement) {
      case "begin-end":
        c15 = o3.Both;
        break;
      case "begin":
        c15 = o3.JustBegin;
        break;
      case "end":
        c15 = o3.JustEnd;
        break;
      default:
        c15 = o3.None;
    }
    const u14 = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: c15, offsetAlongLine: 0 }, d11 = new _z(e12.materialKey, 0, 0, 0, s11, l11, h10, h10 / n12, s11, m8 ? Math.round(u2(e12.lineWidth)) : 0, false, false, m8, i5.MAP, o12, 0, 0, 2, 1, u14, null, n7, o8, false);
    return d11.boundsType = "circle" === e12.style ? "circle" : "square", d11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e10(e12, t12, r13, i19, u14, o12, l11) {
  D = 0;
  const f12 = (i19 - r13) * o12, p15 = u14 && u14.length, c15 = p15 ? (u14[0] - r13) * o12 : f12;
  let v6, s11, h10, d11, Z4, a15 = n9(t12, r13, i19, 0, c15, o12, true);
  if (a15 && a15.next !== a15.prev) {
    if (p15 && (a15 = y7(t12, r13, i19, u14, a15, o12)), f12 > 80 * o12) {
      v6 = h10 = t12[0 + r13 * o12], s11 = d11 = t12[1 + r13 * o12];
      for (let e13 = o12; e13 < c15; e13 += o12) {
        const n12 = t12[e13 + r13 * o12], x10 = t12[e13 + 1 + r13 * o12];
        v6 = Math.min(v6, n12), s11 = Math.min(s11, x10), h10 = Math.max(h10, n12), d11 = Math.max(d11, x10);
      }
      Z4 = Math.max(h10 - v6, d11 - s11), Z4 = 0 !== Z4 ? 1 / Z4 : 0;
    }
    x5(a15, e12, o12, v6, s11, Z4, l11, 0);
  }
}
function n9(e12, n12, t12, x10, r13, i19, l11) {
  let y11;
  if (l11 === Z3(e12, n12, t12, x10, r13, i19) > 0)
    for (let o12 = x10; o12 < r13; o12 += i19)
      y11 = u10(o12 + n12 * i19, e12[o12 + n12 * i19], e12[o12 + 1 + n12 * i19], y11);
  else
    for (let o12 = r13 - i19; o12 >= x10; o12 -= i19)
      y11 = u10(o12 + n12 * i19, e12[o12 + n12 * i19], e12[o12 + 1 + n12 * i19], y11);
  return y11 && M2(y11, y11.next) && (o10(y11), y11 = y11.next), y11;
}
function t10(e12, n12 = e12) {
  if (!e12)
    return e12;
  let t12, x10 = e12;
  do {
    if (t12 = false, x10.steiner || !M2(x10, x10.next) && 0 !== s8(x10.prev, x10, x10.next))
      x10 = x10.next;
    else {
      if (o10(x10), x10 = n12 = x10.prev, x10 === x10.next)
        break;
      t12 = true;
    }
  } while (t12 || x10 !== n12);
  return n12;
}
function x5(e12, n12, u14, l11, y11, f12, p15, v6) {
  if (!e12)
    return;
  !v6 && f12 && (e12 = c12(e12, l11, y11, f12));
  let s11 = e12;
  for (; e12.prev !== e12.next; ) {
    const c15 = e12.prev, h10 = e12.next;
    if (f12 ? i13(e12, l11, y11, f12) : r9(e12))
      n12.push(c15.index / u14 + p15), n12.push(e12.index / u14 + p15), n12.push(h10.index / u14 + p15), o10(e12), e12 = h10.next, s11 = h10.next;
    else if ((e12 = h10) === s11) {
      v6 ? 1 === v6 ? x5(e12 = b5(e12, n12, u14, p15), n12, u14, l11, y11, f12, p15, 2) : 2 === v6 && g6(e12, n12, u14, l11, y11, f12, p15) : x5(t10(e12), n12, u14, l11, y11, f12, p15, 1);
      break;
    }
  }
}
function r9(e12) {
  const n12 = e12.prev, t12 = e12, x10 = e12.next;
  if (s8(n12, t12, x10) >= 0)
    return false;
  let r13 = e12.next.next;
  const i19 = r13;
  let u14 = 0;
  for (; r13 !== e12.prev && (0 === u14 || r13 !== i19); ) {
    if (u14++, a12(n12.x, n12.y, t12.x, t12.y, x10.x, x10.y, r13.x, r13.y) && s8(r13.prev, r13, r13.next) >= 0)
      return false;
    r13 = r13.next;
  }
  return true;
}
function i13(e12, n12, t12, x10) {
  const r13 = e12.prev, i19 = e12, u14 = e12.next;
  if (s8(r13, i19, u14) >= 0)
    return false;
  const o12 = r13.x < i19.x ? r13.x < u14.x ? r13.x : u14.x : i19.x < u14.x ? i19.x : u14.x, l11 = r13.y < i19.y ? r13.y < u14.y ? r13.y : u14.y : i19.y < u14.y ? i19.y : u14.y, y11 = r13.x > i19.x ? r13.x > u14.x ? r13.x : u14.x : i19.x > u14.x ? i19.x : u14.x, f12 = r13.y > i19.y ? r13.y > u14.y ? r13.y : u14.y : i19.y > u14.y ? i19.y : u14.y, p15 = z5(o12, l11, n12, t12, x10), c15 = z5(y11, f12, n12, t12, x10);
  let v6 = e12.prevZ, h10 = e12.nextZ;
  for (; v6 && v6.z >= p15 && h10 && h10.z <= c15; ) {
    if (v6 !== e12.prev && v6 !== e12.next && a12(r13.x, r13.y, i19.x, i19.y, u14.x, u14.y, v6.x, v6.y) && s8(v6.prev, v6, v6.next) >= 0)
      return false;
    if (v6 = v6.prevZ, h10 !== e12.prev && h10 !== e12.next && a12(r13.x, r13.y, i19.x, i19.y, u14.x, u14.y, h10.x, h10.y) && s8(h10.prev, h10, h10.next) >= 0)
      return false;
    h10 = h10.nextZ;
  }
  for (; v6 && v6.z >= p15; ) {
    if (v6 !== e12.prev && v6 !== e12.next && a12(r13.x, r13.y, i19.x, i19.y, u14.x, u14.y, v6.x, v6.y) && s8(v6.prev, v6, v6.next) >= 0)
      return false;
    v6 = v6.prevZ;
  }
  for (; h10 && h10.z <= c15; ) {
    if (h10 !== e12.prev && h10 !== e12.next && a12(r13.x, r13.y, i19.x, i19.y, u14.x, u14.y, h10.x, h10.y) && s8(h10.prev, h10, h10.next) >= 0)
      return false;
    h10 = h10.nextZ;
  }
  return true;
}
function u10(e12, n12, t12, x10) {
  const r13 = q2.create(e12, n12, t12);
  return x10 ? (r13.next = x10.next, r13.prev = x10, x10.next.prev = r13, x10.next = r13) : (r13.prev = r13, r13.next = r13), r13;
}
function o10(e12) {
  e12.next.prev = e12.prev, e12.prev.next = e12.next, e12.prevZ && (e12.prevZ.nextZ = e12.nextZ), e12.nextZ && (e12.nextZ.prevZ = e12.prevZ);
}
function l8(e12) {
  let n12 = e12, t12 = e12;
  do {
    (n12.x < t12.x || n12.x === t12.x && n12.y < t12.y) && (t12 = n12), n12 = n12.next;
  } while (n12 !== e12);
  return t12;
}
function y7(e12, t12, x10, r13, i19, u14) {
  const o12 = new Array();
  for (let y11 = 0, f12 = r13.length; y11 < f12; y11++) {
    const i20 = n9(e12, t12, x10, r13[y11] * u14, y11 < f12 - 1 ? r13[y11 + 1] * u14 : x10 * u14, u14, false);
    i20 === i20.next && (i20.steiner = true), o12.push(l8(i20));
  }
  o12.sort(m5);
  for (const n12 of o12)
    i19 = f7(n12, i19);
  return i19;
}
function f7(e12, n12) {
  const x10 = p8(e12, n12);
  if (!x10)
    return n12;
  const r13 = j2(x10, e12);
  return t10(r13, r13.next), t10(x10, x10.next);
}
function p8(e12, n12) {
  let t12 = n12;
  const x10 = e12.x, r13 = e12.y;
  let i19, u14 = -1 / 0;
  do {
    if (r13 <= t12.y && r13 >= t12.next.y && t12.next.y !== t12.y) {
      const e13 = t12.x + (r13 - t12.y) * (t12.next.x - t12.x) / (t12.next.y - t12.y);
      if (e13 <= x10 && e13 > u14) {
        if (u14 = e13, e13 === x10) {
          if (r13 === t12.y)
            return t12;
          if (r13 === t12.next.y)
            return t12.next;
        }
        i19 = t12.x < t12.next.x ? t12 : t12.next;
      }
    }
    t12 = t12.next;
  } while (t12 !== n12);
  if (!i19)
    return null;
  if (x10 === u14)
    return i19.prev;
  const o12 = i19, l11 = i19.x, y11 = i19.y;
  let f12, p15 = 1 / 0;
  for (t12 = i19.next; t12 !== o12; )
    x10 >= t12.x && t12.x >= l11 && x10 !== t12.x && a12(r13 < y11 ? x10 : u14, r13, l11, y11, r13 < y11 ? u14 : x10, r13, t12.x, t12.y) && (f12 = Math.abs(r13 - t12.y) / (x10 - t12.x), (f12 < p15 || f12 === p15 && t12.x > i19.x) && w8(t12, e12) && (i19 = t12, p15 = f12)), t12 = t12.next;
  return i19;
}
function c12(e12, n12, t12, x10) {
  let r13;
  for (; r13 !== e12; r13 = r13.next) {
    if (r13 = r13 || e12, null === r13.z && (r13.z = z5(r13.x, r13.y, n12, t12, x10)), r13.prev.next !== r13 || r13.next.prev !== r13)
      return r13.prev.next = r13, r13.next.prev = r13, c12(e12, n12, t12, x10);
    r13.prevZ = r13.prev, r13.nextZ = r13.next;
  }
  return e12.prevZ.nextZ = null, e12.prevZ = null, v4(e12);
}
function v4(e12) {
  let n12, t12 = 1;
  for (; ; ) {
    let x10, r13 = e12;
    e12 = null, n12 = null;
    let i19 = 0;
    for (; r13; ) {
      i19++, x10 = r13;
      let u14 = 0;
      for (; u14 < t12 && x10; u14++)
        x10 = x10.nextZ;
      let o12 = t12;
      for (; u14 > 0 || o12 > 0 && x10; ) {
        let t13;
        0 === u14 ? (t13 = x10, x10 = x10.nextZ, o12--) : 0 !== o12 && x10 ? r13.z <= x10.z ? (t13 = r13, r13 = r13.nextZ, u14--) : (t13 = x10, x10 = x10.nextZ, o12--) : (t13 = r13, r13 = r13.nextZ, u14--), n12 ? n12.nextZ = t13 : e12 = t13, t13.prevZ = n12, n12 = t13;
      }
      r13 = x10;
    }
    if (n12.nextZ = null, t12 *= 2, i19 < 2)
      return e12;
  }
}
function s8(e12, n12, t12) {
  return (n12.y - e12.y) * (t12.x - n12.x) - (n12.x - e12.x) * (t12.y - n12.y);
}
function h7(e12, n12, t12, x10) {
  return !!(M2(e12, n12) && M2(t12, x10) || M2(e12, x10) && M2(t12, n12)) || s8(e12, n12, t12) > 0 != s8(e12, n12, x10) > 0 && s8(t12, x10, e12) > 0 != s8(t12, x10, n12) > 0;
}
function d5(e12, n12) {
  let t12 = e12;
  do {
    if (t12.index !== e12.index && t12.next.index !== e12.index && t12.index !== n12.index && t12.next.index !== n12.index && h7(t12, t12.next, e12, n12))
      return true;
    t12 = t12.next;
  } while (t12 !== e12);
  return false;
}
function Z3(e12, n12, t12, x10, r13, i19) {
  let u14 = 0;
  for (let o12 = x10, l11 = r13 - i19; o12 < r13; o12 += i19)
    u14 += (e12[l11 + n12 * i19] - e12[o12 + n12 * i19]) * (e12[o12 + 1 + n12 * i19] + e12[l11 + 1 + n12 * i19]), l11 = o12;
  return u14;
}
function a12(e12, n12, t12, x10, r13, i19, u14, o12) {
  return (r13 - u14) * (n12 - o12) - (e12 - u14) * (i19 - o12) >= 0 && (e12 - u14) * (x10 - o12) - (t12 - u14) * (n12 - o12) >= 0 && (t12 - u14) * (i19 - o12) - (r13 - u14) * (x10 - o12) >= 0;
}
function w8(e12, n12) {
  return s8(e12.prev, e12, e12.next) < 0 ? s8(e12, n12, e12.next) >= 0 && s8(e12, e12.prev, n12) >= 0 : s8(e12, n12, e12.prev) < 0 || s8(e12, e12.next, n12) < 0;
}
function z5(e12, n12, t12, x10, r13) {
  return (e12 = 1431655765 & ((e12 = 858993459 & ((e12 = 252645135 & ((e12 = 16711935 & ((e12 = 32767 * (e12 - t12) * r13) | e12 << 8)) | e12 << 4)) | e12 << 2)) | e12 << 1)) | (n12 = 1431655765 & ((n12 = 858993459 & ((n12 = 252645135 & ((n12 = 16711935 & ((n12 = 32767 * (n12 - x10) * r13) | n12 << 8)) | n12 << 4)) | n12 << 2)) | n12 << 1)) << 1;
}
function M2(e12, n12) {
  return e12.x === n12.x && e12.y === n12.y;
}
function m5(e12, n12) {
  return e12.x - n12.x;
}
function b5(e12, n12, t12, x10) {
  let r13 = e12;
  do {
    const i19 = r13.prev, u14 = r13.next.next;
    !M2(i19, u14) && h7(i19, r13, r13.next, u14) && w8(i19, u14) && w8(u14, i19) && (n12.push(i19.index / t12 + x10), n12.push(r13.index / t12 + x10), n12.push(u14.index / t12 + x10), o10(r13), o10(r13.next), r13 = e12 = u14), r13 = r13.next;
  } while (r13 !== e12);
  return r13;
}
function g6(e12, n12, r13, i19, u14, o12, l11) {
  let y11 = e12;
  do {
    let e13 = y11.next.next;
    for (; e13 !== y11.prev; ) {
      if (y11.index !== e13.index && k3(y11, e13)) {
        let f12 = j2(y11, e13);
        return y11 = t10(y11, y11.next), f12 = t10(f12, f12.next), x5(y11, n12, r13, i19, u14, o12, l11, 0), void x5(f12, n12, r13, i19, u14, o12, l11, 0);
      }
      e13 = e13.next;
    }
    y11 = y11.next;
  } while (y11 !== e12);
}
function k3(e12, n12) {
  return e12.next.index !== n12.index && e12.prev.index !== n12.index && !d5(e12, n12) && w8(e12, n12) && w8(n12, e12) && A2(e12, n12);
}
function A2(e12, n12) {
  let t12 = e12, x10 = false;
  const r13 = (e12.x + n12.x) / 2, i19 = (e12.y + n12.y) / 2;
  do {
    t12.y > i19 != t12.next.y > i19 && t12.next.y !== t12.y && r13 < (t12.next.x - t12.x) * (i19 - t12.y) / (t12.next.y - t12.y) + t12.x && (x10 = !x10), t12 = t12.next;
  } while (t12 !== e12);
  return x10;
}
function j2(e12, n12) {
  const t12 = q2.create(e12.index, e12.x, e12.y), x10 = q2.create(n12.index, n12.x, n12.y), r13 = e12.next, i19 = n12.prev;
  return e12.next = n12, n12.prev = e12, t12.next = r13, r13.prev = t12, x10.next = t12, t12.prev = x10, i19.next = x10, x10.prev = i19, x10;
}
var q2 = class _q {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e12, n12, t12) {
    const x10 = D < B2.length ? B2[D++] : new _q();
    return x10.index = e12, x10.x = n12, x10.y = t12, x10.prev = null, x10.next = null, x10.z = null, x10.prevZ = null, x10.nextZ = null, x10.steiner = false, x10;
  }
};
var B2 = new Array();
var C4 = 8096;
var D = 0;
for (let E5 = 0; E5 < C4; E5++)
  B2.push(new q2());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var i15 = 1e-5;
var f8 = new e6(0, 0, 0, 1, 0);
var u11 = new e6(0, 0, 0, 1, 0);
function c13(t12, e12, n12) {
  let o12 = 0;
  for (let r13 = 1; r13 < n12; r13++) {
    const n13 = t12[2 * (e12 + r13 - 1)], s11 = t12[2 * (e12 + r13 - 1) + 1];
    o12 += (t12[2 * (e12 + r13)] - n13) * (t12[2 * (e12 + r13) + 1] + s11);
  }
  return o12;
}
function h8(t12, e12, n12, o12, r13) {
  let s11 = 0;
  const l11 = 2;
  for (let i19 = n12; i19 < o12; i19 += 3) {
    const n13 = (t12[i19] - r13) * l11, o13 = (t12[i19 + 1] - r13) * l11, f12 = (t12[i19 + 2] - r13) * l11;
    s11 += Math.abs((e12[n13] - e12[f12]) * (e12[o13 + 1] - e12[n13 + 1]) - (e12[n13] - e12[o13]) * (e12[f12 + 1] - e12[n13 + 1]));
  }
  return s11;
}
function a13(t12, e12) {
  const { coords: n12, lengths: o12, hasIndeterminateRingOrder: r13 } = e12, s11 = 0, f12 = t12;
  if (r13)
    return false;
  let u14 = 0;
  for (let a15 = 0; a15 < o12.length; ) {
    let t13 = a15, e13 = o12[a15], r14 = c13(n12, u14, e13);
    const g7 = [];
    for (; ++t13 < o12.length; ) {
      const s12 = o12[t13], l11 = c13(n12, u14 + e13, s12);
      if (!(l11 > 0))
        break;
      r14 += l11, g7.push(u14 + e13), e13 += s12;
    }
    const p15 = f12.length;
    e10(f12, n12, u14, u14 + e13, g7, 2, s11);
    const m8 = h8(f12, n12, p15, f12.length, s11), d11 = Math.abs(r14);
    if (Math.abs((m8 - d11) / Math.max(1e-7, d11)) > i15)
      return f12.length = 0, false;
    a15 = t13, u14 += e13;
  }
  return true;
}
function p9(t12) {
  const { coords: n12, lengths: o12 } = t12, { buffer: r13 } = r3(n12, o12);
  return r13;
}
function m6(t12, e12, n12) {
  let o12 = 0;
  for (let r13 = 0; r13 < t12.lengths.length; r13++) {
    const s11 = t12.lengths[r13];
    for (let r14 = 0; r14 < s11; r14++) {
      const s12 = t12.coords[2 * (r14 + o12)], l11 = t12.coords[2 * (r14 + o12) + 1];
      if (s12 < e12 || s12 > n12 || l11 < e12 || l11 > n12)
        return true;
    }
    o12 += s11;
  }
  return false;
}
function d6(t12, e12) {
  if (null == t12)
    return null;
  if (!m6(t12, -128, c3 + 128))
    return t12;
  f8.setPixelMargin(e12), f8.reset(t3.Polygon);
  let n12 = 0;
  for (let o12 = 0; o12 < t12.lengths.length; o12++) {
    const e13 = t12.lengths[o12];
    let r13 = t12.coords[2 * (0 + n12)], s11 = t12.coords[2 * (0 + n12) + 1];
    f8.moveTo(r13, s11);
    for (let o13 = 1; o13 < e13; o13++)
      r13 = t12.coords[2 * (o13 + n12)], s11 = t12.coords[2 * (o13 + n12) + 1], f8.lineTo(r13, s11);
    f8.close(), n12 += e13;
  }
  const l11 = f8.result(false);
  if (!l11)
    return null;
  const i19 = [], u14 = [];
  for (const o12 of l11) {
    let t13 = 0;
    for (const e13 of o12)
      u14.push(e13.x), u14.push(e13.y), t13++;
    i19.push(t13);
  }
  return new t(i19, u14);
}
function x6(t12, e12) {
  u11.setPixelMargin(e12);
  const n12 = u11, r13 = -e12, l11 = c3 + e12;
  let i19 = [], f12 = false;
  if (!t12.nextPath())
    return null;
  let c15 = true;
  for (; c15; ) {
    t12.seekPathStart();
    const e13 = [];
    if (!t12.numPoints)
      return null;
    n12.reset(t3.LineString), t12.nextPoint();
    let s11 = t12.x, u14 = t12.y;
    if (f12)
      n12.moveTo(s11, u14);
    else {
      if (s11 < r13 || s11 > l11 || u14 < r13 || u14 > l11) {
        f12 = true;
        continue;
      }
      e13.push({ x: s11, y: u14 });
    }
    let h10 = false;
    for (; t12.nextPoint(); )
      if (s11 = t12.x, u14 = t12.y, f12)
        n12.lineTo(s11, u14);
      else {
        if (s11 < r13 || s11 > l11 || u14 < r13 || u14 > l11) {
          h10 = true;
          break;
        }
        e13.push({ x: s11, y: u14 });
      }
    if (h10)
      f12 = true;
    else {
      if (f12) {
        const t13 = n12.resultWithStarts();
        if (t13)
          for (const e14 of t13)
            i19.push(e14);
      } else
        i19.push({ line: e13, start: 0 });
      c15 = t12.nextPath(), f12 = false;
    }
  }
  return i19 = i19.filter((t13) => t13.line.length > 1), 0 === i19.length ? null : i19;
}
f8.setExtent(c3), u11.setExtent(c3);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseLineTemplate.js
var d7 = 8;
var x7 = 16;
var f9 = 65535;
var p10 = (r13) => class extends r13 {
  constructor(...e12) {
    super(...e12), this.tessellationProperties = {}, this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0 }, this.geometryType = E.LINE;
  }
  writeGeometry(e12, t12, i19, r14) {
    this._writeGeometry(e12, t12, i19, r14);
  }
  _initializeTessellator(e12) {
    const i19 = C2.load(this._materialKey), r14 = w4.load(this._materialKey), s11 = this._tessellationOptions, h10 = i19.vvSizeFieldStops || i19.vvSizeMinMaxValue || i19.vvSizeScaleStops || i19.vvSizeUnitValue, m8 = this.tessellationProperties._halfWidth < $ && !e12 && !h10;
    this.tessellationProperties.minMaxZoom = this._minMaxZoom, s11.wrapDistance = f9, s11.textured = this._isDashed || this._hasPattern, s11.offset = this.tessellationProperties.offset, s11.halfWidth = this.tessellationProperties._halfWidth;
    const d11 = m8 ? 0 : 1, x10 = O(r14) ? v5 : _4;
    this._lineTessellator = new c6(x10(this.tessellationProperties, d11, d11), u12(this.tessellationProperties), m8);
  }
  _write(e12, t12, i19, r14) {
    const s11 = "esriGeometryPoint" === t12.geometryType;
    e12.recordStart(t12.getDisplayId(), this._materialKey, this.geometryType, s11), this._writeGeometry(e12, t12, r14, s11), e12.recordEnd();
  }
  _writeGeometry(t12, i19, r14, s11) {
    const o12 = r14 || a7.fromFeatureSetReaderCIM(i19);
    if (!o12)
      return;
    const n12 = this._getLines(o12, s11);
    null != n12 && this._writeVertices(t12, i19, n12);
  }
  _getLines(e12, t12) {
    return x6(e12, t12 ? 256 : 16);
  }
  _writeVertices(e12, t12, i19) {
    const r14 = t12.getDisplayId(), s11 = e12.vertexCount(), o12 = this.tessellationProperties, h10 = this._tessellationOptions;
    o12.out = e12, o12.id = r14, o12.indexCount = 0, o12.vertexCount = 0, o12.offset = s11, h10.capType = this._capType, h10.joinType = this._joinType;
    const m8 = w4.load(this._materialKey);
    this.tessellationProperties.key = O(m8) ? m8 : C2.load(this._materialKey);
    for (const { line: n12, start: l11 } of i19)
      h10.initialDistance = l11 % f9, this._lineTessellator.tessellate(n12, h10);
  }
};
var _4 = (e12, t12, i19) => (o12, n12, l11, a15, h10, m8, f12, p15, _5, v6, u14) => {
  const W = w3(u14, Math.ceil(x7 * e12._halfWidth)), c15 = x(Math.round(x7 * f12), Math.round(x7 * p15), Math.round(x7 * _5), Math.round(x7 * v6)), y11 = x(x7 * h10, x7 * m8, 0, e12._bitset), M3 = e12.out;
  return M3.vertexBounds(o12, n12, t12, i19), M3.vertexWrite(w3(d7 * o12, d7 * n12)), M3.vertexWrite(e12.id), M3.vertexWrite(e12._fillColor), M3.vertexWrite(c15), M3.vertexWrite(W), M3.vertexWrite(e12._tl), M3.vertexWrite(e12._br), M3.vertexWrite(y11), M3.vertexWrite(w3(Math.ceil(x7 * e12._halfReferenceWidth), 0)), M3.vertexWrite(e12.minMaxZoom), M3.vertexEnd(), e12.offset + e12.vertexCount++;
};
var v5 = (e12, t12, i19) => (o12, n12, l11, a15, m8, f12, p15, _5, v6, u14, W) => {
  const c15 = w3(x7 * e12._halfWidth, x7 * e12._halfReferenceWidth), y11 = x(x7 * p15 + 128, x7 * _5 + 128, x7 * v6 + 128, x7 * u14 + 128), M3 = e12.out, C6 = e12._bitset << 24 | e12.id;
  M3.vertexBounds(o12, n12, t12, i19), M3.vertexWrite(w3(d7 * o12, d7 * n12)), M3.vertexWrite(C6), M3.vertexWrite(e12._fillColor);
  const P4 = b3(e12.key);
  return P4 || (M3.vertexWrite(0), M3.vertexWrite(0)), M3.vertexWrite(0), M3.vertexWrite(c15), M3.vertexWrite(y11), P4 || M3.vertexWrite(e12.minMaxZoom), M3.vertexEnd(), e12.offset + e12.vertexCount++;
};
var u12 = (e12) => (t12, i19, r13) => {
  const s11 = e12.out;
  s11.indexWrite(t12), s11.indexWrite(i19), s11.indexWrite(r13), e12.indexCount += 3;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLineTemplate.js
var K = class _K extends p10(r8) {
  constructor(e12, t12, i19, r13, s11, o12, p15, f12, d11, y11, S6, _5, j5, g7, w11, K3, P4, x10, b9, O2) {
    super();
    const T = C2.load(e12);
    t12 && (T.sdf = t12.sdf, T.pattern = true, T.textureBinding = t12.textureBinding), this._capType = r13, this._joinType = s11, this._miterLimitCosine = c10(o12), this.tessellationProperties._fillColor = p15, this.tessellationProperties._tl = f12, this.tessellationProperties._br = d11, this._hasPattern = y11, this._isDashed = S6, this._zOrder = P4, this._effects = x10 || null, this._minMaxZoom = w3(Math.round(b9 * me), Math.round(O2 * me)), this._materialKey = T.data;
    const M3 = (j5 ? pe : 0) | (g7 ? ke : 0) | (_5 ? je : 0) | (w11 ? ge : 0);
    this.tessellationProperties._bitset = M3, this.tessellationProperties._halfWidth = 0.5 * i19, this.tessellationProperties._halfReferenceWidth = 0.5 * K3, this.tessellationProperties.offset = 0, this._initializeTessellator(false);
  }
  static fromCIMLine(e12, r13, l11) {
    const n12 = e12.color, a15 = e12.scaleFactor || 1, m8 = !!e12.dashTemplate;
    let c15 = e12.cap;
    m8 && c15 === e4.ROUND && (c15 = e4.SQUARE);
    const p15 = e12.join, f12 = u2(e12.width) * a15, u14 = u2(e12.referenceWidth), d11 = u2(e12.miterLimit), y11 = n12 && t2(n12) || 0, [L5, _5] = v2(e12.scaleInfo, l11), j5 = false;
    if (!r13)
      return new _K(e12.materialKey, r13, f12, c15, p15, d11, y11, 0, 0, false, m8, e12.scaleDash ?? false, e12.colorLocked ?? false, j5, e12.sampleAlphaOnly, u14, e12.zOrder, e12.effects, L5, _5);
    const { rect: g7, width: w11, height: P4 } = r13, x10 = g7.x + ae, b9 = g7.y + ae, O2 = x10 + w11, T = b9 + P4, M3 = w3(x10, b9), W = w3(O2, T), z6 = false;
    return new _K(e12.materialKey, r13, f12, c15, p15, d11, y11, M3, W, true, m8, e12.scaleDash ?? false, e12.colorLocked ?? false, z6, e12.sampleAlphaOnly, u14, e12.zOrder, e12.effects, L5, _5);
  }
  static fromFillOutline(e12) {
    var _a;
    const t12 = w4.load(e12.materialKey);
    return O(t12) && e12.outline && "esriSLSSolid" === ((_a = e12.outline) == null ? void 0 : _a.style) ? _K.fromSimpleLine({ hash: "", materialKey: e12.materialKey, ...e12.outline }, null, true) : null;
  }
  static fromSimpleLine(e12, i19, s11 = false) {
    const { color: l11 } = e12, n12 = "esriSLSSolid" !== e12.style && "esriSLSNull" !== e12.style, a15 = k(e12.cap || "round"), m8 = G(e12.join || "round");
    let c15 = l11 && "esriSLSNull" !== e12.style && o5(l11) || 0;
    "esriSLSNull" === e12.style && (c15 = 0);
    const u14 = u2(e12.width), d11 = e12.miterLimit;
    if (!i19)
      return new _K(e12.materialKey, i19, u14, a15, m8, d11, c15, 0, 0, false, n12, true, false, s11, false, u14, 0, null, n7, o8);
    const { rect: y11, width: L5, height: S6 } = i19, g7 = y11.x + ae, w11 = y11.y + ae, P4 = g7 + L5, x10 = w11 + S6, b9 = w3(g7, w11), O2 = w3(P4, x10);
    return new _K(e12.materialKey, i19, u14, a15, m8, d11, c15, b9, O2, true, n12, true, false, s11, false, u14, 0, null, n7, o8);
  }
  static fromPictureLineSymbol(t12, i19, r13, s11) {
    return s.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate").error("PictureLineSymbol support does not exist!"), null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseFillTemplate.js
var y8 = 100;
var p11 = 1;
var x8 = (x10) => class extends x10 {
  constructor(...t12) {
    super(...t12), this.forceLibtess = false, this._bitset = 0, this._lineTemplate = null, this.geometryType = E.FILL;
  }
  _maybeAddLineTemplate(e12) {
    this._lineTemplate = K.fromFillOutline(e12);
  }
  _write(e12, t12, r13, i19) {
    const l11 = "esriGeometryPoint" === t12.geometryType, n12 = w4.load(this._materialKey);
    e12.recordStart(t12.getDisplayId(), this._materialKey, this.geometryType, l11), this._writeGeometry(e12, t12, n12, i19, l11), O(n12) && null != this._lineTemplate && this._lineTemplate.writeGeometry(e12, t12, i19, l11), e12.recordEnd();
  }
  _writeGeometry(e12, t12, r13, i19, s11) {
    const o12 = this._getGeometry(t12, i19, s11);
    if (null == o12)
      return;
    const l11 = [];
    if (!(o12.maxLength > y8) && !this.forceLibtess && a13(l11, o12))
      return void (l11.length && this._writeVertices(e12, t12, o12.coords, o12.lengths, r13, l11));
    const a15 = p9(o12);
    this._writeVertices(e12, t12, a15, [a15.length / 2], r13);
  }
  _writeVertex(e12, i19, s11, o12, n12, m8) {
    const a15 = w3(p11 * o12, p11 * n12);
    if (e12.vertexBounds(o12, n12, 0, 0), e12.vertexWrite(a15), e12.vertexWrite(i19), s11.symbologyType === S.DOT_DENSITY)
      e12.vertexWriteF32(1 / Math.abs(m8.readGeometryArea()));
    else {
      e12.vertexWrite(this.fillColor);
      const t12 = b3(s11);
      t12 || (e12.vertexWrite(this.tl), e12.vertexWrite(this.br)), e12.vertexWrite(this.aux21), e12.vertexWrite(this.aux22), e12.vertexWrite(this.aux3), t12 || e12.vertexWrite(this._minMaxZoom);
    }
  }
  _writeVertices(e12, t12, r13, s11, o12, l11) {
    const n12 = t12.getDisplayId(), m8 = this._bitset << 24 | n12, a15 = s11.reduce((e13, t13) => e13 + t13), h10 = R2(o12.geometryType, o12.symbologyType).geometry / 4, y11 = e12.vertexCount();
    e12.vertexEnsureSize(h10 * a15);
    let p15 = 0;
    if (l11)
      for (const i19 of l11) {
        const s12 = r13[2 * i19], l12 = r13[2 * i19 + 1];
        this._writeVertex(e12, m8, o12, s12, l12, t12), p15++;
      }
    else
      for (let i19 = 0; i19 < r13.length; i19 += 2) {
        const s12 = Math.round(r13[i19]), l12 = Math.round(r13[i19 + 1]);
        this._writeVertex(e12, m8, o12, s12, l12, t12), p15++;
      }
    e12.indexEnsureSize(p15);
    for (let i19 = 0; i19 < p15; i19++)
      e12.indexWrite(i19 + y11);
  }
  _getGeometry(e12, t12, r13) {
    const i19 = (t12 == null ? void 0 : t12.asOptimized()) || e12.readGeometryForDisplay();
    if (!i19)
      return null;
    return d6(i19, r13 ? 256 : 8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMeshTemplate.js
var i16 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");
var r10 = class extends r8 {
  constructor(e12) {
    super(), this._ongoingMaterialRequestMap = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._dynamicPropertyMap = /* @__PURE__ */ new Map(), this._cimLayer = e12;
  }
  async analyze(e12, s11, r13, n12, l11) {
    if (l11 && 0 === l11.length)
      return null;
    const o12 = l11 && l11.length > 0, m8 = s11.readLegacyFeature(), c15 = s11.getObjectId(), h10 = this._materialCache, u14 = this._cimLayer.materialHash;
    if (!u14)
      return i16.error("A Dynamic mesh template must have a material hash value or function!"), null;
    const p15 = "function" == typeof u14 ? u14(m8, r13, n12, c15) : u14, g7 = h10.get(p15);
    if (null != g7)
      return g7;
    const y11 = this._ongoingMaterialRequestMap.get(p15);
    if (y11)
      return y11;
    const M3 = this._cimLayer, d11 = V(M3.cim, this._cimLayer.materialOverrides);
    d11.mosaicHash = p15;
    const { type: f12, url: _5 } = M3, b9 = { cim: d11, type: f12, mosaicHash: p15, url: _5, size: null, dashTemplate: null, text: null, fontName: null, objectId: c15, animatedSymbolProperties: null };
    switch (f12) {
      case "marker":
        b9.size = t5(M3.size, m8, r13, n12), b9.animatedSymbolProperties = t5(M3.animatedSymbolProperties, m8, r13, n12);
        break;
      case "line":
        b9.dashTemplate = M3.dashTemplate;
        break;
      case "text":
        b9.text = t5(M3.text, m8, r13, n12), b9.fontName = t5(M3.fontName, m8, r13, n12);
    }
    const L5 = e12.getMosaicItem(b9, l11).then((e13) => (o12 || (this._ongoingMaterialRequestMap.delete(p15), h10.set(p15, e13)), e13)).catch((e13) => (this._ongoingMaterialRequestMap.delete(p15), i16.error(".analyze()", e13.message), null));
    return o12 || this._ongoingMaterialRequestMap.set(p15, L5), L5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Result.js
function e11(e12, n12) {
  if (e12 && "name" in e12) {
    const o12 = e12;
    return n12 && n12.error(new s2(o12.name, o12.message, o12.details)), false;
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicFillTemplate.js
var j3 = class _j extends x8(r10) {
  constructor(l11, h10, n12) {
    var _a;
    if (super(l11), this._minMaxZoom = w3(Math.round(h10 * me), Math.round(n12 * me)), e7(l11.color)) {
      const t12 = (t13, e12, i19) => {
        const o12 = l11.color(t13, e12, i19);
        return o12 && t2(o12) || 0;
      };
      this._dynamicPropertyMap.set("fillColor", t12);
    } else {
      const t12 = l11.color;
      this.fillColor = t12 && t2(t12) || 0;
    }
    const c15 = "CIMMarkerPlacementInsidePolygon" === ((_a = l11.cim.placement) == null ? void 0 : _a.type) && l11.cim.placement.shiftOddRows ? 2 : 1, f12 = l11.height;
    if (e7(f12)) {
      const t12 = (t13, e12, s11) => f12(t13, e12, s11) * c15;
      this._dynamicPropertyMap.set("_height", t12);
    } else
      this._height = (f12 || 0) * c15;
    const y11 = l11.offsetX;
    if (e7(y11)) {
      const e12 = (e13, s11, i19) => u2(y11(e13, s11, i19));
      this._dynamicPropertyMap.set("_offsetX", e12);
    } else
      this._offsetX = u2(y11 || 0);
    const d11 = l11.offsetY;
    if (e7(d11)) {
      const e12 = (e13, s11, i19) => u2(-d11(e13, s11, i19));
      this._dynamicPropertyMap.set("_offsetY", e12);
    } else
      this._offsetY = u2(-d11 || 0);
    const u14 = l11.scaleX;
    e7(u14) ? this._dynamicPropertyMap.set("_scaleX", u14) : this._scaleX = u14 || 1;
    const M3 = l11.angle;
    if (e7(M3)) {
      const t12 = (t13, e12, s11) => c5(M3(t13, e12, s11));
      this._dynamicPropertyMap.set("_angle", t12);
    } else
      this._angle = c5(M3) || 0;
    if (null != l11.effects) {
      const t12 = l11.effects;
      e7(t12) ? this._dynamicPropertyMap.set("_effects", t12) : this._effects = t12;
    }
    this._cimFillLayer = l11, this._bitset = (l11.colorLocked ? pe : 0) | (l11.applyRandomOffset ? ue : 0) | (l11.sampleAlphaOnly ? ge : 0) | (l11.hasUnresolvedReplacementColor ? ve : 0), this._fillMaterialKey = l11.materialKey;
  }
  static fromCIMFill(t12, e12) {
    const [s11, i19] = v2(t12.scaleInfo, e12);
    return new _j(t12, s11, i19);
  }
  bindFeature(e12, s11, i19) {
    const o12 = e12.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t12, e13) => {
      this[e13] = t12(o12, s11, i19);
    });
    const r13 = w4.load(this._fillMaterialKey), a15 = this._materialCache, m8 = (0, this._cimFillLayer.materialHash)(o12, s11, i19), p15 = a15.get(m8);
    let u14 = null;
    if (p15 && e11(p15.spriteMosaicItem) && (u14 = p15.spriteMosaicItem), u14) {
      const { rect: e13, width: s12, height: i20 } = u14, o13 = e13.x + ae, a16 = e13.y + ae, m9 = o13 + s12, p16 = a16 + i20;
      let d11 = u2(this._height);
      d11 <= 0 && (d11 = p16 - a16), d11 < i3 && (d11 *= h2, this._bitset |= ye), d11 = Math.round(d11);
      let M3 = u2(this._height / i20 * s12);
      M3 <= 0 && (M3 = m9 - o13), M3 < i3 && (M3 *= h2, this._bitset |= be), M3 = Math.round(M3);
      const g7 = this._scaleX, x10 = 1;
      this.tl = w3(o13, a16), this.br = w3(m9, p16), this.aux21 = w3(M3, d11), this.aux22 = w3(this._offsetX, this._offsetY), this.aux3 = x(g7 * h2, x10 * h2, this._angle, 0), r13.sdf = u14.sdf, r13.pattern = true, r13.textureBinding = u14.textureBinding;
    } else
      this.tl = 0, this.br = 0, this.aux21 = 0, this.aux22 = 0, this.aux3 = 0, r13.sdf = false, r13.pattern = false, r13.textureBinding = 0;
    this._materialKey = r13.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicLineTemplate.js
var d8 = class _d extends p10(r10) {
  constructor(a15, n12, m8) {
    super(a15), this._minMaxZoom = w3(Math.round(n12 * me), Math.round(m8 * me)), this._cimLineLayer = a15;
    let p15 = 0;
    e7(a15.width) || (p15 = 0.5 * u2(a15.width));
    const _5 = (i19, s11, r13) => e7(a15.width) ? 0.5 * u2(a15.width(i19, s11, r13)) : p15;
    this._dynamicPropertyMap.set("_halfWidth", _5), e7(a15.cap) ? this._dynamicPropertyMap.set("_capType", a15.cap) : this._capType = a15.cap, e7(a15.join) ? this._dynamicPropertyMap.set("_joinType", a15.join) : this._joinType = a15.join;
    const f12 = a15.color;
    if (e7(f12)) {
      const t12 = (t13, e12, s11) => t2(f12(t13, e12, s11));
      this._dynamicPropertyMap.set("_fillColor", t12);
    } else
      this._fillColor = f12 && t2(f12) || 0;
    const d11 = a15.miterLimit;
    if (e7(d11)) {
      const t12 = (t13, e12, i19) => c10(d11(t13, e12, i19));
      this._dynamicPropertyMap.set("_miterLimitCosine", t12);
    } else
      this._miterLimitCosine = c10(d11);
    if (null != a15.effects) {
      const t12 = a15.effects;
      e7(t12) ? this._dynamicPropertyMap.set("_effects", t12) : this._effects = t12;
    }
    this._scaleFactor = a15.scaleFactor || 1, this._isDashed = null != a15.dashTemplate;
    const y11 = a15.colorLocked ? pe : 0, P4 = a15.scaleDash ? je : 0, u14 = a15.sampleAlphaOnly ? ge : 0;
    this.tessellationProperties._bitset = y11 | P4 | u14, this._materialKey = a15.materialKey, this._initializeTessellator(true);
  }
  static fromCIMLine(t12, e12) {
    const [i19, s11] = v2(t12.scaleInfo, e12);
    return new _d(t12, i19, s11);
  }
  bindFeature(t12, e12, i19) {
    const s11 = t12.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t13, r14) => {
      this[r14] = t13(s11, e12, i19);
    }), this._halfWidth *= this._scaleFactor;
    const r13 = this._materialCache, o12 = (0, this._cimLineLayer.materialHash)(s11, e12, i19), l11 = r13.get(o12);
    let c15 = null;
    if (l11 && e11(l11.spriteMosaicItem) && (c15 = l11.spriteMosaicItem), c15) {
      this._hasPattern = true;
      const { rect: t13, width: e13, height: i20 } = c15, s12 = t13.x + ae, r14 = t13.y + ae, o13 = s12 + e13, l12 = r14 + i20;
      this.tessellationProperties._tl = w3(s12, r14), this.tessellationProperties._br = w3(o13, l12);
    } else
      this._hasPattern = false, this.tessellationProperties._tl = 0, this.tessellationProperties._br = 0;
    this.tessellationProperties._fillColor = this._fillColor, this.tessellationProperties._halfWidth = this._halfWidth, this.tessellationProperties.offset = 0, this.tessellationProperties._halfReferenceWidth = this.tessellationProperties._halfWidth;
    const m8 = C2.load(this._materialKey);
    c15 && (m8.sdf = c15.sdf, m8.pattern = true, m8.textureBinding = c15.textureBinding), this._materialKey = m8.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMarkerTemplate.js
var k4 = n5();
var P3 = n3();
var L3 = class _L extends y6(r10) {
  constructor(t12, e12, i19) {
    super(t12), this._cimMarkerLayer = t12, this._minMaxZoom = w3(Math.round(e12 * me), Math.round(i19 * me));
    const r13 = t12.color;
    if (e7(r13)) {
      const t13 = (t14, e13, s11) => t2(r13(t14, e13, s11));
      this._dynamicPropertyMap.set("_fillColor", t13);
    } else
      this._fillColor = t2(r13);
    const y11 = t12.outlineColor;
    if (e7(y11)) {
      const t13 = (t14, e13, s11) => t2(y11(t14, e13, s11));
      this._dynamicPropertyMap.set("_outlineColor", t13);
    } else
      this._outlineColor = t2(y11);
    const p15 = t12.size;
    if (e7(p15)) {
      const t13 = (t14, e13, i20) => u2(p15(t14, e13, i20));
      this._dynamicPropertyMap.set("_size", t13);
    } else
      this._size = u2(p15) || 0;
    const M3 = t12.scaleX;
    e7(M3) ? this._dynamicPropertyMap.set("_scaleX", M3) : this._scaleX = M3;
    const d11 = t12.offsetX;
    if (e7(d11)) {
      const t13 = (t14, e13, i20) => u2(d11(t14, e13, i20));
      this._dynamicPropertyMap.set("xOffset", t13);
    } else
      this.xOffset = u2(d11) || 0;
    const u14 = t12.offsetY;
    if (e7(u14)) {
      const t13 = (t14, e13, i20) => u2(u14(t14, e13, i20));
      this._dynamicPropertyMap.set("yOffset", t13);
    } else
      this.yOffset = u2(u14) || 0;
    const g7 = t12.outlineWidth;
    if (e7(g7)) {
      const t13 = (t14, e13, i20) => u2(g7(t14, e13, i20));
      this._dynamicPropertyMap.set("_outlineWidth", t13);
    } else
      this._outlineWidth = u2(g7) || 0;
    const k6 = t12.rotation;
    if (e7(k6) ? this._dynamicPropertyMap.set("_angle", k6) : this._angle = k6 || 0, null != t12.effects) {
      const e13 = t12.effects;
      e7(e13) ? this._dynamicPropertyMap.set("_effects", e13) : this._effects = e13;
    }
    if (null != t12.markerPlacement) {
      const e13 = t12.markerPlacement;
      e7(e13) ? this._dynamicPropertyMap.set("_markerPlacement", e13) : this._markerPlacement = e13;
    }
    this._scaleFactor = t12.scaleFactor ?? 1, this._bitSet = (t12.alignment === i5.MAP ? ne : le) | (t12.colorLocked ? pe : 0) | (t12.scaleSymbolsProportionally ? xe : 0), this._materialKey = t12.materialKey;
  }
  static fromCIMMarker(t12, e12) {
    const [s11, i19] = v2(t12.scaleInfo, e12);
    return new _L(t12, s11, i19);
  }
  bindFeature(i19, r13, o12) {
    const a15 = i19.readLegacyFeature(), n12 = i19.getObjectId();
    this._dynamicPropertyMap.forEach((t12, e12) => {
      this[e12] = t12(a15, r13, o12);
    });
    const c15 = this._cimMarkerLayer.materialHash, h10 = "function" == typeof c15 ? c15(a15, r13, o12, n12) : c15, m8 = this._materialCache.get(h10);
    if (!m8 || !e11(m8.spriteMosaicItem) || !m8.spriteMosaicItem)
      return void s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate").error(new s2("mapview-cim", "Encountered an error when binding feature"));
    const l11 = m8.spriteMosaicItem, f12 = this._cimMarkerLayer.sizeRatio, M3 = l11.width / l11.height * this._scaleX, d11 = N.load(this._materialKey);
    d11.sdf = l11.sdf, d11.pattern = true, d11.textureBinding = l11.textureBinding, this._materialKey = d11.data;
    const u14 = this._cimMarkerLayer.rotateClockwise ? this._angle : -this._angle, L5 = this._size, j5 = L5 * M3, b9 = this.xOffset, z6 = this.yOffset;
    this.xOffset *= this._scaleFactor, this.yOffset *= this._scaleFactor;
    const x10 = this._cimMarkerLayer.scaleSymbolsProportionally && this._cimMarkerLayer.frameHeight ? this._size / u2(this._cimMarkerLayer.frameHeight) : 1, O2 = this._outlineWidth * x10, w11 = u2(this._cimMarkerLayer.referenceSize);
    let C6 = 0, W = 0;
    const F2 = this._cimMarkerLayer.anchorPoint;
    F2 && (this._cimMarkerLayer.isAbsoluteAnchorPoint ? this._size && (C6 = u2(F2.x) / (this._size * M3), W = u2(F2.y) / this._size) : (C6 = F2.x, W = F2.y)), this._anchorX = C6, this._anchorY = W, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * j5), 255)), Math.round(Math.min(Math.sqrt(128 * L5), 255)), Math.round(Math.min(Math.sqrt(128 * O2), 255)), Math.round(Math.min(Math.sqrt(128 * w11), 255))), this.angle = u14;
    const S6 = Math.round(64 * f12);
    this._bitestAndDistRatio = w3(this._bitSet, S6), this._computeSize(j5, L5, f12, O2, this._scaleFactor, l11, d11.hasSizeVV(), true), this._applyTransformation(P3, k4), this.xOffset = b9, this.yOffset = z6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/textUtils.js
function n10(n12) {
  if (null == n12)
    return [];
  const r13 = new Array(n12.length);
  for (let t12 = 0; t12 < n12.length; t12++)
    r13[t12] = n12.charCodeAt(t12);
  return r13;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicTextTemplate.js
var y9 = 5;
function p12(t12, e12, i19, s11) {
  return "string" == typeof t12.text ? t12.text : "function" == typeof t12.text ? t12.text(e12, i19, s11) ?? "" : "";
}
var d9 = class _d extends w6(r10) {
  constructor(s11, o12, n12) {
    super(s11), this._horizontalAlignment = "center", this._verticalAlignment = "middle", this._textToGlyphs = /* @__PURE__ */ new Map(), this._minMaxZoom = w3(Math.round(o12 * me), Math.round(n12 * me));
    const c15 = s11.scaleFactor || 1;
    this._cimTextLayer = s11;
    const m8 = s11.color;
    if (e7(m8)) {
      const t12 = (t13, e12, i19) => t2(m8(t13, e12, i19));
      this._dynamicPropertyMap.set("_color", t12);
    } else
      this._color = t2(m8);
    const _5 = s11.outlineColor;
    if (e7(_5)) {
      const t12 = (t13, e12, i19) => t2(_5(t13, e12, i19));
      this._dynamicPropertyMap.set("_haloColor", t12);
    } else
      this._haloColor = t2(_5);
    let f12;
    e7(s11.size) || (f12 = Math.min(Math.round(u2(s11.size * s11.sizeRatio)), 127));
    const p15 = (e12, o13, r13) => e7(s11.size) ? Math.min(Math.round(u2(s11.size(e12, o13, r13) * s11.sizeRatio)), 127) : f12;
    if (this._dynamicPropertyMap.set("_size", p15), e7(s11.outlineSize)) {
      const e12 = (e13, i19, o13) => Math.min(Math.floor(y9 * u2(s11.outlineSize(e13, i19, o13) * s11.sizeRatio)), 127);
      this._dynamicPropertyMap.set("_haloSize", e12);
    } else
      this._haloSize = Math.min(Math.floor(y9 * u2(s11.outlineSize * s11.sizeRatio)), 127);
    let d11;
    e7(s11.offsetX) || (d11 = Math.round(u2(s11.offsetX * s11.sizeRatio)));
    const M3 = (e12, o13, r13) => e7(s11.offsetX) ? Math.round(u2(s11.offsetX(e12, o13, r13) * s11.sizeRatio)) : d11;
    let u14;
    this._dynamicPropertyMap.set("_xOffset", M3), e7(s11.offsetY) || (u14 = Math.round(u2(s11.offsetY * s11.sizeRatio)));
    const g7 = (e12, o13, r13) => e7(s11.offsetY) ? Math.round(u2(s11.offsetY(e12, o13, r13) * s11.sizeRatio)) : u14;
    if (this._dynamicPropertyMap.set("_yOffset", g7), e7(s11.angle) ? this._dynamicPropertyMap.set("_angle", s11.angle) : this._angle = s11.angle, e7(s11.horizontalAlignment) ? this._dynamicPropertyMap.set("_horizontalAlignment", s11.horizontalAlignment) : this._horizontalAlignment = s11.horizontalAlignment, e7(s11.verticalAlignment) ? this._dynamicPropertyMap.set("_verticalAlignment", s11.verticalAlignment) : this._verticalAlignment = s11.verticalAlignment, null != s11.effects) {
      const t12 = s11.effects;
      e7(t12) ? this._dynamicPropertyMap.set("_effects", t12) : this._effects = t12;
    }
    if (null != s11.markerPlacement) {
      const t12 = s11.markerPlacement;
      e7(t12) ? this._dynamicPropertyMap.set("_markerPlacement", t12) : this._textPlacement = t12;
    }
    e7(s11.text) ? this._dynamicPropertyMap.set("_text", s11.text) : this._text = s11.text, this._backgroundColor = s11.backgroundColor && t2(s11.backgroundColor), this._borderLineColor = s11.borderLineColor && t2(s11.borderLineColor), this._borderLineSize = s11.borderLineWidth, this._scaleFactor = c15;
    const z6 = Math.min(Math.round(u2(s11.referenceSize * s11.sizeRatio)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * z6)), this._materialKey = s11.materialKey;
    const x10 = P.load(this._materialKey);
    x10.sdf = true, this._bitset = (s11.alignment === i5.MAP ? 1 : 0) | (s11.colorLocked ? 1 : 0) << 1, this._materialKey = x10.data, this._decoration = "none", this._lineHeight = 1, this._lineWidth = 512, this._isCIM = true;
  }
  static fromCIMText(t12, e12) {
    const [i19, s11] = v2(t12.scaleInfo, e12);
    return new _d(t12, i19, s11);
  }
  async analyze(t12, e12, i19, s11) {
    const o12 = e12.readLegacyFeature(), r13 = p12(this._cimTextLayer, o12, i19, s11), n12 = await super.analyze(t12, e12, i19, s11, n10(r13));
    return n12 && n12.glyphMosaicItems && this._textToGlyphs.set(r13, n12.glyphMosaicItems), n12;
  }
  bindFeature(t12, e12, i19) {
    const r13 = t12.readLegacyFeature();
    if (this._dynamicPropertyMap.forEach((t13, s11) => {
      this[s11] = t13(r13, e12, i19);
    }), !this._text || 0 === this._text.length)
      return void (this._shapingInfo = null);
    this._size *= this._scaleFactor, this._scale = this._size / b2, this._xOffset *= this._scaleFactor, this._yOffset *= this._scaleFactor, this._xAlignD = r4(this._horizontalAlignment ?? "center"), this._yAlignD = n4(this._verticalAlignment ?? "baseline");
    const a15 = this._textToGlyphs.get(this._text) ?? [];
    this.bindTextInfo(a15, false);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLFillTemplate.js
var K2 = class _K extends x8(r8) {
  constructor(t12, e12, l11, o12, r13, i19, s11, a15, n12, m8, c15, f12, d11, u14, M3, j5) {
    super(), this._effects = u14 || void 0;
    const w11 = w4.load(t12);
    e12 && (w11.sdf = e12.sdf, w11.pattern = true, w11.textureBinding = e12.textureBinding), this.fillColor = l11, this.tl = o12, this.br = r13, this.aux21 = w3(i19, s11), this.aux22 = w3(a15, n12), this.aux3 = x(m8, c15, f12, 0), this._bitset = d11, this._minMaxZoom = w3(Math.round(M3 * me), Math.round(j5 * me)), this._materialKey = w11.data;
  }
  static fromCIMFill(e12, h10, d11) {
    const y11 = e12.color, x10 = y11 && t2(y11) || 0, j5 = e12.materialKey, [w11, g7] = v2(e12.scaleInfo, d11);
    let F2 = (e12.colorLocked ? pe : 0) | (e12.applyRandomOffset ? ue : 0) | (e12.sampleAlphaOnly ? ge : 0) | (e12.hasUnresolvedReplacementColor ? ve : 0);
    if (!h10)
      return new _K(j5, null, x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, F2, e12.effects, w11, g7);
    const { rect: _5, width: b9, height: L5 } = h10, C6 = e12.scaleX || 1, T = _5.x + ae, A3 = _5.y + ae, B3 = T + b9, G4 = A3 + L5, I2 = u2(e12.height);
    let R3 = C6 * I2;
    "CIMHatchFill" === e12.cim.type && (R3 *= b9 / L5);
    let S6 = I2;
    S6 <= 0 && (S6 = G4 - A3), S6 < i3 && (S6 *= h2, F2 |= ye), S6 = Math.round(S6);
    let U2 = R3;
    U2 <= 0 && (U2 = B3 - T), U2 < i3 && (U2 *= h2, F2 |= be), U2 = Math.round(U2);
    const v6 = u2(e12.offsetX || 0), O2 = u2(-e12.offsetY || 0), W = w3(T, A3), X = w3(B3, G4);
    return new _K(j5, h10, x10, W, X, U2, S6, v6, O2, h2, h2, c5(e12.angle), F2, e12.effects, w11, g7);
  }
  static fromSimpleFill(t12, l11, r13 = false) {
    const { color: i19 } = t12, s11 = i19 && "esriSFSNull" !== t12.style && o5(i19) || 0;
    let h10 = r13 ? pe : 0;
    const d11 = t12.materialKey;
    let u14;
    if (l11) {
      const { rect: t13, width: e12, height: o12, pixelRatio: r14 } = l11, i20 = t13.x + ae, y11 = t13.y + ae, x10 = i20 + e12, M3 = y11 + o12, g7 = w3(i20, y11), F2 = w3(x10, M3);
      let _5 = e12 / r14;
      _5 < i3 && (_5 *= h2, h10 |= be), _5 = Math.round(_5);
      let b9 = o12 / r14;
      b9 < i3 && (b9 *= h2, h10 |= ye), b9 = Math.round(b9), u14 = new _K(d11, l11, s11, g7, F2, _5, b9, 0, 0, h2, h2, 0, h10, null, n7, o8);
    } else
      u14 = new _K(d11, null, s11, 0, 0, 0, 0, 0, 0, 0, 0, 0, h10, null, n7, o8);
    return u14._maybeAddLineTemplate(t12), u14;
  }
  static fromPictureFill(e12, l11, r13 = false) {
    const i19 = a5, { rect: s11, width: h10, height: u14 } = l11, y11 = s11.x + ae, x10 = s11.y + ae, M3 = y11 + h10, g7 = x10 + u14, F2 = w3(y11, x10), _5 = w3(M3, g7);
    let b9 = r13 ? pe : 0, L5 = u2(e12.width);
    L5 < i3 && (L5 *= h2, b9 |= be), L5 = Math.round(L5);
    let C6 = u2(e12.height);
    C6 < i3 && (C6 *= h2, b9 |= ye), C6 = Math.round(C6);
    const T = u2(e12.xoffset), A3 = u2(-e12.yoffset), B3 = e12.materialKey, G4 = new _K(B3, l11, i19, F2, _5, L5, C6, T, A3, h2 * e12.xscale, h2 * e12.yscale, 0, b9, null, n7, o8);
    return G4._maybeAddLineTemplate(e12), G4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Lock.js
var r11 = class {
  constructor() {
    this._resolver = null;
  }
  isHeld() {
    return !!this._resolver;
  }
  async acquire() {
    this._resolver ? (await this._resolver.promise, await this.acquire()) : this._resolver = C();
  }
  release() {
    const e12 = this._resolver;
    this._resolver = null, e12 == null ? void 0 : e12.resolve();
  }
};
async function s9(e12, r13, s11) {
  try {
    await e12.acquire(), await r13(s11), e12.release();
  } catch (t12) {
    throw e12.release(), t12;
  }
}

// node_modules/@arcgis/core/symbols/cim/ExpandedCIM.js
var s10 = { marker: E.MARKER, fill: E.FILL, line: E.LINE, text: E.TEXT };
var l9 = class {
  constructor(e12, l11, n12, r13) {
    const c15 = { minScale: l11 == null ? void 0 : l11.minScale, maxScale: l11 == null ? void 0 : l11.maxScale }, m8 = i17(c15);
    this.layers = e12, this.data = l11, this.hash = this._createHash() + m8, this.rendererKey = n12;
    const o12 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: n12 };
    for (const t12 of e12) {
      const e13 = s10[t12.type];
      o12.isOutline = "line" === t12.type && t12.isOutline, t12.materialKey = f4(e13, o12), t12.maxVVSize = r13, t12.scaleInfo = c15, t12.templateHash += m8;
    }
  }
  get type() {
    return "expanded-cim";
  }
  _createHash() {
    let e12 = "";
    for (const t12 of this.layers)
      e12 += t12.templateHash;
    return e12;
  }
};
function i17(e12) {
  return e12.minScale || e12.maxScale ? e12.minScale + "-" + e12.maxScale : "";
}

// node_modules/@arcgis/core/views/2d/layers/support/webStyleUtils.js
async function f10(t12, r13, s11) {
  if (!t12.name)
    throw new s2("style-symbol-reference-name-missing", "Missing name in style symbol reference");
  if (t12.styleName && "Esri2DPointSymbolsStyle" === t12.styleName)
    return p13(t12, s11);
  try {
    return b6(await c2(t12, r13, s11), t12.name, r13, s11);
  } catch (l11) {
    return f(l11), null;
  }
}
async function p13(t12, r13) {
  const o12 = w.replaceAll(/\{SymbolName\}/gi, t12.name);
  try {
    const t13 = await b(o12, r13);
    return p(t13.data);
  } catch (s11) {
    return f(s11), null;
  }
}
async function b6(m8, a15, f12, p15) {
  const b9 = { portal: f12 && null != f12.portal ? f12.portal : j.getDefault(), url: L(m8.baseUrl), origin: "portal-item" }, j5 = h(a15, m8.data);
  if (!j5) {
    throw new s2("symbolstyleutils:symbol-name-not-found", `The symbol name '${a15}' could not be found`, { symbolName: a15 });
  }
  let w11 = i2(d2(j5, "cimRef"), b9);
  c() && (w11 = a3(w11));
  try {
    const t12 = await b(w11, p15);
    return p(t12.data);
  } catch (U2) {
    return f(U2), null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/cimSymbolUtils.js
var i18 = async (a15, i19, r13) => {
  const n12 = new G2(r13, i19);
  return new l9(await n12.analyzeSymbolReference(a15.data, false), a15.data, a15.rendererKey, a15.maxVVSize);
};
async function r12(e12, t12, r13, n12) {
  if (!e12)
    return null;
  if ("cim" === e12.type)
    return i18(e12, t12, r13);
  if ("web-style" === e12.type) {
    const l11 = { type: "cim", data: await f10(e12, null, n12) ?? void 0, rendererKey: e12.rendererKey, maxVVSize: e12.maxVVSize };
    return i18(l11, t12, r13);
  }
  return e12;
}
function n11(e12) {
  if (!e12)
    return null;
  const { avoidSDFRasterization: t12, type: a15, cim: i19, url: r13, materialHash: n12, maxVVSize: l11 } = e12, m8 = { cim: i19, type: a15, mosaicHash: n12, url: r13, size: null, dashTemplate: null, path: null, text: null, fontName: null, animatedSymbolProperties: null, avoidSDFRasterization: t12 };
  switch (a15) {
    case "marker":
      l11 && "size" in i19 && (i19.size = Math.max(l11, i19.size)), m8.size = e12.size, m8.path = e12.path, m8.animatedSymbolProperties = e12.animatedSymbolProperties;
      break;
    case "line":
      m8.dashTemplate = e12.dashTemplate;
      break;
    case "text":
      m8.text = e12.text, m8.fontName = e12.fontName;
  }
  return m8;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTemplateStore.js
var S4 = s.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore");
var w9 = { sortKey: null, templates: new Array() };
var k5 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: 0 };
var C5 = { ...r, hash: JSON.stringify(r), materialKey: f4(E.MARKER, k5) };
var L4 = { ...s5, hash: JSON.stringify(s5), materialKey: f4(E.LINE, k5) };
var b7 = { ...y2, hash: JSON.stringify(y2), materialKey: f4(E.FILL, k5) };
function E4(e12, t12) {
  const r13 = e12.length;
  return e12.push(null), t12.then((t13) => e12[r13] = t13), e12;
}
function G3(e12) {
  return null != e12 && !!(1 & e12);
}
function j4(e12) {
  return "worker:port-closed" === e12.name;
}
var x9 = class {
  constructor(e12, t12) {
    this._idCounter = 1, this._templateIdCounter = 1, this._idToTemplateGroup = /* @__PURE__ */ new Map(), this._symbolToTemplate = /* @__PURE__ */ new Map(), this._fetchQueue = [], this._idToResolver = /* @__PURE__ */ new Map(), this._cimTemplateCache = /* @__PURE__ */ new Map(), this._cimAnalyses = [], this._lock = new r11(), this._fetchResource = e12, this._tileInfo = t12;
  }
  get _markerError() {
    return this._errorTemplates.marker[0];
  }
  get _fillError() {
    return this._errorTemplates.fill[0];
  }
  get _lineError() {
    return this._errorTemplates.line[0];
  }
  get _textError() {
    return this._errorTemplates.line[0];
  }
  createTemplateGroup(e12, t12, r13 = null) {
    this._initErrorTemplates();
    const s11 = e12.hash, i19 = this._symbolToTemplate.get(s11);
    if (null != i19)
      return i19;
    const a15 = new Array(), o12 = { sortKey: r13, templates: a15 };
    t12 && this._createMeshTemplates(a15, t12, true), this._createMeshTemplates(a15, e12, false);
    const l11 = this._createGroupId("expanded-cim" === e12.type && F(e12));
    return this._idToTemplateGroup.set(l11, o12), this._symbolToTemplate.set(s11, l11), l11;
  }
  getTemplateGroup(e12) {
    return this._idToTemplateGroup.get(e12) ?? w9;
  }
  getDynamicTemplateGroup(e12) {
    return this._idToTemplateGroup.has(e12) ? (G3(e12) || S4.error("mapview-template-store", `Id ${e12} does not refer to a dynamic template`), this._idToTemplateGroup.get(e12)) : w9;
  }
  getMosaicItem(e12, t12) {
    const r13 = this._createTemplateId(), s11 = new Promise((e13) => this._idToResolver.set(r13, e13));
    return this._fetchQueue.push({ symbol: e12, id: r13, glyphIds: t12 }), s11;
  }
  finalize(e12) {
    return this._fetchQueue.length || this._lock.isHeld() ? s9(this._lock, this._fetchAllQueuedResources.bind(this), e12) : Promise.resolve();
  }
  _initErrorTemplates() {
    this._errorTemplates || (this._errorTemplates = { fill: this._createMeshTemplates([], b7, false), marker: this._createMeshTemplates([], C5, false), line: this._createMeshTemplates([], L4, false) });
  }
  _fetchAllQueuedResources(t12) {
    if (!this._fetchQueue.length)
      return Promise.resolve();
    const s11 = this._fetchQueue, i19 = this._cimAnalyses;
    return this._fetchQueue = [], this._cimAnalyses = [], Promise.all(i19).then(() => this._fetchResource(s11, t12).then((e12) => {
      for (const { id: t13, mosaicItem: r13 } of e12) {
        this._idToResolver.get(t13)(r13), this._idToResolver.delete(t13);
      }
    })).catch((t13) => {
      d(t13) ? this._fetchQueue = this._fetchQueue.concat(s11) : j4(t13) || S4.error(new s2("mapview-template-store", "Unable to fetch requested texture resources", t13));
    });
  }
  _createGroupId(e12) {
    return this._idCounter++ << 1 | (e12 ? 1 : 0);
  }
  _createTemplateId() {
    return this._templateIdCounter++;
  }
  async _createSMS(e12) {
    const { spriteMosaicItem: t12 } = await this.getMosaicItem(e12);
    return e11(t12, S4) ? z4.fromSimpleMarker(e12, t12) : this._markerError;
  }
  async _createPMS(e12) {
    const { spriteMosaicItem: t12 } = await this.getMosaicItem(e12);
    return e11(t12, S4) ? z4.fromPictureMarker(e12, t12) : this._markerError;
  }
  async _createSFS(e12, t12) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e12);
    return e11(r13, S4) ? K2.fromSimpleFill(e12, r13, t12) : this._fillError;
  }
  async _createPFS(e12, t12) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e12);
    return e11(r13, S4) ? K2.fromPictureFill(e12, r13, t12) : this._fillError;
  }
  async _createSLS(e12, t12) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e12);
    return e11(r13, S4) ? K.fromSimpleLine(e12, r13) : this._lineError;
  }
  async _createLMS(e12) {
    const { spriteMosaicItem: t12 } = await this.getMosaicItem(e12);
    return e11(t12, S4) ? z4.fromLineSymbolMarker(e12, t12) : this._markerError;
  }
  async _createTS(e12) {
    const { glyphMosaicItems: t12 } = await this.getMosaicItem(e12);
    return g4.fromText(e12, t12 ?? []);
  }
  async _createCIMText(e12) {
    const { glyphMosaicItems: t12 } = await this.getMosaicItem(n11(e12), n10(e12.text));
    return e11(t12, S4) ? g4.fromCIMText(e12, t12, this._tileInfo) : this._textError;
  }
  async _createCIMFill(e12) {
    const { spriteMosaicItem: t12 } = await this.getMosaicItem(n11(e12));
    return e11(t12, S4) ? K2.fromCIMFill(e12, t12, this._tileInfo) : this._fillError;
  }
  async _createCIMLine(e12) {
    const { spriteMosaicItem: t12 } = await this.getMosaicItem(n11(e12));
    return e11(t12, S4) ? K.fromCIMLine(e12, t12, this._tileInfo) : this._lineError;
  }
  async _createCIMMarker(e12) {
    const { spriteMosaicItem: t12 } = await this.getMosaicItem(n11(e12));
    return e11(t12, S4) ? z4.fromCIMMarker(e12, t12, this._tileInfo) : this._markerError;
  }
  async _createCIM(e12) {
    const t12 = e12.templateHash;
    let r13 = this._cimTemplateCache.get(t12);
    if (null != r13)
      return r13;
    switch (e12.type) {
      case "marker":
        r13 = await this._createCIMMarker(e12);
        break;
      case "line":
        r13 = await this._createCIMLine(e12);
        break;
      case "fill":
        r13 = await this._createCIMFill(e12);
        break;
      case "text":
        r13 = await this._createCIMText(e12);
    }
    return this._cimTemplateCache.set(t12, r13), r13;
  }
  async _createDynamicCIM(e12) {
    const t12 = e12.templateHash;
    let r13 = this._cimTemplateCache.get(t12);
    if (null != r13)
      return r13;
    switch (e12.type) {
      case "marker":
        r13 = L3.fromCIMMarker(e12, this._tileInfo);
        break;
      case "line":
        r13 = d8.fromCIMLine(e12, this._tileInfo);
        break;
      case "fill":
        r13 = j3.fromCIMFill(e12, this._tileInfo);
        break;
      case "text":
        r13 = d9.fromCIMText(e12, this._tileInfo);
    }
    return this._cimTemplateCache.set(t12, r13), r13;
  }
  _createPrimitiveMeshTemplates(e12, t12, r13) {
    switch (t12.type) {
      case "esriSMS":
        return E4(e12, this._createSMS(t12));
      case "esriPMS":
        return E4(e12, this._createPMS(t12));
      case "esriSFS":
        return E4(e12, this._createSFS(t12, r13));
      case "line-marker":
        return E4(e12, this._createLMS(t12));
      case "esriPFS":
        return E4(e12, this._createPFS(t12, r13));
      case "esriSLS":
        return E4(e12, this._createSLS(t12, false));
      case "esriTS":
        return E4(e12, this._createTS(t12));
      default:
        return S4.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"), e12;
    }
  }
  _createMeshTemplates(e12, t12, r13) {
    if (t12.type.includes("3d"))
      return S4.error("3D symbols are not supported with MapView"), e12;
    if ("expanded-cim" === t12.type) {
      for (const r14 of t12.layers)
        "function" == typeof r14.materialHash ? E4(e12, this._createDynamicCIM(r14)) : E4(e12, this._createCIM(r14));
      return e12;
    }
    if ("composite-symbol" === t12.type) {
      for (const s11 of t12.layers)
        this._createPrimitiveMeshTemplates(e12, s11, r13);
      return e12;
    }
    return "cim" === t12.type || "label" === t12.type || "web-style" === t12.type ? e12 : this._createPrimitiveMeshTemplates(e12, t12, r13);
  }
};
var F = (e12) => {
  if (!e12.layers)
    return false;
  for (const t12 of e12.layers)
    if ("function" == typeof t12.materialHash)
      return true;
  return false;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/WGLMeshFactory.js
var a14 = class {
  constructor(e12, s11, r13) {
    this._loadPromise = i6(), this._geometryType = e12, this._idField = s11, this._templateStore = r13;
  }
  update(e12, t12) {
    null != e12.mesh.labels && (this._labelTemplates = this._createLabelTemplates(e12.mesh.labels, t12)), this._schema = e12;
  }
  _createLabelTemplates(e12, t12) {
    const s11 = /* @__PURE__ */ new Map();
    if ("simple" === e12.type) {
      for (const l11 of e12.classes) {
        const e13 = C3.fromLabelClass(l11, t12);
        s11.set(l11.index, e13);
      }
      return s11;
    }
    for (const l11 in e12.classes) {
      const i19 = e12.classes[l11];
      for (const e13 of i19) {
        const l12 = C3.fromLabelClass(e13, t12);
        s11.set(e13.index, l12);
      }
    }
    return s11;
  }
  get templates() {
    return this._templateStore;
  }
  async analyze(t12, r13, l11, a15, o12, n12, m8) {
    if (a2(m8))
      return;
    let p15;
    "dictionary" === (l11 == null ? void 0 : l11.type) && (p15 = await l11.analyze(this._idField, t12.copy(), r13, o12, n12, m8));
    let f12 = 0;
    for (; t12.next(); ) {
      let e12 = null;
      if (e12 = p15 ? p15[f12++] : null != a15 && p3(t12.getDisplayId()) && 1 !== t12.readAttribute("cluster_count") ? a15.match(this._idField, t12, this._geometryType, o12, n12) : l11.match(this._idField, t12, this._geometryType, o12, n12), t12.setGroupId(e12), G3(e12)) {
        const s11 = this._templateStore.getDynamicTemplateGroup(e12).templates;
        for (const e13 of s11)
          e13 && e13.analyze && e13.analyze(this._templateStore, t12, o12, n12);
      }
    }
    return await this._loadPromise, this._templateStore.finalize(m8);
  }
  async analyzeGraphics(t12, s11, r13, l11, a15, o12) {
    if (a2(o12))
      return;
    const n12 = t12.getCursor();
    for (r13 && await r13.analyze(this._idField, n12.copy(), s11, l11, a15, o12); n12.next(); ) {
      let e12 = n12.getGroupId();
      if (null != e12 && -1 !== e12 || (e12 = r13 == null ? void 0 : r13.match(this._idField, n12, n12.geometryType, l11, a15), n12.setGroupId(e12)), G3(e12)) {
        const t13 = this._templateStore.getDynamicTemplateGroup(e12).templates;
        for (const e13 of t13)
          e13 && e13.analyze && e13.analyze(this._templateStore, n12, l11, a15);
      }
      n12.setGroupId(e12);
    }
    return await this._loadPromise, this._templateStore.finalize(o12);
  }
  writeGraphic(e12, t12, s11, r13) {
    const l11 = t12.getGroupId(), a15 = t12.getDisplayId(), o12 = this._templateStore.getTemplateGroup(l11);
    if (e12.featureStart(t12.insertAfter, 0), null != a15) {
      if (G3(l11))
        for (const e13 of o12.templates)
          e13 && e13.bindFeature(t12, null, null);
      if (o12) {
        for (const l12 of o12.templates)
          l12 && l12.write(e12, t12, s11, r13);
        e12.featureEnd();
      }
    }
  }
  writeCursor(e12, t12, s11, r13, l11, a15, o12) {
    const n12 = t12.getGroupId(), m8 = t12.getDisplayId(), p15 = this._templateStore.getTemplateGroup(n12), f12 = p15.templates, u14 = this._getSortKeyValue(t12, p15);
    if (e12.featureStart(0, u14), null != m8 && f12) {
      if (G3(n12))
        for (const e13 of f12)
          e13.bindFeature(t12, s11, r13);
      for (const s12 of f12)
        s12.write(e12, t12, l11, o12);
      if (null != a15 && e12.hasRecords) {
        const s12 = a15 && this._findLabelRef(f12);
        this._writeLabels(e12, t12, a15, s12, l11, o12);
      }
      e12.featureEnd();
    }
  }
  _getSortKeyValue(e12, t12) {
    const s11 = this._schema.mesh.sortKey;
    if (null == s11)
      return 0;
    let r13 = 0;
    return r13 = true === s11.byRenderer && null != t12.sortKey ? t12.sortKey : null != s11.fieldIndex ? e12.getComputedNumericAtIndex(s11.fieldIndex) : null != s11.field ? e12.readAttribute(s11.field) : e12.readAttribute(this._idField), r13 *= "asc" === s11.order ? 1 : -1, null == r13 || isNaN(r13) ? 0 : r13;
  }
  _findLabelRef(e12) {
    for (const t12 of e12)
      if (t12 instanceof z4)
        return t12;
    return null;
  }
  _writeLabels(e12, t12, s11, r13, l11, i19) {
    for (const a15 of s11)
      if (null != a15 && a15) {
        const { glyphs: s12, rtl: o12, index: n12 } = a15, m8 = this._labelTemplates.get(n12);
        if (!m8)
          continue;
        m8.setZoomLevel(l11), m8.bindReferenceTemplate(r13), m8.bindTextInfo(s12, o12), m8.write(e12, t12, null, i19);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var l10 = s.getLogger("esri/views/2d/engine/webgl/util/Matcher");
async function o11(e12, t12, s11, r13) {
  switch (e12.type) {
    case "simple":
    case "heatmap":
      return u13.fromBasicRenderer(e12, t12, s11, r13);
    case "map":
      return d10.fromUVRenderer(e12, t12, s11, r13);
    case "interval":
      return m7.fromCBRenderer(e12, t12, s11, r13);
    case "dictionary":
      return y10.fromDictionaryRenderer(e12, t12, s11, r13);
    case "pie-chart":
      return c14.fromPieChartRenderer(e12, t12, s11, r13);
    case "subtype":
      return c14.fromSubtypes(e12, t12, s11, r13);
  }
}
var u13 = class _u {
  constructor() {
    this.type = "feature", this._defaultResult = null;
  }
  static async fromBasicRenderer(e12, t12, s11, r13) {
    const i19 = new _u();
    if (e12.symbol) {
      const a15 = await r12(e12.symbol, s11, r13), l11 = t12.createTemplateGroup(a15, null);
      i19.setDefault(l11);
    }
    return i19;
  }
  static async fromPieChartRenderer(e12, t12, s11, r13) {
    const i19 = new _u();
    if (e12.markerSymbol) {
      const a15 = await r12(e12.markerSymbol, s11, r13);
      let l11;
      e12.fillSymbol && (l11 = await r12(e12.fillSymbol, s11, r13));
      const o12 = t12.createTemplateGroup(a15, l11);
      i19.setDefault(o12);
    }
    return i19;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(e12) {
    this._defaultResult = e12;
  }
  match(e12, t12, s11, r13, i19) {
    return this.getDefault();
  }
  async analyze(e12, t12, s11, r13, i19, a15) {
    return null;
  }
};
var c14 = class _c extends u13 {
  constructor(e12, t12) {
    super(), this._subMatchers = e12, this._subtypeField = t12;
  }
  static async fromSubtypes(e12, t12, s11, r13) {
    const i19 = /* @__PURE__ */ new Map(), a15 = [];
    for (const n12 in e12.renderers) {
      const l11 = parseInt(n12, 10), u14 = o11(e12.renderers[n12], t12, s11, r13).then((e13) => i19.set(l11, e13));
      a15.push(u14);
    }
    return await Promise.all(a15), new _c(i19, e12.subtypeField);
  }
  match(e12, t12, s11, r13, i19) {
    const a15 = t12.readAttribute(this._subtypeField), n12 = this._subMatchers.get(a15);
    return n12 ? n12.match(e12, t12, s11, r13, i19) : null;
  }
};
var m7 = class _m extends u13 {
  constructor(e12, t12, s11, r13) {
    super(), this.type = "interval", this._intervals = [], this._isMaxInclusive = t12, this._fieldIndex = r13, this._field = e12, this._normalizationInfo = s11;
  }
  static async fromCBRenderer(e12, t12, s11, r13) {
    const { isMaxInclusive: i19, normalizationField: a15, normalizationTotal: l11, normalizationType: o12 } = e12, u14 = e12.field, c15 = new _m(u14, i19, { normalizationField: a15, normalizationTotal: l11, normalizationType: o12 }, e12.fieldIndex), d11 = await r12(e12.backgroundFillSymbol, s11, r13);
    await Promise.all(e12.intervals.map(async (e13) => {
      const i20 = await r12(e13.symbol, s11, r13), a16 = await t12.createTemplateGroup(i20, d11), l12 = { min: e13.min, max: e13.max };
      c15.add(l12, a16);
    }));
    const h10 = await r12(e12.defaultSymbol, s11, r13);
    if (h10) {
      const e13 = await t12.createTemplateGroup(h10, d11);
      c15.setDefault(e13);
    }
    return c15;
  }
  add(e12, t12) {
    this._intervals.push({ interval: e12, result: t12 }), this._intervals.sort((e13, t13) => e13.interval.min - t13.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  match(e12, t12, s11, r13, i19) {
    if (null == this._fieldIndex && !this._field)
      return this.getDefault();
    const a15 = null != this._fieldIndex ? t12.getComputedNumericAtIndex(this._fieldIndex) : this._getValueFromField(t12);
    if (null == a15 || isNaN(a15) || a15 === 1 / 0 || a15 === -1 / 0)
      return this.getDefault();
    for (let n12 = 0; n12 < this._intervals.length; n12++) {
      const { interval: e13, result: t13 } = this._intervals[n12], s12 = a15 >= e13.min, r14 = this._isMaxInclusive ? a15 <= e13.max : a15 < e13.max;
      if (s12 && r14)
        return t13;
    }
    return this.getDefault();
  }
  _needsNormalization() {
    const e12 = this._normalizationInfo;
    return e12 && (e12.normalizationField || e12.normalizationTotal || e12.normalizationType);
  }
  _getValueFromField(e12) {
    const t12 = e12.readAttribute(this._field);
    if (!this._needsNormalization() || null == t12)
      return t12;
    const { normalizationField: s11, normalizationTotal: r13, normalizationType: i19 } = this._normalizationInfo, a15 = e12.readAttribute(s11) ?? 1;
    if (i19)
      switch (i19) {
        case "esriNormalizeByField":
          return a15 ? t12 / a15 : void 0;
        case "esriNormalizeByLog":
          return Math.log(t12) * Math.LOG10E;
        case "esriNormalizeByPercentOfTotal":
          return t12 / r13 * 100;
        default:
          return void l10.error(`Found unknown normalization type: ${i19}`);
      }
    else
      l10.error("Normalization is required, but no type was set!");
  }
};
var d10 = class _d extends u13 {
  constructor(e12, t12, s11) {
    super(), this.type = "map", this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fieldsIndex = s11, this._fields = e12, this._seperator = t12 || "";
  }
  static async fromUVRenderer(e12, t12, s11, r13) {
    const i19 = e12.fieldDelimiter, a15 = [e12.field];
    e12.field2 && a15.push(e12.field2), e12.field3 && a15.push(e12.field3);
    const l11 = await r12(e12.backgroundFillSymbol, s11, r13), o12 = new _d(a15, i19, e12.fieldIndex);
    await Promise.all(e12.map.map(async (e13, i20) => {
      const a16 = await r12(e13.symbol, s11, r13), u15 = i20 + 1, c15 = await t12.createTemplateGroup(a16, l11, u15);
      "<Null>" === e13.value ? o12.setNullResult(c15) : o12.add(e13.value, c15);
    }));
    const u14 = await r12(e12.defaultSymbol, s11, r13);
    if (u14) {
      const e13 = Number.MAX_SAFE_INTEGER, s12 = await t12.createTemplateGroup(u14, l11, e13);
      o12.setDefault(s12);
    }
    return o12;
  }
  setNullResult(e12) {
    this._nullResult = e12;
  }
  add(e12, t12) {
    this._resultsMap.set(e12.toString(), t12);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  match(e12, t12, s11, r13, i19) {
    if (null == this._fieldsIndex && !this._fields)
      return this.getDefault();
    const a15 = null != this._fieldsIndex ? t12.getComputedStringAtIndex(this._fieldsIndex) : this._getValueFromFields(t12);
    if (null !== this._nullResult && (null == a15 || "" === a15 || "<Null>" === a15))
      return this._nullResult;
    if (null == a15)
      return this.getDefault();
    const n12 = a15.toString();
    return this._resultsMap.has(n12) ? this._resultsMap.get(n12) : this.getDefault();
  }
  _getValueFromFields(e12) {
    const t12 = [];
    for (const s11 of this._fields) {
      const r13 = e12.readAttribute(s11);
      null == r13 || "" === r13 ? t12.push("<Null>") : t12.push(r13);
    }
    return t12.join(this._seperator);
  }
};
async function h9(e12, t12) {
  const s11 = e12 || 1;
  if ("number" == typeof s11)
    return (e13, t13, r14) => s11;
  const r13 = await n6(s11, t12.spatialReference, t12.fields);
  return (e13, s12, i19) => s7(r13, e13, { $view: i19 }, t12.geometryType, s12) || 1;
}
var f11;
async function p14() {
  return f11 || (f11 = import("./createSymbolSchema-T7GI4YCI.js")), f11;
}
var y10 = class _y extends u13 {
  constructor(e12, t12, s11, i19, a15, n12) {
    super(), this.type = "dictionary", this._groupIdCache = new e2(100), this._loader = e12, this._fieldMap = e12.fieldMap, this._symbolFields = e12.getSymbolFields(), this._templates = t12, this._info = s11, this._scaleFn = i19, this._schemaUtilsModule = a15, this._symbolOptions = n12;
  }
  static async fromDictionaryRenderer(e12, t12, s11, r13) {
    const [{ DictionaryLoader: i19 }, a15] = await Promise.all([import("./DictionaryLoader-JVVPMIB4.js"), p14()]), n12 = new i19(e12.url, e12.config, e12.fieldMap);
    await n12.fetchResources({ spatialReference: s11.spatialReference, fields: s11.fields });
    const l11 = await h9(e12.scaleExpression, s11);
    return new _y(n12, t12, s11, l11, a15, e12.symbolOptions);
  }
  async _analyzeFeature(e12, s11, r13, i19, a15) {
    const o12 = e12.readLegacyFeature(), u14 = this._scaleFn(o12, r13, i19), c15 = this._attributeHash(o12) + "-" + u14, m8 = this._groupIdCache.get(c15);
    if (m8)
      return m8;
    const d11 = { ...i19, spatialReference: this._info.spatialReference, abortOptions: a15, fields: this._info.fields }, h10 = await this._loader.getSymbolAsync(o12, d11), f12 = this._schemaUtilsModule.createSymbolSchema(h10, this._symbolOptions), p15 = r12(f12, this._info, s11, a15).then((e13) => {
      if ("expanded-cim" !== (e13 == null ? void 0 : e13.type))
        return l10.error(new s2("mapview-bad-type", `Found unexpected type ${e13 == null ? void 0 : e13.type} in dictionary response`)), null;
      e13.hash += "-" + u14;
      for (const t12 of e13.layers)
        t12.scaleFactor = u14, t12.templateHash += "-" + u14;
      return this._templates.createTemplateGroup(e13, null);
    });
    return this._groupIdCache.put(c15, p15, 1), p15;
  }
  async analyze(t12, s11, r13, i19, a15, n12) {
    const l11 = s11.getCursor(), o12 = [];
    for (; l11.next(); )
      o12.push(this._analyzeFeature(l11, r13, i19, a15, n12));
    return Promise.all(o12).then((t13) => t13.filter(R));
  }
  match(e12, t12, s11, r13, i19) {
    return null;
  }
  _attributeHash(e12) {
    var _a;
    let t12 = "";
    for (const s11 of this._symbolFields) {
      const r13 = (_a = this._fieldMap) == null ? void 0 : _a[s11];
      r13 && (t12 += e12.attributes[r13] + "-");
    }
    return t12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ResourceManagerProxy.js
var t11 = class {
  constructor(e12) {
    this._remoteClient = e12, this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null, this.geometryEnginePromise = null;
  }
  destroy() {
  }
  async fetchResource(t12, r13) {
    const s11 = this._resourceMap, i19 = s11.get(t12);
    if (i19)
      return i19;
    let n12 = this._inFlightResourceMap.get(t12);
    if (n12)
      return n12;
    try {
      n12 = this._remoteClient.invoke("tileRenderer.fetchResource", { url: t12 }, { ...r13 }), this._inFlightResourceMap.set(t12, n12), n12.then((e12) => (this._inFlightResourceMap.delete(t12), s11.set(t12, e12), e12));
    } catch (o12) {
      return d(o12) ? null : { width: 0, height: 0 };
    }
    return n12;
  }
  getResource(e12) {
    return this._resourceMap.get(e12) ?? null;
  }
  loadFont(e12) {
    return Promise.resolve(null);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processors/SymbolProcessor.js
function b8(e12, t12) {
  return (!e12.minScale || e12.minScale >= t12) && (!e12.maxScale || e12.maxScale <= t12);
}
function S5(e12) {
  const t12 = e12.message, r13 = { message: { data: {}, tileKey: t12.tileKey, tileKeyOrigin: t12.tileKeyOrigin, version: t12.version }, transferList: new Array() };
  for (const i19 in t12.data) {
    const e13 = i19, a15 = t12.data[e13];
    if (r13.message.data[e13] = null, null != a15) {
      const t13 = a15.stride, i20 = a15.indices.slice(0), o12 = a15.vertices.slice(0), n12 = a15.records.slice(0), l11 = { stride: t13, indices: i20, vertices: o12, records: n12, metrics: n(a15.metrics, (e14) => e14.slice(0)) };
      r13.transferList.push(i20, o12, n12), r13.message.data[e13] = l11;
    }
  }
  return r13;
}
var w10 = class extends p2 {
  constructor() {
    super(...arguments), this.type = "symbol", this._matchers = { feature: null, aggregate: null }, this._bufferData = /* @__PURE__ */ new Map(), this._bufferIds = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]), this._resourceManagerProxy = new t11(this.remoteClient);
  }
  destroy() {
    this._resourceManagerProxy.destroy();
  }
  get supportsTileUpdates() {
    return true;
  }
  forEachBufferId(e12) {
    this._bufferIds.forEach((t12) => {
      t12.forEach(e12);
    });
  }
  async update(e12, t12) {
    var _a;
    const s11 = t12.schema.processors[0];
    if ("symbol" !== s11.type)
      return;
    const r13 = a4(this._schema, s11);
    (s4(r13, "mesh") || s4(r13, "target")) && (e12.mesh = true, (_a = e12.why) == null ? void 0 : _a.mesh.push("Symbology changed"), this._schema = s11, this._factory = this._createFactory(s11), this._factory.update(s11, this.tileStore.tileScheme.tileInfo));
  }
  onTileMessage(e12, t12, s11, r13) {
    return s3(r13), this._onTileData(e12, t12, s11, r13);
  }
  onTileClear(e12, t12) {
    const s11 = { clear: true, end: t12 };
    return this._bufferData.delete(e12.key.id), this._bufferIds.delete(e12.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e12.id, data: s11 });
  }
  onTileError(e12, t12, s11) {
    const r13 = s11.signal, i19 = { tileKey: e12.id, error: t12 };
    return this.remoteClient.invoke("tileRenderer.onTileError", i19, { signal: r13 });
  }
  onTileUpdate(e12) {
    for (const t12 of e12.removed)
      this._bufferData.has(t12.key.id) && this._bufferData.delete(t12.key.id), this._bufferIds.has(t12.key.id) && this._bufferIds.delete(t12.key.id);
    for (const t12 of e12.added)
      this._bufferData.forEach((e13) => {
        for (const s11 of e13)
          s11.message.tileKey === t12.id && this._updateTileMesh("append", t12, S5(s11), [], false, false, null);
      });
  }
  _addBufferData(e12, t12) {
    var _a;
    this._bufferData.has(e12) || this._bufferData.set(e12, []), (_a = this._bufferData.get(e12)) == null ? void 0 : _a.push(S5(t12));
  }
  _createFactory(e12) {
    const { geometryType: t12, objectIdField: r13, fields: i19 } = this.service, a15 = (e13, t13) => this.remoteClient.invoke("tileRenderer.getMaterialItems", e13, t13), o12 = { geometryType: t12, fields: i19, spatialReference: f2.fromJSON(this.spatialReference) }, n12 = new x9(a15, this.tileStore.tileScheme.tileInfo), { matcher: l11, aggregateMatcher: d11 } = e12.mesh;
    return this._store = n12, this._matchers.feature = o11(l11, n12, o12, this._resourceManagerProxy), this._matchers.aggregate = n(d11, (e13) => o11(e13, n12, o12, this._resourceManagerProxy)), new a14(t12, r13, n12);
  }
  async _onTileData(e12, t12, s11, r13) {
    var _a;
    s3(r13);
    const { type: a15, addOrUpdate: o12, remove: n12, clear: l11, end: c15 } = t12, d11 = !!this._schema.mesh.sortKey;
    if (!o12) {
      const t13 = { type: a15, addOrUpdate: null, remove: n12, clear: l11, end: c15, sort: d11 };
      return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e12.id, data: t13 }, r13);
    }
    const h10 = this._processFeatures(e12, o12, s11, r13, (_a = t12.status) == null ? void 0 : _a.version);
    try {
      const s12 = await h10;
      if (null == s12) {
        const t13 = { type: a15, addOrUpdate: null, remove: n12, clear: l11, end: c15, sort: d11 };
        return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e12.id, data: t13 }, r13);
      }
      const i19 = [];
      for (const t13 of s12) {
        let s13 = false;
        const r14 = t13.message.bufferIds, a16 = e12.key.id, o13 = t13.message.tileKey;
        if (a16 !== o13 && null != r14) {
          if (!this.tileStore.get(o13)) {
            this._addBufferData(a16, t13), i19.push(t13);
            continue;
          }
          let e13 = this._bufferIds.get(o13);
          e13 || (e13 = /* @__PURE__ */ new Set(), this._bufferIds.set(o13, e13));
          const n13 = Array.from(r14);
          for (const t14 of n13) {
            if (e13.has(t14)) {
              s13 = true;
              break;
            }
            e13.add(t14);
          }
        }
        s13 || (this._addBufferData(a16, t13), i19.push(t13));
      }
      await Promise.all(i19.map((s13) => {
        const i20 = e12.key.id === s13.message.tileKey, o13 = i20 ? t12.remove : [], n13 = i20 && t12.end;
        return this._updateTileMesh(a15, e12, s13, o13, n13, !!t12.clear, r13.signal);
      }));
    } catch (f12) {
      this._handleError(e12, f12, r13);
    }
  }
  async _updateTileMesh(e12, t12, r13, a15, o12, n12, l11) {
    const c15 = e12, d11 = r13.message.tileKey, h10 = !!this._schema.mesh.sortKey;
    d11 !== t12.key.id && (o12 = false);
    const f12 = { type: c15, addOrUpdate: n(r13, (e13) => e13.message), remove: a15, clear: n12, end: o12, sort: h10 }, u14 = { transferList: n(r13, (e13) => e13.transferList) || [], signal: l11 };
    return s3(u14), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: d11, data: f12 }, u14);
  }
  async _processFeatures(e12, t12, s11, r13, a15) {
    if (null == t12 || !t12.hasFeatures)
      return null;
    const o12 = { transform: e12.transform, hasZ: false, hasM: false }, n12 = this._factory, l11 = { viewingMode: "", scale: e12.scale }, c15 = await this._matchers.feature, d11 = await this._matchers.aggregate;
    s3(r13);
    const h10 = this._getLabelInfos(e12, t12);
    return await n12.analyze(t12.getCursor(), this._resourceManagerProxy, c15, d11, o12, l11), s3(r13), this._writeFeatureSet(e12, t12, o12, h10, n12, s11, a15);
  }
  _writeFeatureSet(e12, t12, s11, r13, i19, a15, o12) {
    const n12 = t12.getSize(), l11 = this._schema.mesh.matcher.symbologyType, c15 = new E3(e12.key.id, { features: n12, records: n12, metrics: 0 }, l11, a15, l11 !== S.HEATMAP, o12), d11 = { viewingMode: "", scale: e12.scale }, u14 = t12.getCursor();
    for (; u14.next(); )
      try {
        const t13 = u14.getDisplayId(), a16 = null != r13 ? r13.get(t13) : null;
        i19.writeCursor(c15, u14, s11, d11, e12.level, a16, this._resourceManagerProxy);
      } catch (g7) {
      }
    const m8 = e12.tileInfoView.tileInfo.isWrappable;
    return c15.serialize(m8);
  }
  _handleError(e12, t12, s11) {
    if (!d(t12)) {
      const r13 = { tileKey: e12.id, error: t12.message };
      return this.remoteClient.invoke("tileRenderer.onTileError", r13, { signal: s11.signal });
    }
    return Promise.resolve();
  }
  _getLabelingSchemaForScale(e12) {
    const t12 = this._schema.mesh.labels;
    if (null == t12)
      return null;
    if ("subtype" === t12.type) {
      const s12 = { type: "subtype", classes: {} };
      let r13 = false;
      for (const i19 in t12.classes) {
        const a15 = t12.classes[i19].filter((t13) => b8(t13, e12.scale));
        r13 = r13 || !!a15.length, s12.classes[i19] = a15;
      }
      return r13 ? s12 : null;
    }
    const s11 = t12.classes.filter((t13) => b8(t13, e12.scale));
    return s11.length ? { type: "simple", classes: s11 } : null;
  }
  _getLabels(e12, t12) {
    if ("subtype" === t12.type) {
      const s11 = this.service.subtypeField, i19 = u(s11, "Expected to find subtype Field"), a15 = e12.readAttribute(i19);
      return null == a15 ? [] : t12.classes[a15] ?? [];
    }
    return t12.classes;
  }
  _getLabelInfos(e12, s11) {
    const r13 = this._getLabelingSchemaForScale(e12);
    if (null == r13)
      return null;
    const i19 = /* @__PURE__ */ new Map(), a15 = s11.getCursor();
    for (; a15.next(); ) {
      const e13 = a15.getDisplayId(), s12 = [], o12 = p3(e13), n12 = o12 && 1 !== a15.readAttribute("cluster_count") ? "aggregate" : "feature", l11 = this._getLabels(a15, r13);
      for (const r14 of l11) {
        if (r14.target !== n12)
          continue;
        const i20 = a15.getStorage(), l12 = o12 && "feature" === n12 ? i20.getComputedStringAtIndex(a15.readAttribute("referenceId"), r14.fieldIndex) : i20.getComputedStringAtIndex(e13, r14.fieldIndex);
        if (!l12)
          continue;
        const c15 = i4(l12.toString()), d11 = c15[0], h10 = c15[1];
        this._store.getMosaicItem(r14.symbol, n10(d11)).then((e14) => {
          s12[r14.index] = { glyphs: e14.glyphMosaicItems ?? [], rtl: h10, index: r14.index };
        });
      }
      i19.set(e13, s12);
    }
    return i19;
  }
};
w10 = e([a("esri.views.2d.layers.features.processors.SymbolProcessor")], w10);
var I = w10;
export {
  I as default
};
//# sourceMappingURL=SymbolProcessor-7DP2MY7I.js.map
