import {
  p,
  v,
  y as y2,
  z
} from "./chunk-2735WBYK.js";
import {
  t as t2
} from "./chunk-OZXJDVTE.js";
import {
  a as a4
} from "./chunk-W3WHCGIQ.js";
import {
  h
} from "./chunk-ZXXKE5XP.js";
import {
  M
} from "./chunk-T35GN7EL.js";
import {
  f,
  x2 as x
} from "./chunk-7U6V6KY2.js";
import {
  o,
  r as r2
} from "./chunk-NFY4EX6G.js";
import {
  s as s5
} from "./chunk-ULGEYK3G.js";
import {
  s as s4
} from "./chunk-F3KGLZDZ.js";
import {
  l
} from "./chunk-CHTUPHTO.js";
import {
  y
} from "./chunk-453UIKKW.js";
import {
  a2
} from "./chunk-5BLDWPLW.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a2 as a3,
  c2 as c,
  r,
  s2 as s3
} from "./chunk-UYRCWUYQ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  has,
  t
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js
var l2 = class {
  constructor(l9 = null, a16 = null, t11 = null) {
    this.minValue = l9, this.maxValue = a16, this.noDataValue = t11;
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/pixelRangeUtils.js
var t3 = 9999999e31;
var e2 = 2e-7;
var n = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767], u32: [0, 4294967295], s32: [-2147483648, 2147483647], f32: [-34028234663852886e22, 34028234663852886e22], f64: [-Number.MAX_VALUE, Number.MAX_VALUE], unknown: void 0, c64: void 0, c128: void 0 };
function s6(t11) {
  return n[t11] ?? [-34028234663852886e22, 34028234663852886e22];
}
function u(n14, u14, i11) {
  if (n14.depthCount && n14.depthCount > 1)
    return;
  const { pixels: a16, statistics: o10, pixelType: l9 } = n14, r16 = a16[0].length, f11 = n14.bandMasks ?? [], c11 = n14.mask ?? new Uint8Array(r16).fill(255), b5 = "f32" === l9 || "f64" === l9, m8 = s6(l9);
  let d8 = false;
  for (let s14 = 0; s14 < a16.length; s14++) {
    const n15 = "number" == typeof u14 ? u14 : u14[s14];
    if (null == n15)
      continue;
    const h10 = (o10 == null ? void 0 : o10[s14].minValue) ?? m8[0], p10 = (o10 == null ? void 0 : o10[s14].maxValue) ?? m8[1];
    if (h10 > n15 + Number.EPSILON || p10 < n15 - Number.EPSILON)
      continue;
    const N2 = f11[s14] || new Uint8Array(r16).fill(255), M6 = a16[s14], A4 = i11 == null ? void 0 : i11.customFloatTolerance;
    if (b5 && 0 !== A4) {
      let s15 = A4;
      s15 || (s15 = Math.abs(n15) >= t3 ? e2 * Math.abs(n15) : "f32" === l9 ? 2 ** -23 : Number.EPSILON);
      for (let t11 = 0; t11 < M6.length; t11++)
        N2[t11] && Math.abs(M6[t11] - n15) < s15 && (M6[t11] = 0, N2[t11] = 0, c11[t11] = 0, d8 = true);
    } else
      for (let t11 = 0; t11 < M6.length; t11++)
        N2[t11] && M6[t11] === n15 && (M6[t11] = 0, N2[t11] = 0, c11[t11] = 0, d8 = true);
    f11[s14] = N2;
  }
  d8 && (n14.bandMasks = f11, n14.mask = c11), d8 && "updateStatistics" in n14 && n14.updateStatistics();
}

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var p2;
var c2 = p2 = class extends l {
  static createEmptyBand(t11, e8) {
    return new (p2.getPixelArrayConstructor(t11))(e8);
  }
  static getPixelArrayConstructor(t11) {
    let e8;
    switch (t11) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e8 = Uint8Array;
        break;
      case "u16":
        e8 = Uint16Array;
        break;
      case "u32":
        e8 = Uint32Array;
        break;
      case "s8":
        e8 = Int8Array;
        break;
      case "s16":
        e8 = Int16Array;
        break;
      case "s32":
        e8 = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e8 = Float32Array;
        break;
      case "f64":
        e8 = Float64Array;
    }
    return e8;
  }
  constructor(t11) {
    super(t11), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.premultiplyAlpha = false, this.statistics = null, this.depthCount = 1;
  }
  castPixelType(t11) {
    if (!t11)
      return "f32";
    let e8 = t11.toLowerCase();
    return ["u1", "u2", "u4"].includes(e8) ? e8 = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e8) || (e8 = "f32"), e8;
  }
  getPlaneCount() {
    var _a;
    return (_a = this.pixels) == null ? void 0 : _a.length;
  }
  addData(t11) {
    if (!t11.pixels || t11.pixels.length !== this.width * this.height)
      throw new s2("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t11.pixels), this.statistics.push(t11.statistics ?? new l2());
  }
  getAsRGBA() {
    const t11 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t11);
        break;
      default:
        this._fillFrom8Bit(t11);
    }
    return new Uint8ClampedArray(t11);
  }
  getAsRGBAFloat() {
    const t11 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t11), t11;
  }
  updateStatistics() {
    if (!this.pixels)
      return;
    this.statistics = this.pixels.map((t12) => this._calculateBandStatistics(t12, this.mask));
    const t11 = this.mask;
    let e8 = 0;
    if (null != t11)
      for (let s14 = 0; s14 < t11.length; s14++)
        t11[s14] && e8++;
    else
      e8 = this.width * this.height;
    this.validPixelCount = e8;
  }
  clamp(t11) {
    if (!t11 || "f64" === t11 || "f32" === t11 || !this.pixels)
      return;
    const [e8, s14] = s6(t11), i11 = this.pixels, l9 = this.width * this.height, r16 = i11.length;
    let o10, a16, n14;
    const c11 = [];
    for (let h10 = 0; h10 < r16; h10++) {
      n14 = p2.createEmptyBand(t11, l9), o10 = i11[h10];
      for (let t12 = 0; t12 < l9; t12++)
        a16 = o10[t12], n14[t12] = a16 > s14 ? s14 : a16 < e8 ? e8 : a16;
      c11.push(n14);
    }
    this.pixels = c11, this.pixelType = t11;
  }
  extractBands(t11) {
    var _a;
    const { pixels: e8, statistics: s14 } = this;
    if (null == t11 || 0 === t11.length || !e8 || 0 === e8.length)
      return this;
    const i11 = e8.length, l9 = t11.some((t12) => t12 >= e8.length), r16 = i11 === t11.length && !t11.some((t12, e9) => t12 !== e9);
    if (l9 || r16)
      return this;
    const o10 = ((_a = this.bandMasks) == null ? void 0 : _a.length) === i11 ? t11.map((t12) => this.bandMasks[t12]) : void 0;
    let { mask: a16, validPixelCount: n14 } = this;
    const { width: h10, height: c11 } = this;
    if (o10) {
      if (1 === o10.length)
        a16 = o10[0];
      else {
        const t12 = h10 * c11;
        a16 = new Uint8Array(t12).fill(255);
        for (let e9 = 0; e9 < o10.length; e9++) {
          const s15 = o10[e9];
          for (let e10 = 0; e10 < t12; e10++)
            s15[e10] || (a16[e10] = 0);
        }
      }
      n14 = a16.filter((t12) => !!t12).length;
    }
    return new p2({ pixelType: this.pixelType, width: h10, height: c11, mask: a16, bandMasks: o10, validPixelCount: n14, maskIsAlpha: this.maskIsAlpha, pixels: t11.map((t12) => e8[t12]), statistics: s14 && t11.map((t12) => s14[t12]) });
  }
  clone() {
    const t11 = new p2({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount });
    let e8;
    null != this.mask && (this.mask instanceof Uint8Array ? t11.mask = new Uint8Array(this.mask) : t11.mask = this.mask.slice(0)), this.bandMasks && (t11.bandMasks = this.bandMasks.map((t12) => new Uint8Array(t12)));
    const s14 = p2.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t11.pixels = [];
      const i11 = !!this.pixels[0].slice;
      for (e8 = 0; e8 < this.pixels.length; e8++)
        t11.pixels[e8] = i11 ? this.pixels[e8].slice(0, this.pixels[e8].length) : new s14(this.pixels[e8]);
    }
    if (this.statistics)
      for (t11.statistics = [], e8 = 0; e8 < this.statistics.length; e8++)
        t11.statistics[e8] = a(this.statistics[e8]);
    return t11.premultiplyAlpha = this.premultiplyAlpha, t11;
  }
  _fillFrom8Bit(t11) {
    const { mask: e8, maskIsAlpha: s14, premultiplyAlpha: i11, pixels: r16 } = this;
    if (!t11 || !r16 || !r16.length)
      return void s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let o10, a16, n14, h10;
    o10 = a16 = n14 = r16[0], r16.length >= 3 ? (a16 = r16[1], n14 = r16[2]) : 2 === r16.length && (a16 = r16[1]);
    const p10 = new Uint32Array(t11), c11 = this.width * this.height;
    if (o10.length === c11)
      if (null != e8 && e8.length === c11)
        if (s14)
          for (h10 = 0; h10 < c11; h10++) {
            const t12 = e8[h10];
            if (t12) {
              const e9 = t12 / 255;
              p10[h10] = i11 ? t12 << 24 | n14[h10] * e9 << 16 | a16[h10] * e9 << 8 | o10[h10] * e9 : t12 << 24 | n14[h10] << 16 | a16[h10] << 8 | o10[h10];
            }
          }
        else
          for (h10 = 0; h10 < c11; h10++)
            e8[h10] && (p10[h10] = 255 << 24 | n14[h10] << 16 | a16[h10] << 8 | o10[h10]);
      else
        for (h10 = 0; h10 < c11; h10++)
          p10[h10] = 255 << 24 | n14[h10] << 16 | a16[h10] << 8 | o10[h10];
    else
      s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t11) {
    const { pixels: e8, mask: s14, statistics: i11 } = this;
    if (!t11 || !e8 || !e8.length)
      return void s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const r16 = this.pixelType;
    let o10 = 1, a16 = 0, n14 = 1;
    if (i11 && i11.length > 0) {
      for (const t12 of i11)
        if (null != t12.minValue && (a16 = Math.min(a16, t12.minValue)), null != t12.maxValue && null != t12.minValue) {
          const e9 = t12.maxValue - t12.minValue;
          n14 = Math.max(n14, e9);
        }
      o10 = 255 / n14;
    } else {
      let t12 = 255;
      "s8" === r16 ? (a16 = -128, t12 = 127) : "u16" === r16 ? t12 = 65535 : "s16" === r16 ? (a16 = -32768, t12 = 32767) : "u32" === r16 ? t12 = 4294967295 : "s32" === r16 ? (a16 = -2147483648, t12 = 2147483647) : "f32" === r16 ? (a16 = -34e38, t12 = 34e38) : "f64" === r16 && (a16 = -Number.MAX_VALUE, t12 = Number.MAX_VALUE), o10 = 255 / (t12 - a16);
    }
    const h10 = new Uint32Array(t11), p10 = this.width * this.height;
    let c11, u14, g7, f11, m8;
    if (c11 = u14 = g7 = e8[0], c11.length !== p10)
      return s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e8.length >= 2)
      if (u14 = e8[1], e8.length >= 3 && (g7 = e8[2]), null != s14 && s14.length === p10)
        for (f11 = 0; f11 < p10; f11++)
          s14[f11] && (h10[f11] = 255 << 24 | (g7[f11] - a16) * o10 << 16 | (u14[f11] - a16) * o10 << 8 | (c11[f11] - a16) * o10);
      else
        for (f11 = 0; f11 < p10; f11++)
          h10[f11] = 255 << 24 | (g7[f11] - a16) * o10 << 16 | (u14[f11] - a16) * o10 << 8 | (c11[f11] - a16) * o10;
    else if (null != s14 && s14.length === p10)
      for (f11 = 0; f11 < p10; f11++)
        m8 = (c11[f11] - a16) * o10, s14[f11] && (h10[f11] = 255 << 24 | m8 << 16 | m8 << 8 | m8);
    else
      for (f11 = 0; f11 < p10; f11++)
        m8 = (c11[f11] - a16) * o10, h10[f11] = 255 << 24 | m8 << 16 | m8 << 8 | m8;
  }
  _fillFrom32Bit(t11) {
    const { pixels: e8, mask: s14 } = this;
    if (!t11 || !e8 || !e8.length)
      return s.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i11, r16, o10, a16;
    i11 = r16 = o10 = e8[0], e8.length >= 3 ? (r16 = e8[1], o10 = e8[2]) : 2 === e8.length && (r16 = e8[1]);
    const n14 = this.width * this.height;
    if (i11.length !== n14)
      return s.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let h10 = 0;
    if (null != s14 && s14.length === n14)
      for (a16 = 0; a16 < n14; a16++)
        t11[h10++] = i11[a16], t11[h10++] = r16[a16], t11[h10++] = o10[a16], t11[h10++] = 1 & s14[a16];
    else
      for (a16 = 0; a16 < n14; a16++)
        t11[h10++] = i11[a16], t11[h10++] = r16[a16], t11[h10++] = o10[a16], t11[h10++] = 1;
  }
  _calculateBandStatistics(t11, e8) {
    let s14 = 1 / 0, i11 = -1 / 0;
    const l9 = t11.length;
    let r16, o10 = 0;
    if (null != e8)
      for (r16 = 0; r16 < l9; r16++)
        e8[r16] && (o10 = t11[r16], s14 = o10 < s14 ? o10 : s14, i11 = o10 > i11 ? o10 : i11);
    else
      for (r16 = 0; r16 < l9; r16++)
        o10 = t11[r16], s14 = o10 < s14 ? o10 : s14, i11 = o10 > i11 ? o10 : i11;
    return new l2(s14, i11);
  }
};
e([y({ json: { write: true } })], c2.prototype, "width", void 0), e([y({ json: { write: true } })], c2.prototype, "height", void 0), e([y({ json: { write: true } })], c2.prototype, "pixelType", void 0), e([s5("pixelType")], c2.prototype, "castPixelType", null), e([y({ json: { write: true } })], c2.prototype, "validPixelCount", void 0), e([y({ json: { write: true } })], c2.prototype, "mask", void 0), e([y({ json: { write: true } })], c2.prototype, "maskIsAlpha", void 0), e([y({ json: { write: true } })], c2.prototype, "pixels", void 0), e([y()], c2.prototype, "premultiplyAlpha", void 0), e([y({ json: { write: true } })], c2.prototype, "statistics", void 0), e([y({ json: { write: true } })], c2.prototype, "depthCount", void 0), e([y({ json: { write: true } })], c2.prototype, "noDataValues", void 0), e([y({ json: { write: true } })], c2.prototype, "bandMasks", void 0), c2 = p2 = e([a2("esri.layers.support.PixelBlock")], c2);
var u2 = c2;

// node_modules/@arcgis/core/chunks/Zlib.js
var e3;
var r3;
var i;
var s7 = { exports: {} };
s7.exports, r3 = s7, void 0 !== (e3 = function() {
  function t11() {
    this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = null;
  }
  return t11.prototype = { ensureBuffer: function(t12) {
    var e8 = this.buffer, r16 = e8 ? e8.byteLength : 0;
    if (t12 < r16)
      return e8;
    for (var i11 = 512; i11 < t12; )
      i11 <<= 1;
    for (var s14 = new Uint8Array(i11), f11 = 0; f11 < r16; ++f11)
      s14[f11] = e8[f11];
    return this.buffer = s14;
  }, getByte: function() {
    for (var t12 = this.pos; this.bufferLength <= t12; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }, getBytes: function(t12) {
    var e8 = this.pos;
    if (t12) {
      this.ensureBuffer(e8 + t12);
      for (var r16 = e8 + t12; !this.eof && this.bufferLength < r16; )
        this.readBlock();
      var i11 = this.bufferLength;
      r16 > i11 && (r16 = i11);
    } else {
      for (; !this.eof; )
        this.readBlock();
      r16 = this.bufferLength;
    }
    return this.pos = r16, this.buffer.subarray(e8, r16);
  }, lookChar: function() {
    for (var t12 = this.pos; this.bufferLength <= t12; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos]);
  }, getChar: function() {
    for (var t12 = this.pos; this.bufferLength <= t12; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos++]);
  }, makeSubStream: function(t12, e8, r16) {
    for (var i11 = t12 + e8; this.bufferLength <= i11 && !this.eof; )
      this.readBlock();
    return new Stream(this.buffer, t12, e8, r16);
  }, skip: function(t12) {
    t12 || (t12 = 1), this.pos += t12;
  }, reset: function() {
    this.pos = 0;
  } }, t11;
}(), i = function() {
  if (!self || !self.Uint32Array)
    return null;
  var t11 = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), r16 = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), i11 = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), s14 = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], f11 = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
  function o10(t12) {
    throw new Error(t12);
  }
  function n14(t12) {
    var r17 = 0, i12 = t12[r17++], s15 = t12[r17++];
    -1 != i12 && -1 != s15 || o10("Invalid header in flate stream"), 8 != (15 & i12) && o10("Unknown compression method in flate stream"), ((i12 << 8) + s15) % 31 != 0 && o10("Bad FCHECK in flate stream"), 32 & s15 && o10("FDICT bit set in flate stream"), this.bytes = t12, this.bytesPos = r17, this.codeSize = 0, this.codeBuf = 0, e3.call(this);
  }
  return n14.prototype = Object.create(e3.prototype), n14.prototype.getBits = function(t12) {
    for (var e8, r17 = this.codeSize, i12 = this.codeBuf, s15 = this.bytes, f12 = this.bytesPos; r17 < t12; )
      void 0 === (e8 = s15[f12++]) && o10("Bad encoding in flate stream"), i12 |= e8 << r17, r17 += 8;
    return e8 = i12 & (1 << t12) - 1, this.codeBuf = i12 >> t12, this.codeSize = r17 -= t12, this.bytesPos = f12, e8;
  }, n14.prototype.getCode = function(t12) {
    for (var e8 = t12[0], r17 = t12[1], i12 = this.codeSize, s15 = this.codeBuf, f12 = this.bytes, n15 = this.bytesPos; i12 < r17; ) {
      var a16;
      void 0 === (a16 = f12[n15++]) && o10("Bad encoding in flate stream"), s15 |= a16 << i12, i12 += 8;
    }
    var h10 = e8[s15 & (1 << r17) - 1], u14 = h10 >> 16, l9 = 65535 & h10;
    return (0 == i12 || i12 < u14 || 0 == u14) && o10("Bad encoding in flate stream"), this.codeBuf = s15 >> u14, this.codeSize = i12 - u14, this.bytesPos = n15, l9;
  }, n14.prototype.generateHuffmanTable = function(t12) {
    for (var e8 = t12.length, r17 = 0, i12 = 0; i12 < e8; ++i12)
      t12[i12] > r17 && (r17 = t12[i12]);
    for (var s15 = 1 << r17, f12 = new Uint32Array(s15), o11 = 1, n15 = 0, a16 = 2; o11 <= r17; ++o11, n15 <<= 1, a16 <<= 1)
      for (var h10 = 0; h10 < e8; ++h10)
        if (t12[h10] == o11) {
          var u14 = 0, l9 = n15;
          for (i12 = 0; i12 < o11; ++i12)
            u14 = u14 << 1 | 1 & l9, l9 >>= 1;
          for (i12 = u14; i12 < s15; i12 += a16)
            f12[i12] = o11 << 16 | h10;
          ++n15;
        }
    return [f12, r17];
  }, n14.prototype.readBlock = function() {
    function e8(t12, e9, r17, i12, s15) {
      for (var f12 = t12.getBits(r17) + i12; f12-- > 0; )
        e9[b5++] = s15;
    }
    var n15 = this.getBits(3);
    if (1 & n15 && (this.eof = true), 0 != (n15 >>= 1)) {
      var a16, h10;
      if (1 == n15)
        a16 = s14, h10 = f11;
      else if (2 == n15) {
        for (var u14 = this.getBits(5) + 257, l9 = this.getBits(5) + 1, c11 = this.getBits(4) + 4, d8 = Array(t11.length), b5 = 0; b5 < c11; )
          d8[t11[b5++]] = this.getBits(3);
        for (var v6 = this.generateHuffmanTable(d8), g7 = 0, B4 = (b5 = 0, u14 + l9), p10 = new Array(B4); b5 < B4; ) {
          var y7 = this.getCode(v6);
          16 == y7 ? e8(this, p10, 2, 3, g7) : 17 == y7 ? e8(this, p10, 3, 3, g7 = 0) : 18 == y7 ? e8(this, p10, 7, 11, g7 = 0) : p10[b5++] = g7 = y7;
        }
        a16 = this.generateHuffmanTable(p10.slice(0, u14)), h10 = this.generateHuffmanTable(p10.slice(u14, B4));
      } else
        o10("Unknown block type in flate stream");
      for (var m8 = (T4 = this.buffer) ? T4.length : 0, k5 = this.bufferLength; ; ) {
        var w6 = this.getCode(a16);
        if (w6 < 256)
          k5 + 1 >= m8 && (m8 = (T4 = this.ensureBuffer(k5 + 1)).length), T4[k5++] = w6;
        else {
          if (256 == w6)
            return void (this.bufferLength = k5);
          var C6 = (w6 = r16[w6 -= 257]) >> 16;
          C6 > 0 && (C6 = this.getBits(C6)), g7 = (65535 & w6) + C6, w6 = this.getCode(h10), (C6 = (w6 = i11[w6]) >> 16) > 0 && (C6 = this.getBits(C6));
          var L3 = (65535 & w6) + C6;
          k5 + g7 >= m8 && (m8 = (T4 = this.ensureBuffer(k5 + g7)).length);
          for (var S4 = 0; S4 < g7; ++S4, ++k5)
            T4[k5] = T4[k5 - L3];
        }
      }
    } else {
      var A4, U4 = this.bytes, P4 = this.bytesPos;
      void 0 === (A4 = U4[P4++]) && o10("Bad block header in flate stream");
      var z2 = A4;
      void 0 === (A4 = U4[P4++]) && o10("Bad block header in flate stream"), z2 |= A4 << 8, void 0 === (A4 = U4[P4++]) && o10("Bad block header in flate stream");
      var H2 = A4;
      void 0 === (A4 = U4[P4++]) && o10("Bad block header in flate stream"), (H2 |= A4 << 8) != (65535 & ~z2) && o10("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
      var x6 = this.bufferLength, T4 = this.ensureBuffer(x6 + z2), j2 = x6 + z2;
      this.bufferLength = j2;
      for (var E4 = x6; E4 < j2; ++E4) {
        if (void 0 === (A4 = U4[P4++])) {
          this.eof = true;
          break;
        }
        T4[E4] = A4;
      }
      this.bytesPos = P4;
    }
  }, n14;
}()) && (r3.exports = i);
var f2 = t2(s7.exports);

// node_modules/@arcgis/core/layers/support/rasterFormats/ImageCanvasDecoder.js
var i2 = class _i {
  constructor(t11) {
    this._canvas = null, this._ctx = null, t11 && (this._canvas = t11.canvas, this._ctx = t11.ctx || t11.canvas && t11.canvas.getContext("2d"));
  }
  decode(n14, s14, r16) {
    if (!n14 || n14.byteLength < 10)
      throw new s2("imagecanvasdecoder: decode", "required a valid encoded data as input.");
    let { width: c11 = 0, height: h10 = 0, format: o10 } = s14;
    const { applyJpegMask: l9 } = s14;
    if (l9 && (!c11 || !h10))
      throw new s2("imagecanvasdecoder: decode", "image width and height are needed to apply jpeg mask directly to canvas");
    return new Promise((t11, d8) => {
      let g7 = null;
      "jpg" === o10 && l9 && (g7 = _i._getMask(n14, { width: c11, height: h10 }));
      const w6 = new Blob([new Uint8Array(n14)], { type: "image/" + o10 == "jpg" ? "jpeg" : o10 }), v6 = URL.createObjectURL(w6), m8 = new Image();
      let _3;
      m8.src = v6, m8.onload = () => {
        if (URL.revokeObjectURL(v6), a3(r16))
          return void d8(c());
        c11 = m8.width, h10 = m8.height, this._canvas && this._ctx ? (this._canvas.width === c11 && this._canvas.height === h10 || (this._canvas.width = c11, this._canvas.height = h10), this._ctx.clearRect(0, 0, c11, h10)) : (this._canvas = document.createElement("canvas"), this._canvas.width = c11, this._canvas.height = h10, this._ctx = this._canvas.getContext("2d")), this._ctx.drawImage(m8, 0, 0);
        const n15 = this._ctx.getImageData(0, 0, c11, h10);
        let i11;
        if (_3 = n15.data, s14.renderOnCanvas) {
          if (g7)
            for (i11 = 0; i11 < g7.length; i11++)
              g7[i11] ? _3[4 * i11 + 3] = 255 : _3[4 * i11 + 3] = 0;
          return this._ctx.putImageData(n15, 0, 0), void t11(null);
        }
        const o11 = c11 * h10, l10 = new Uint8Array(o11), w7 = new Uint8Array(o11), p10 = new Uint8Array(o11);
        if (g7)
          for (i11 = 0; i11 < o11; i11++)
            l10[i11] = _3[4 * i11], w7[i11] = _3[4 * i11 + 1], p10[i11] = _3[4 * i11 + 2];
        else
          for (g7 = new Uint8Array(o11), i11 = 0; i11 < o11; i11++)
            l10[i11] = _3[4 * i11], w7[i11] = _3[4 * i11 + 1], p10[i11] = _3[4 * i11 + 2], g7[i11] = _3[4 * i11 + 3];
        t11({ width: c11, height: h10, pixels: [l10, w7, p10], mask: g7, pixelType: "u8" });
      }, m8.onerror = () => {
        URL.revokeObjectURL(v6), d8("cannot load image");
      };
    });
  }
  static _getMask(t11, e8) {
    let a16 = null;
    try {
      const i11 = new Uint8Array(t11), s14 = Math.ceil(i11.length / 2);
      let r16 = 0;
      const c11 = i11.length - 2;
      for (r16 = s14; r16 < c11 && (255 !== i11[r16] || 217 !== i11[r16 + 1]); r16++)
        ;
      if (r16 += 2, r16 < i11.length - 1) {
        const t12 = new f2(i11.subarray(r16)).getBytes();
        a16 = new Uint8Array(e8.width * e8.height);
        let s15 = 0;
        for (let e9 = 0; e9 < t12.length; e9++)
          for (let n14 = 7; n14 >= 0; n14--)
            a16[s15++] = t12[e9] >> n14 & 1;
      }
    } catch (i11) {
    }
    return a16;
  }
};

// node_modules/@arcgis/core/chunks/Jpg.js
var r4;
var n2;
var o2;
var a5 = { exports: {} };
a5.exports, r4 = a5, n2 = function() {
  var e8 = function() {
    function e9(e10) {
      this.message = "JPEG error: " + e10;
    }
    return e9.prototype = new Error(), e9.prototype.name = "JpegError", e9.constructor = e9, e9;
  }();
  return function() {
    if (!self || !self.Uint8ClampedArray)
      return null;
    var r16 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), n14 = 4017, o10 = 799, a16 = 3406, t11 = 2276, i11 = 1567, s14 = 3784, c11 = 5793, f11 = 2896;
    function l9() {
      this.decodeTransform = null, this.colorTransform = -1;
    }
    function u14(e9, r17) {
      for (var n15, o11, a17 = 0, t12 = [], i12 = 16; i12 > 0 && !e9[i12 - 1]; )
        i12--;
      t12.push({ children: [], index: 0 });
      var s15, c12 = t12[0];
      for (n15 = 0; n15 < i12; n15++) {
        for (o11 = 0; o11 < e9[n15]; o11++) {
          for ((c12 = t12.pop()).children[c12.index] = r17[a17]; c12.index > 0; )
            c12 = t12.pop();
          for (c12.index++, t12.push(c12); t12.length <= n15; )
            t12.push(s15 = { children: [], index: 0 }), c12.children[c12.index] = s15.children, c12 = s15;
          a17++;
        }
        n15 + 1 < i12 && (t12.push(s15 = { children: [], index: 0 }), c12.children[c12.index] = s15.children, c12 = s15);
      }
      return t12[0].children;
    }
    function h10(e9, r17, n15) {
      return 64 * ((e9.blocksPerLine + 1) * r17 + n15);
    }
    function v6(n15, o11, a17, t12, i12, s15, c12, f12, l10) {
      var u15 = a17.mcusPerLine, v7 = a17.progressive, m9 = o11, d9 = 0, b5 = 0;
      function k5() {
        if (b5 > 0)
          return b5--, d9 >> b5 & 1;
        if (255 === (d9 = n15[o11++])) {
          var r17 = n15[o11++];
          if (r17)
            throw new e8("unexpected marker " + (d9 << 8 | r17).toString(16));
        }
        return b5 = 7, d9 >>> 7;
      }
      function g7(r17) {
        for (var n16 = r17; ; ) {
          if ("number" == typeof (n16 = n16[k5()]))
            return n16;
          if ("object" != typeof n16)
            throw new e8("invalid huffman sequence");
        }
      }
      function C6(e9) {
        for (var r17 = 0; e9 > 0; )
          r17 = r17 << 1 | k5(), e9--;
        return r17;
      }
      function w6(e9) {
        if (1 === e9)
          return 1 === k5() ? 1 : -1;
        var r17 = C6(e9);
        return r17 >= 1 << e9 - 1 ? r17 : r17 + (-1 << e9) + 1;
      }
      function x6(e9, n16) {
        var o12 = g7(e9.huffmanTableDC), a18 = 0 === o12 ? 0 : w6(o12);
        e9.blockData[n16] = e9.pred += a18;
        for (var t13 = 1; t13 < 64; ) {
          var i13 = g7(e9.huffmanTableAC), s16 = 15 & i13, c13 = i13 >> 4;
          if (0 !== s16) {
            var f13 = r16[t13 += c13];
            e9.blockData[n16 + f13] = w6(s16), t13++;
          } else {
            if (c13 < 15)
              break;
            t13 += 16;
          }
        }
      }
      function y7(e9, r17) {
        var n16 = g7(e9.huffmanTableDC), o12 = 0 === n16 ? 0 : w6(n16) << l10;
        e9.blockData[r17] = e9.pred += o12;
      }
      function D4(e9, r17) {
        e9.blockData[r17] |= k5() << l10;
      }
      var T4 = 0;
      function P4(e9, n16) {
        if (T4 > 0)
          T4--;
        else
          for (var o12 = s15, a18 = c12; o12 <= a18; ) {
            var t13 = g7(e9.huffmanTableAC), i13 = 15 & t13, f13 = t13 >> 4;
            if (0 !== i13) {
              var u16 = r16[o12 += f13];
              e9.blockData[n16 + u16] = w6(i13) * (1 << l10), o12++;
            } else {
              if (f13 < 15) {
                T4 = C6(f13) + (1 << f13) - 1;
                break;
              }
              o12 += 16;
            }
          }
      }
      var L3, A4 = 0;
      function _3(n16, o12) {
        for (var a18, t13, i13 = s15, f13 = c12, u16 = 0; i13 <= f13; ) {
          var h11 = r16[i13];
          switch (A4) {
            case 0:
              if (u16 = (t13 = g7(n16.huffmanTableAC)) >> 4, 0 == (a18 = 15 & t13))
                u16 < 15 ? (T4 = C6(u16) + (1 << u16), A4 = 4) : (u16 = 16, A4 = 1);
              else {
                if (1 !== a18)
                  throw new e8("invalid ACn encoding");
                L3 = w6(a18), A4 = u16 ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              n16.blockData[o12 + h11] ? n16.blockData[o12 + h11] += k5() << l10 : 0 == --u16 && (A4 = 2 === A4 ? 3 : 0);
              break;
            case 3:
              n16.blockData[o12 + h11] ? n16.blockData[o12 + h11] += k5() << l10 : (n16.blockData[o12 + h11] = L3 << l10, A4 = 0);
              break;
            case 4:
              n16.blockData[o12 + h11] && (n16.blockData[o12 + h11] += k5() << l10);
          }
          i13++;
        }
        4 === A4 && 0 == --T4 && (A4 = 0);
      }
      function U4(e9, r17, n16, o12, a18) {
        var t13 = n16 % u15;
        r17(e9, h10(e9, (n16 / u15 | 0) * e9.v + o12, t13 * e9.h + a18));
      }
      function z2(e9, r17, n16) {
        r17(e9, h10(e9, n16 / e9.blocksPerLine | 0, n16 % e9.blocksPerLine));
      }
      var I5, M6, Y2, q, S4, H2, R4 = t12.length;
      H2 = v7 ? 0 === s15 ? 0 === f12 ? y7 : D4 : 0 === f12 ? P4 : _3 : x6;
      var j2, E4, J, V2, B4 = 0;
      for (E4 = 1 === R4 ? t12[0].blocksPerLine * t12[0].blocksPerColumn : u15 * a17.mcusPerColumn; B4 < E4; ) {
        var N2 = i12 ? Math.min(E4 - B4, i12) : E4;
        for (M6 = 0; M6 < R4; M6++)
          t12[M6].pred = 0;
        if (T4 = 0, 1 === R4)
          for (I5 = t12[0], S4 = 0; S4 < N2; S4++)
            z2(I5, H2, B4), B4++;
        else
          for (S4 = 0; S4 < N2; S4++) {
            for (M6 = 0; M6 < R4; M6++)
              for (J = (I5 = t12[M6]).h, V2 = I5.v, Y2 = 0; Y2 < V2; Y2++)
                for (q = 0; q < J; q++)
                  U4(I5, H2, B4, Y2, q);
            B4++;
          }
        b5 = 0, (j2 = p10(n15, o11)) && j2.invalid && (console.log("decodeScan - unexpected MCU data, next marker is: " + j2.invalid), o11 = j2.offset);
        var G3 = j2 && j2.marker;
        if (!G3 || G3 <= 65280)
          throw new e8("marker was not found");
        if (!(G3 >= 65488 && G3 <= 65495))
          break;
        o11 += 2;
      }
      return (j2 = p10(n15, o11)) && j2.invalid && (console.log("decodeScan - unexpected Scan data, next marker is: " + j2.invalid), o11 = j2.offset), o11 - m9;
    }
    function m8(r17, l10, u15) {
      var h11, v7, m9, d9, p11, b5, k5, g7, C6, w6, x6, y7, D4, T4, P4, L3, A4, _3 = r17.quantizationTable, U4 = r17.blockData;
      if (!_3)
        throw new e8("missing required Quantization Table.");
      for (var z2 = 0; z2 < 64; z2 += 8)
        C6 = U4[l10 + z2], w6 = U4[l10 + z2 + 1], x6 = U4[l10 + z2 + 2], y7 = U4[l10 + z2 + 3], D4 = U4[l10 + z2 + 4], T4 = U4[l10 + z2 + 5], P4 = U4[l10 + z2 + 6], L3 = U4[l10 + z2 + 7], C6 *= _3[z2], 0 != (w6 | x6 | y7 | D4 | T4 | P4 | L3) ? (w6 *= _3[z2 + 1], x6 *= _3[z2 + 2], y7 *= _3[z2 + 3], D4 *= _3[z2 + 4], T4 *= _3[z2 + 5], P4 *= _3[z2 + 6], L3 *= _3[z2 + 7], v7 = (h11 = (h11 = c11 * C6 + 128 >> 8) + (v7 = c11 * D4 + 128 >> 8) + 1 >> 1) - v7, A4 = (m9 = x6) * s14 + (d9 = P4) * i11 + 128 >> 8, m9 = m9 * i11 - d9 * s14 + 128 >> 8, k5 = (p11 = (p11 = f11 * (w6 - L3) + 128 >> 8) + (k5 = T4 << 4) + 1 >> 1) - k5, b5 = (g7 = (g7 = f11 * (w6 + L3) + 128 >> 8) + (b5 = y7 << 4) + 1 >> 1) - b5, d9 = (h11 = h11 + (d9 = A4) + 1 >> 1) - d9, m9 = (v7 = v7 + m9 + 1 >> 1) - m9, A4 = p11 * t11 + g7 * a16 + 2048 >> 12, p11 = p11 * a16 - g7 * t11 + 2048 >> 12, g7 = A4, A4 = b5 * o10 + k5 * n14 + 2048 >> 12, b5 = b5 * n14 - k5 * o10 + 2048 >> 12, k5 = A4, u15[z2] = h11 + g7, u15[z2 + 7] = h11 - g7, u15[z2 + 1] = v7 + k5, u15[z2 + 6] = v7 - k5, u15[z2 + 2] = m9 + b5, u15[z2 + 5] = m9 - b5, u15[z2 + 3] = d9 + p11, u15[z2 + 4] = d9 - p11) : (A4 = c11 * C6 + 512 >> 10, u15[z2] = A4, u15[z2 + 1] = A4, u15[z2 + 2] = A4, u15[z2 + 3] = A4, u15[z2 + 4] = A4, u15[z2 + 5] = A4, u15[z2 + 6] = A4, u15[z2 + 7] = A4);
      for (var I5 = 0; I5 < 8; ++I5)
        C6 = u15[I5], 0 != ((w6 = u15[I5 + 8]) | (x6 = u15[I5 + 16]) | (y7 = u15[I5 + 24]) | (D4 = u15[I5 + 32]) | (T4 = u15[I5 + 40]) | (P4 = u15[I5 + 48]) | (L3 = u15[I5 + 56])) ? (v7 = (h11 = 4112 + ((h11 = c11 * C6 + 2048 >> 12) + (v7 = c11 * D4 + 2048 >> 12) + 1 >> 1)) - v7, A4 = (m9 = x6) * s14 + (d9 = P4) * i11 + 2048 >> 12, m9 = m9 * i11 - d9 * s14 + 2048 >> 12, d9 = A4, k5 = (p11 = (p11 = f11 * (w6 - L3) + 2048 >> 12) + (k5 = T4) + 1 >> 1) - k5, b5 = (g7 = (g7 = f11 * (w6 + L3) + 2048 >> 12) + (b5 = y7) + 1 >> 1) - b5, A4 = p11 * t11 + g7 * a16 + 2048 >> 12, p11 = p11 * a16 - g7 * t11 + 2048 >> 12, g7 = A4, A4 = b5 * o10 + k5 * n14 + 2048 >> 12, b5 = b5 * n14 - k5 * o10 + 2048 >> 12, C6 = (C6 = (h11 = h11 + d9 + 1 >> 1) + g7) < 16 ? 0 : C6 >= 4080 ? 255 : C6 >> 4, w6 = (w6 = (v7 = v7 + m9 + 1 >> 1) + (k5 = A4)) < 16 ? 0 : w6 >= 4080 ? 255 : w6 >> 4, x6 = (x6 = (m9 = v7 - m9) + b5) < 16 ? 0 : x6 >= 4080 ? 255 : x6 >> 4, y7 = (y7 = (d9 = h11 - d9) + p11) < 16 ? 0 : y7 >= 4080 ? 255 : y7 >> 4, D4 = (D4 = d9 - p11) < 16 ? 0 : D4 >= 4080 ? 255 : D4 >> 4, T4 = (T4 = m9 - b5) < 16 ? 0 : T4 >= 4080 ? 255 : T4 >> 4, P4 = (P4 = v7 - k5) < 16 ? 0 : P4 >= 4080 ? 255 : P4 >> 4, L3 = (L3 = h11 - g7) < 16 ? 0 : L3 >= 4080 ? 255 : L3 >> 4, U4[l10 + I5] = C6, U4[l10 + I5 + 8] = w6, U4[l10 + I5 + 16] = x6, U4[l10 + I5 + 24] = y7, U4[l10 + I5 + 32] = D4, U4[l10 + I5 + 40] = T4, U4[l10 + I5 + 48] = P4, U4[l10 + I5 + 56] = L3) : (A4 = (A4 = c11 * C6 + 8192 >> 14) < -2040 ? 0 : A4 >= 2024 ? 255 : A4 + 2056 >> 4, U4[l10 + I5] = A4, U4[l10 + I5 + 8] = A4, U4[l10 + I5 + 16] = A4, U4[l10 + I5 + 24] = A4, U4[l10 + I5 + 32] = A4, U4[l10 + I5 + 40] = A4, U4[l10 + I5 + 48] = A4, U4[l10 + I5 + 56] = A4);
    }
    function d8(e9, r17) {
      for (var n15 = r17.blocksPerLine, o11 = r17.blocksPerColumn, a17 = new Int16Array(64), t12 = 0; t12 < o11; t12++)
        for (var i12 = 0; i12 < n15; i12++)
          m8(r17, h10(r17, t12, i12), a17);
      return r17.blockData;
    }
    function p10(e9, r17, n15) {
      function o11(r18) {
        return e9[r18] << 8 | e9[r18 + 1];
      }
      var a17 = e9.length - 1, t12 = n15 < r17 ? n15 : r17;
      if (r17 >= a17)
        return null;
      var i12 = o11(r17);
      if (i12 >= 65472 && i12 <= 65534)
        return { invalid: null, marker: i12, offset: r17 };
      for (var s15 = o11(t12); !(s15 >= 65472 && s15 <= 65534); ) {
        if (++t12 >= a17)
          return null;
        s15 = o11(t12);
      }
      return { invalid: i12.toString(16), marker: s15, offset: t12 };
    }
    return l9.prototype = { parse: function(n15) {
      function o11() {
        var e9 = n15[c12] << 8 | n15[c12 + 1];
        return c12 += 2, e9;
      }
      function a17() {
        var e9 = o11(), r17 = c12 + e9 - 2, a18 = p10(n15, r17, c12);
        a18 && a18.invalid && (console.log("readDataBlock - incorrect length, next marker is: " + a18.invalid), r17 = a18.offset);
        var t13 = n15.subarray(c12, r17);
        return c12 += t13.length, t13;
      }
      function t12(e9) {
        for (var r17 = Math.ceil(e9.samplesPerLine / 8 / e9.maxH), n16 = Math.ceil(e9.scanLines / 8 / e9.maxV), o12 = 0; o12 < e9.components.length; o12++) {
          R4 = e9.components[o12];
          var a18 = Math.ceil(Math.ceil(e9.samplesPerLine / 8) * R4.h / e9.maxH), t13 = Math.ceil(Math.ceil(e9.scanLines / 8) * R4.v / e9.maxV), i13 = r17 * R4.h, s16 = n16 * R4.v * 64 * (i13 + 1);
          R4.blockData = new Int16Array(s16), R4.blocksPerLine = a18, R4.blocksPerColumn = t13;
        }
        e9.mcusPerLine = r17, e9.mcusPerColumn = n16;
      }
      var i12, s15, c12 = 0, f12 = null, l10 = null, h11 = [], m9 = [], b5 = [], k5 = o11();
      if (65496 !== k5)
        throw new e8("SOI not found");
      for (k5 = o11(); 65497 !== k5; ) {
        var g7, C6, w6;
        switch (k5) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            var x6 = a17();
            65504 === k5 && 74 === x6[0] && 70 === x6[1] && 73 === x6[2] && 70 === x6[3] && 0 === x6[4] && (f12 = { version: { major: x6[5], minor: x6[6] }, densityUnits: x6[7], xDensity: x6[8] << 8 | x6[9], yDensity: x6[10] << 8 | x6[11], thumbWidth: x6[12], thumbHeight: x6[13], thumbData: x6.subarray(14, 14 + 3 * x6[12] * x6[13]) }), 65518 === k5 && 65 === x6[0] && 100 === x6[1] && 111 === x6[2] && 98 === x6[3] && 101 === x6[4] && (l10 = { version: x6[5] << 8 | x6[6], flags0: x6[7] << 8 | x6[8], flags1: x6[9] << 8 | x6[10], transformCode: x6[11] });
            break;
          case 65499:
            for (var y7 = o11() + c12 - 2; c12 < y7; ) {
              var D4 = n15[c12++], T4 = new Uint16Array(64);
              if (D4 >> 4 == 0)
                for (C6 = 0; C6 < 64; C6++)
                  T4[r16[C6]] = n15[c12++];
              else {
                if (D4 >> 4 != 1)
                  throw new e8("DQT - invalid table spec");
                for (C6 = 0; C6 < 64; C6++)
                  T4[r16[C6]] = o11();
              }
              h11[15 & D4] = T4;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (i12)
              throw new e8("Only single frame JPEGs supported");
            o11(), (i12 = {}).extended = 65473 === k5, i12.progressive = 65474 === k5, i12.precision = n15[c12++], i12.scanLines = o11(), i12.samplesPerLine = o11(), i12.components = [], i12.componentIds = {};
            var P4, L3 = n15[c12++], A4 = 0, _3 = 0;
            for (g7 = 0; g7 < L3; g7++) {
              P4 = n15[c12];
              var U4 = n15[c12 + 1] >> 4, z2 = 15 & n15[c12 + 1];
              A4 < U4 && (A4 = U4), _3 < z2 && (_3 = z2);
              var I5 = n15[c12 + 2];
              w6 = i12.components.push({ h: U4, v: z2, quantizationId: I5, quantizationTable: null }), i12.componentIds[P4] = w6 - 1, c12 += 3;
            }
            i12.maxH = A4, i12.maxV = _3, t12(i12);
            break;
          case 65476:
            var M6 = o11();
            for (g7 = 2; g7 < M6; ) {
              var Y2 = n15[c12++], q = new Uint8Array(16), S4 = 0;
              for (C6 = 0; C6 < 16; C6++, c12++)
                S4 += q[C6] = n15[c12];
              var H2 = new Uint8Array(S4);
              for (C6 = 0; C6 < S4; C6++, c12++)
                H2[C6] = n15[c12];
              g7 += 17 + S4, (Y2 >> 4 == 0 ? b5 : m9)[15 & Y2] = u14(q, H2);
            }
            break;
          case 65501:
            o11(), s15 = o11();
            break;
          case 65498:
            o11();
            var R4, j2 = n15[c12++], E4 = [];
            for (g7 = 0; g7 < j2; g7++) {
              var J = i12.componentIds[n15[c12++]];
              R4 = i12.components[J];
              var V2 = n15[c12++];
              R4.huffmanTableDC = b5[V2 >> 4], R4.huffmanTableAC = m9[15 & V2], E4.push(R4);
            }
            var B4 = n15[c12++], N2 = n15[c12++], G3 = n15[c12++], O3 = v6(n15, c12, i12, E4, s15, B4, N2, G3 >> 4, 15 & G3);
            c12 += O3;
            break;
          case 65535:
            255 !== n15[c12] && c12--;
            break;
          default:
            if (255 === n15[c12 - 3] && n15[c12 - 2] >= 192 && n15[c12 - 2] <= 254) {
              c12 -= 3;
              break;
            }
            throw new e8("unknown marker " + k5.toString(16));
        }
        k5 = o11();
      }
      for (this.width = i12.samplesPerLine, this.height = i12.scanLines, this.jfif = f12, this.eof = c12, this.adobe = l10, this.components = [], g7 = 0; g7 < i12.components.length; g7++) {
        var Q = h11[(R4 = i12.components[g7]).quantizationId];
        Q && (R4.quantizationTable = Q), this.components.push({ output: d8(i12, R4), scaleX: R4.h / i12.maxH, scaleY: R4.v / i12.maxV, blocksPerLine: R4.blocksPerLine, blocksPerColumn: R4.blocksPerColumn });
      }
      this.numComponents = this.components.length;
    }, _getLinearizedBlockData: function(e9, r17) {
      var n15, o11, a17, t12, i12, s15, c12, f12, l10, u15, h11, v7 = this.width / e9, m9 = this.height / r17, d9 = 0, p11 = this.components.length, b5 = e9 * r17 * p11, k5 = new Uint8ClampedArray(b5), g7 = new Uint32Array(e9), C6 = 4294967288;
      for (c12 = 0; c12 < p11; c12++) {
        for (o11 = (n15 = this.components[c12]).scaleX * v7, a17 = n15.scaleY * m9, d9 = c12, h11 = n15.output, t12 = n15.blocksPerLine + 1 << 3, i12 = 0; i12 < e9; i12++)
          f12 = 0 | i12 * o11, g7[i12] = (f12 & C6) << 3 | 7 & f12;
        for (s15 = 0; s15 < r17; s15++)
          for (u15 = t12 * ((f12 = 0 | s15 * a17) & C6) | (7 & f12) << 3, i12 = 0; i12 < e9; i12++)
            k5[d9] = h11[u15 + g7[i12]], d9 += p11;
      }
      var w6 = this.decodeTransform;
      if (w6)
        for (c12 = 0; c12 < b5; )
          for (f12 = 0, l10 = 0; f12 < p11; f12++, c12++, l10 += 2)
            k5[c12] = (k5[c12] * w6[l10] >> 8) + w6[l10 + 1];
      return k5;
    }, _isColorConversionNeeded: function() {
      return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this.colorTransform : 1 === this.colorTransform;
    }, _convertYccToRgb: function(e9) {
      for (var r17, n15, o11, a17 = 0, t12 = e9.length; a17 < t12; a17 += 3)
        r17 = e9[a17], n15 = e9[a17 + 1], o11 = e9[a17 + 2], e9[a17] = r17 - 179.456 + 1.402 * o11, e9[a17 + 1] = r17 + 135.459 - 0.344 * n15 - 0.714 * o11, e9[a17 + 2] = r17 - 226.816 + 1.772 * n15;
      return e9;
    }, _convertYcckToRgb: function(e9) {
      for (var r17, n15, o11, a17, t12 = 0, i12 = 0, s15 = e9.length; i12 < s15; i12 += 4)
        r17 = e9[i12], n15 = e9[i12 + 1], o11 = e9[i12 + 2], a17 = e9[i12 + 3], e9[t12++] = n15 * (-660635669420364e-19 * n15 + 437130475926232e-18 * o11 - 54080610064599e-18 * r17 + 48449797120281e-17 * a17 - 0.154362151871126) - 122.67195406894 + o11 * (-957964378445773e-18 * o11 + 817076911346625e-18 * r17 - 0.00477271405408747 * a17 + 1.53380253221734) + r17 * (961250184130688e-18 * r17 - 0.00266257332283933 * a17 + 0.48357088451265) + a17 * (-336197177618394e-18 * a17 + 0.484791561490776), e9[t12++] = 107.268039397724 + n15 * (219927104525741e-19 * n15 - 640992018297945e-18 * o11 + 659397001245577e-18 * r17 + 426105652938837e-18 * a17 - 0.176491792462875) + o11 * (-778269941513683e-18 * o11 + 0.00130872261408275 * r17 + 770482631801132e-18 * a17 - 0.151051492775562) + r17 * (0.00126935368114843 * r17 - 0.00265090189010898 * a17 + 0.25802910206845) + a17 * (-318913117588328e-18 * a17 - 0.213742400323665), e9[t12++] = n15 * (-570115196973677e-18 * n15 - 263409051004589e-19 * o11 + 0.0020741088115012 * r17 - 0.00288260236853442 * a17 + 0.814272968359295) - 20.810012546947 + o11 * (-153496057440975e-19 * o11 - 132689043961446e-18 * r17 + 560833691242812e-18 * a17 - 0.195152027534049) + r17 * (0.00174418132927582 * r17 - 0.00255243321439347 * a17 + 0.116935020465145) + a17 * (-343531996510555e-18 * a17 + 0.24165260232407);
      return e9;
    }, _convertYcckToCmyk: function(e9) {
      for (var r17, n15, o11, a17 = 0, t12 = e9.length; a17 < t12; a17 += 4)
        r17 = e9[a17], n15 = e9[a17 + 1], o11 = e9[a17 + 2], e9[a17] = 434.456 - r17 - 1.402 * o11, e9[a17 + 1] = 119.541 - r17 + 0.344 * n15 + 0.714 * o11, e9[a17 + 2] = 481.816 - r17 - 1.772 * n15;
      return e9;
    }, _convertCmykToRgb: function(e9) {
      for (var r17, n15, o11, a17, t12 = 0, i12 = 1 / 255, s15 = 0, c12 = e9.length; s15 < c12; s15 += 4)
        r17 = e9[s15] * i12, n15 = e9[s15 + 1] * i12, o11 = e9[s15 + 2] * i12, a17 = e9[s15 + 3] * i12, e9[t12++] = 255 + r17 * (-4.387332384609988 * r17 + 54.48615194189176 * n15 + 18.82290502165302 * o11 + 212.25662451639585 * a17 - 285.2331026137004) + n15 * (1.7149763477362134 * n15 - 5.6096736904047315 * o11 - 17.873870861415444 * a17 - 5.497006427196366) + o11 * (-2.5217340131683033 * o11 - 21.248923337353073 * a17 + 17.5119270841813) - a17 * (21.86122147463605 * a17 + 189.48180835922747), e9[t12++] = 255 + r17 * (8.841041422036149 * r17 + 60.118027045597366 * n15 + 6.871425592049007 * o11 + 31.159100130055922 * a17 - 79.2970844816548) + n15 * (-15.310361306967817 * n15 + 17.575251261109482 * o11 + 131.35250912493976 * a17 - 190.9453302588951) + o11 * (4.444339102852739 * o11 + 9.8632861493405 * a17 - 24.86741582555878) - a17 * (20.737325471181034 * a17 + 187.80453709719578), e9[t12++] = 255 + r17 * (0.8842522430003296 * r17 + 8.078677503112928 * n15 + 30.89978309703729 * o11 - 0.23883238689178934 * a17 - 14.183576799673286) + n15 * (10.49593273432072 * n15 + 63.02378494754052 * o11 + 50.606957656360734 * a17 - 112.23884253719248) + o11 * (0.03296041114873217 * o11 + 115.60384449646641 * a17 - 193.58209356861505) - a17 * (22.33816807309886 * a17 + 180.12613974708367);
      return e9;
    }, getData: function(r17, n15, o11) {
      if (this.numComponents > 4)
        throw new e8("Unsupported color mode");
      var a17 = this._getLinearizedBlockData(r17, n15);
      if (1 === this.numComponents && o11) {
        for (var t12 = a17.length, i12 = new Uint8ClampedArray(3 * t12), s15 = 0, c12 = 0; c12 < t12; c12++) {
          var f12 = a17[c12];
          i12[s15++] = f12, i12[s15++] = f12, i12[s15++] = f12;
        }
        return i12;
      }
      if (3 === this.numComponents && this._isColorConversionNeeded())
        return this._convertYccToRgb(a17);
      if (4 === this.numComponents) {
        if (this._isColorConversionNeeded())
          return o11 ? this._convertYcckToRgb(a17) : this._convertYcckToCmyk(a17);
        if (o11)
          return this._convertCmykToRgb(a17);
      }
      return a17;
    } }, l9;
  }();
}, void 0 !== (o2 = n2()) && (r4.exports = o2);
var t4 = t2(a5.exports);

// node_modules/@arcgis/core/layers/support/rasterFormats/JpgPlus.js
var r5 = class {
  static decode(r16, n14 = false) {
    const s14 = new Uint8Array(r16), o10 = new t4();
    o10.parse(s14);
    const { width: a16, height: i11, numComponents: f11, eof: h10 } = o10, l9 = o10.getData(a16, i11, true), c11 = a16 * i11;
    let u14, g7 = null, p10 = 0, w6 = 0, m8 = 0;
    if (!n14 && h10 < s14.length - 1)
      try {
        const t11 = new f2(s14.subarray(h10)).getBytes();
        g7 = new Uint8Array(c11);
        let r17 = 0;
        for (p10 = 0; p10 < t11.length; p10++)
          for (m8 = 7; m8 >= 0; m8--)
            g7[r17++] = t11[p10] >> m8 & 1;
      } catch {
      }
    if (1 === f11 && l9.length === a16 * i11) {
      const t11 = new Uint8Array(l9.buffer);
      u14 = [t11, t11, t11];
    } else {
      for (u14 = [], p10 = 0; p10 < 3; p10++)
        u14.push(new Uint8Array(c11));
      for (m8 = 0, w6 = 0; w6 < c11; w6++)
        for (p10 = 0; p10 < 3; p10++)
          u14[p10][w6] = l9[m8++];
    }
    return { width: a16, height: i11, pixels: u14, mask: g7 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/Lerc.js
var t5 = [{ pixelType: "S8", size: 1, ctor: Int8Array, range: [-128, 127] }, { pixelType: "U8", size: 1, ctor: Uint8Array, range: [0, 255] }, { pixelType: "S16", size: 2, ctor: Int16Array, range: [-32768, 32767] }, { pixelType: "U16", size: 2, ctor: Uint16Array, range: [0, 65536] }, { pixelType: "S32", size: 4, ctor: Int32Array, range: [-2147483648, 2147483647] }, { pixelType: "U32", size: 4, ctor: Uint32Array, range: [0, 4294967296] }, { pixelType: "F32", size: 4, ctor: Float32Array, range: [-34027999387901484e22, 34027999387901484e22] }, { pixelType: "F64", size: 8, ctor: Float64Array, range: [-17976931348623157e292, 17976931348623157e292] }];
var n3 = null;
var r6 = false;
function a6() {
  return n3 || (n3 = import("./lerc-wasm-MVNP2YVB.js").then((e8) => e8.l).then(({ default: t11 }) => t11({ locateFile: (t12) => a4(`esri/layers/support/rasterFormats/${t12}`) })).then((e8) => {
    u3(e8), r6 = true;
  }), n3);
}
var l3 = { getBlobInfo: null, decode: null };
function s8(e8) {
  return 16 + (e8 >> 3 << 3);
}
function i3(e8, t11, n14) {
  n14.set(e8.slice(t11, t11 + n14.length));
}
function u3(e8) {
  const { _malloc: n14, _free: r16, _lerc_getBlobInfo: a16, _lerc_getDataRanges: o10, _lerc_decode_4D: u14, asm: f11 } = e8;
  let c11;
  const h10 = Object.values(f11).find((t11) => t11 && "buffer" in t11 && t11.buffer === e8.HEAPU8.buffer), y7 = (e9) => {
    const t11 = e9.map((e10) => s8(e10)), r17 = t11.reduce((e10, t12) => e10 + t12), a17 = n14(r17);
    c11 = new Uint8Array(h10.buffer);
    let o11 = t11[0];
    t11[0] = a17;
    for (let n15 = 1; n15 < t11.length; n15++) {
      const e10 = t11[n15];
      t11[n15] = t11[n15 - 1] + o11, o11 = e10;
    }
    return t11;
  };
  l3.getBlobInfo = (e9) => {
    const t11 = 12, n15 = 3, l9 = new Uint8Array(4 * t11), s14 = new Uint8Array(8 * n15), [u15, f12, p10] = y7([e9.length, l9.length, s14.length]);
    c11.set(e9, u15), c11.set(l9, f12), c11.set(s14, p10);
    let g7 = a16(u15, e9.length, f12, p10, t11, n15);
    if (g7)
      throw r16(u15), new Error(`lerc-getBlobInfo: error code is ${g7}`);
    c11 = new Uint8Array(h10.buffer), i3(c11, f12, l9), i3(c11, p10, s14);
    const d8 = new Uint32Array(l9.buffer), b5 = new Float64Array(s14.buffer), [w6, A4, , m8, U4, x6, C6, V2, T4, D4, z2] = d8, F2 = { version: w6, depthCount: D4, width: m8, height: U4, validPixelCount: C6, bandCount: x6, blobSize: V2, maskCount: T4, dataType: A4, minValue: b5[0], maxValue: b5[1], maxZerror: b5[2], statistics: [], bandCountWithNoData: z2 };
    if (z2)
      return F2;
    if (1 === D4 && 1 === x6)
      return r16(u15), F2.statistics.push({ minValue: b5[0], maxValue: b5[1] }), F2;
    const I5 = D4 * x6 * 8, _3 = new Uint8Array(I5), k5 = new Uint8Array(I5);
    let B4 = u15, S4 = 0, v6 = 0, E4 = false;
    if (c11.byteLength < u15 + 2 * I5 ? (r16(u15), E4 = true, [B4, S4, v6] = y7([e9.length, I5, I5]), c11.set(e9, B4)) : [S4, v6] = y7([I5, I5]), c11.set(_3, S4), c11.set(k5, v6), g7 = o10(B4, e9.length, D4, x6, S4, v6), g7)
      throw r16(B4), E4 || r16(S4), new Error(`lerc-getDataRanges: error code is ${g7}`);
    c11 = new Uint8Array(h10.buffer), i3(c11, S4, _3), i3(c11, v6, k5);
    const O3 = new Float64Array(_3.buffer), $ = new Float64Array(k5.buffer), j2 = F2.statistics;
    for (let r17 = 0; r17 < x6; r17++)
      if (D4 > 1) {
        const e10 = O3.slice(r17 * D4, (r17 + 1) * D4), t12 = $.slice(r17 * D4, (r17 + 1) * D4), n16 = Math.min.apply(null, e10), a17 = Math.max.apply(null, t12);
        j2.push({ minValue: n16, maxValue: a17, depthStats: { minValues: e10, maxValues: t12 } });
      } else
        j2.push({ minValue: O3[r17], maxValue: $[r17] });
    return r16(B4), E4 || r16(S4), F2;
  }, l3.decode = (e9, n15) => {
    const { maskCount: a17, depthCount: o11, bandCount: l9, width: s14, height: f12, dataType: p10, bandCountWithNoData: g7 } = n15, d8 = t5[p10], b5 = s14 * f12, w6 = new Uint8Array(b5 * l9), A4 = b5 * o11 * l9 * d8.size, m8 = new Uint8Array(A4), U4 = new Uint8Array(l9), x6 = new Uint8Array(8 * l9), [C6, V2, T4, D4, z2] = y7([e9.length, w6.length, m8.length, U4.length, x6.length]);
    c11.set(e9, C6), c11.set(w6, V2), c11.set(m8, T4), c11.set(U4, D4), c11.set(x6, z2);
    const F2 = u14(C6, e9.length, a17, V2, o11, s14, f12, l9, p10, T4, D4, z2);
    if (F2)
      throw r16(C6), new Error(`lerc-decode: error code is ${F2}`);
    c11 = new Uint8Array(h10.buffer), i3(c11, T4, m8), i3(c11, V2, w6);
    let I5 = null;
    if (g7) {
      i3(c11, D4, U4), i3(c11, z2, x6), I5 = [];
      const e10 = new Float64Array(x6.buffer);
      for (let t11 = 0; t11 < U4.length; t11++)
        I5.push(U4[t11] ? e10[t11] : null);
    }
    return r16(C6), { data: m8, maskData: w6, noDataValues: I5 };
  };
}
function f3(e8, t11, n14, r16, a16) {
  if (n14 < 2)
    return e8;
  const o10 = new r16(t11 * n14);
  if (a16)
    for (let l9 = 0, s14 = 0; l9 < t11; l9++)
      for (let r17 = 0, a17 = l9; r17 < n14; r17++, a17 += t11)
        o10[a17] = e8[s14++];
  else
    for (let l9 = 0, s14 = 0; l9 < t11; l9++)
      for (let r17 = 0, a17 = l9; r17 < n14; r17++, a17 += t11)
        o10[s14++] = e8[a17];
  return o10;
}
function c3(e8, n14 = {}) {
  const r16 = n14.inputOffset ?? 0, a16 = e8 instanceof Uint8Array ? e8.subarray(r16) : new Uint8Array(e8, r16), o10 = l3.getBlobInfo(a16), { data: s14, maskData: i11, noDataValues: u14 } = l3.decode(a16, o10), { width: c11, height: h10, bandCount: y7, depthCount: p10, dataType: g7, maskCount: d8, statistics: b5 } = o10, w6 = t5[g7], A4 = new w6.ctor(s14.buffer), m8 = [], U4 = [], x6 = c11 * h10, C6 = x6 * p10;
  for (let t11 = 0; t11 < y7; t11++) {
    const e9 = A4.subarray(t11 * C6, (t11 + 1) * C6);
    if (n14.returnInterleaved)
      m8.push(e9);
    else {
      const t12 = f3(e9, x6, p10, w6.ctor, true);
      m8.push(t12);
    }
    U4.push(i11.subarray(t11 * C6, (t11 + 1) * C6));
  }
  const V2 = 0 === d8 ? null : 1 === d8 ? U4[0] : new Uint8Array(x6);
  if (d8 > 1) {
    V2.set(U4[0]);
    for (let e9 = 1; e9 < U4.length; e9++) {
      const t11 = U4[e9];
      for (let e10 = 0; e10 < x6; e10++)
        V2[e10] = V2[e10] & t11[e10];
    }
  }
  const { noDataValue: T4 } = n14, D4 = null != T4 && w6.range[0] <= T4 && w6.range[1] >= T4;
  if (d8 > 0 && D4)
    for (let t11 = 0; t11 < y7; t11++) {
      const e9 = m8[t11], n15 = U4[t11] || V2;
      for (let t12 = 0; t12 < x6; t12++)
        0 === n15[t12] && (e9[t12] = T4);
    }
  const z2 = d8 === y7 && y7 > 1 ? U4 : null, { pixelType: F2 } = w6;
  return { width: c11, height: h10, bandCount: y7, pixelType: F2, depthCount: p10, statistics: b5, pixels: m8, mask: V2, bandMasks: z2, noDataValues: u14 };
}

// node_modules/@arcgis/core/layers/support/rasterFormats/Lzw.js
function e4(e8, n14, t11, r16 = true) {
  if (n14 % 4 != 0 || t11 % 4 != 0) {
    const i11 = new ArrayBuffer(4 * Math.ceil(t11 / 4)), o10 = new Uint8Array(i11), l9 = new Uint8Array(e8, n14, t11);
    if (r16)
      for (let e9 = 0; e9 < o10.length; e9 += 4)
        o10[e9] = l9[e9 + 3], o10[e9 + 1] = l9[e9 + 2], o10[e9 + 2] = l9[e9 + 1], o10[e9 + 3] = l9[e9];
    else
      o10.set(l9);
    return new Uint32Array(o10.buffer);
  }
  if (r16) {
    const r17 = new Uint8Array(e8, n14, t11), i11 = new Uint8Array(r17.length);
    for (let e9 = 0; e9 < i11.length; e9 += 4)
      i11[e9] = r17[e9 + 3], i11[e9 + 1] = r17[e9 + 2], i11[e9 + 2] = r17[e9 + 1], i11[e9 + 3] = r17[e9];
    return new Uint32Array(i11.buffer);
  }
  return new Uint32Array(e8, n14, t11 / 4);
}
function n4() {
  const e8 = [];
  for (let n14 = 0; n14 <= 257; n14++)
    e8[n14] = [n14];
  return e8;
}
function t6(e8, n14) {
  for (let t11 = 0; t11 < n14.length; t11++)
    e8.push(n14[t11]);
}
var r7 = /* @__PURE__ */ new Set();
function i4(i11, o10, l9, f11 = true) {
  const s14 = e4(i11, o10, l9, f11);
  let a16 = 9, c11 = n4(), u14 = 32, h10 = c11.length, d8 = [], w6 = 1, g7 = s14[0], y7 = 0;
  const A4 = s14.length, U4 = 8 * (4 * A4 - l9), p10 = [];
  for (; null != g7; ) {
    if (u14 >= a16)
      u14 -= a16, y7 = g7 >>> 32 - a16, g7 <<= a16;
    else {
      y7 = g7 >>> 32 - u14, g7 = s14[w6++];
      const e9 = a16 - u14;
      u14 = 32 - e9, y7 = (y7 << e9) + (g7 >>> u14), g7 <<= e9;
    }
    if (257 === y7)
      break;
    if (256 === y7) {
      a16 = 9, c11 = n4(), h10 = c11.length, d8 = [];
      continue;
    }
    const e8 = c11[y7];
    if (null == e8) {
      if (y7 > c11.length)
        throw new Error("data integrity issue: code does not exist on code page");
      d8.push(d8[0]), c11[h10++] = d8.slice(), t6(p10, d8);
    } else
      t6(p10, e8), d8.push(e8[0]), d8.length > 1 && (c11[h10++] = d8.slice()), d8 = e8.slice();
    if (r7.has(h10) && a16++, 0 === u14 && (g7 = s14[w6++], u14 = 32), w6 > A4 || w6 === A4 && u14 <= U4)
      break;
  }
  return new Uint8Array(p10);
}
r7.add(511), r7.add(1023), r7.add(2047), r7.add(4095), r7.add(8191);

// node_modules/@arcgis/core/layers/support/rasterFormats/Raw.js
var e5 = (e8, r16) => {
  const a16 = r16.width * r16.height, n14 = r16.pixelType;
  return Math.floor(e8.byteLength / (a16 * t7(n14)));
};
var t7 = (e8) => {
  let t11 = 1;
  switch (e8) {
    case Uint8Array:
    case Int8Array:
      t11 = 1;
      break;
    case Uint16Array:
    case Int16Array:
      t11 = 2;
      break;
    case Uint32Array:
    case Int32Array:
    case Float32Array:
      t11 = 4;
      break;
    case Float64Array:
      t11 = 8;
  }
  return t11;
};
var r8 = (e8, t11) => {
  if (8 * e8.byteLength < t11)
    return null;
  const r16 = new Uint8Array(e8, 0, Math.ceil(t11 / 8)), a16 = new Uint8Array(t11);
  let n14 = 0, s14 = 0, l9 = 0, i11 = 0;
  for (l9 = 0; l9 < r16.length - 1; l9++)
    for (s14 = r16[l9], i11 = 7; i11 >= 0; i11--)
      a16[n14++] = s14 >> i11 & 1;
  for (i11 = 7; n14 < t11 - 1; )
    s14 = r16[r16.length - 1], a16[n14++] = s14 >> i11 & 1, i11--;
  return a16;
};
var a7 = class {
  static decode(a16, n14) {
    const s14 = n14.pixelType, l9 = [], i11 = n14.width * n14.height, h10 = e5(a16, n14), { bandIds: c11, format: y7 } = n14, o10 = c11 && c11.length || e5(a16, n14), b5 = a16.byteLength - a16.byteLength % (i11 * t7(s14)), f11 = new s14(a16, 0, i11 * h10);
    let u14, g7, A4, p10, d8 = null;
    if ("bip" === y7)
      for (u14 = 0; u14 < o10; u14++) {
        for (A4 = new s14(i11), p10 = c11 ? c11[u14] : u14, g7 = 0; g7 < i11; g7++)
          A4[g7] = f11[g7 * h10 + p10];
        l9.push(A4);
      }
    else if ("bsq" === y7)
      for (u14 = 0; u14 < o10; u14++)
        p10 = c11 ? c11[u14] : u14, l9.push(f11.subarray(p10 * i11, (p10 + 1) * i11));
    return b5 < a16.byteLength - 1 && (d8 = r8(a16.slice(b5), i11)), { pixels: l9, mask: d8 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/byteStreamUtils.js
function r9(r16, t11) {
  let n14 = 0, o10 = "", e8 = 0, f11 = 0;
  const c11 = r16.length;
  for (; n14 < c11; )
    f11 = r16[n14++], e8 = f11 >> 4, e8 < 8 ? e8 = 1 : 15 === e8 ? (e8 = 4, f11 = (7 & f11) << 18 | (63 & r16[n14++]) << 12 | (63 & r16[n14++]) << 6 | 63 & r16[n14++]) : 14 === e8 ? (e8 = 3, f11 = (15 & f11) << 12 | (63 & r16[n14++]) << 6 | 63 & r16[n14++]) : (e8 = 2, f11 = (31 & f11) << 6 | 63 & r16[n14++]), (0 !== f11 || t11) && (o10 += String.fromCharCode(f11));
  return o10;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffTags.js
var e6 = (() => {
  const e8 = [];
  return e8[254] = "NEWSUBFILETYPE", e8[255] = "SUBFILETYPE", e8[256] = "IMAGEWIDTH", e8[257] = "IMAGELENGTH", e8[258] = "BITSPERSAMPLE", e8[259] = "COMPRESSION", e8[262] = "PHOTOMETRICINTERPRETATION", e8[263] = "THRESHHOLDING", e8[264] = "CELLWIDTH", e8[265] = "CELLLENGTH", e8[266] = "FILLORDER", e8[269] = "DOCUMENTNAME", e8[270] = "IMAGEDESCRIPTION", e8[271] = "MAKE", e8[272] = "MODEL", e8[273] = "STRIPOFFSETS", e8[274] = "ORIENTATION", e8[277] = "SAMPLESPERPIXEL", e8[278] = "ROWSPERSTRIP", e8[279] = "STRIPBYTECOUNTS", e8[280] = "MINSAMPLEVALUE", e8[281] = "MAXSAMPLEVALUE", e8[282] = "XRESOLUTION", e8[283] = "YRESOLUTION", e8[284] = "PLANARCONFIGURATION", e8[285] = "PAGENAME", e8[286] = "XPOSITION", e8[287] = "YPOSITION", e8[288] = "FREEOFFSETS", e8[289] = "FREEBYTECOUNTS", e8[290] = "GRAYRESPONSEUNIT", e8[291] = "GRAYRESPONSECURVE", e8[292] = "T4OPTIONS", e8[293] = "T6OPTIONS", e8[296] = "RESOLUTIONUNIT", e8[297] = "PAGENUMBER", e8[300] = "COLORRESPONSEUNIT", e8[301] = "TRANSFERFUNCTION", e8[305] = "SOFTWARE", e8[306] = "DATETIME", e8[315] = "ARTIST", e8[316] = "HOSTCOMPUTER", e8[317] = "PREDICTOR", e8[318] = "WHITEPOINT", e8[319] = "PRIMARYCHROMATICITIES", e8[320] = "COLORMAP", e8[321] = "HALFTONEHINTS", e8[322] = "TILEWIDTH", e8[323] = "TILELENGTH", e8[324] = "TILEOFFSETS", e8[325] = "TILEBYTECOUNTS", e8[326] = "BADFAXLINES", e8[327] = "CLEANFAXDATA", e8[328] = "CONSECUTIVEBADFAXLINES", e8[330] = "SUBIFD", e8[332] = "INKSET", e8[333] = "INKNAMES", e8[334] = "NUMBEROFINKS", e8[336] = "DOTRANGE", e8[337] = "TARGETPRINTER", e8[338] = "EXTRASAMPLES", e8[339] = "SAMPLEFORMAT", e8[340] = "SMINSAMPLEVALUE", e8[341] = "SMAXSAMPLEVALUE", e8[342] = "TRANSFERRANGE", e8[347] = "JPEGTABLES", e8[512] = "JPEGPROC", e8[513] = "JPEGIFOFFSET", e8[514] = "JPEGIFBYTECOUNT", e8[515] = "JPEGRESTARTINTERVAL", e8[517] = "JPEGLOSSLESSPREDICTORS", e8[518] = "JPEGPOINTTRANSFORM", e8[519] = "JPEGQTABLES", e8[520] = "JPEGDCTABLES", e8[521] = "JPEGACTABLES", e8[529] = "YCBCRCOEFFICIENTS", e8[530] = "YCBCRSUBSAMPLING", e8[531] = "YCBCRPOSITIONING", e8[532] = "REFERENCEBLACKWHITE", e8[700] = "XMP", e8[33550] = "GEOPIXELSCALE", e8[33922] = "GEOTIEPOINTS", e8[33432] = "COPYRIGHT", e8[42112] = "GDAL_METADATA", e8[42113] = "GDAL_NODATA", e8[50844] = "RPCCOEFFICIENT", e8[34264] = "GEOTRANSMATRIX", e8[34735] = "GEOKEYDIRECTORY", e8[34736] = "GEODOUBLEPARAMS", e8[34737] = "GEOASCIIPARAMS", e8[34665] = "EXIFIFD", e8[34853] = "GPSIFD", e8[40965] = "INTEROPERABILITYIFD", e8;
})();
var i5 = (() => {
  const i11 = e6.slice();
  return i11[36864] = "ExifVersion", i11[40960] = "FlashpixVersion", i11[40961] = "ColorSpace", i11[42240] = "Gamma", i11[37121] = "ComponentsConfiguration", i11[37122] = "CompressedBitsPerPixel", i11[40962] = "PixelXDimension", i11[40963] = "PixelYDimension", i11[37500] = "MakerNote", i11[37510] = "UserComment", i11[40964] = "RelatedSoundFile", i11[36867] = "DateTimeOriginal", i11[36868] = "DateTimeDigitized", i11[36880] = "OffsetTime", i11[36881] = "OffsetTimeOriginal", i11[36882] = "OffsetTimeDigitized", i11[37520] = "SubSecTime", i11[37521] = "SubSecTimeOriginal", i11[37522] = "SubSecTimeDigitized", i11[37888] = "Temperature", i11[37889] = "Humidity", i11[37890] = "Pressure", i11[37891] = "WaterDepth", i11[37892] = "Acceleration", i11[37893] = "CameraElevationAngle", i11[42016] = "ImageUniqueID", i11[42032] = "CameraOwnerName", i11[42033] = "BodySerialNumber", i11[42034] = "LensSpecification", i11[42035] = "LensMake", i11[42036] = "LensModel", i11[42037] = "LensSerialNumber", i11[33434] = "ExposureTime", i11[33437] = "FNumber", i11[34850] = "ExposureProgram", i11[34852] = "SpectralSensitivity", i11[34855] = "PhotographicSensitivity", i11[34856] = "OECF", i11[34864] = "SensitivityType", i11[34865] = "StandardOutputSensitivity", i11[34866] = "RecommendedExposureIndex", i11[34867] = "ISOSpeed", i11[34868] = "ISOSpeedLatitudeyyy", i11[34869] = "ISOSpeedLatitudezzz", i11[37377] = "ShutterSpeedValue", i11[37378] = "ApertureValue", i11[37379] = "BrightnessValue", i11[37380] = "ExposureBiasValue", i11[37381] = "MaxApertureValue", i11[37382] = "SubjectDistance", i11[37383] = "MeteringMode", i11[37384] = "LightSource", i11[37385] = "Flash", i11[37386] = "FocalLength", i11[37396] = "SubjectArea", i11[41483] = "FlashEnergy", i11[41484] = "SpatialFrequencyResponse", i11[41486] = "FocalPlaneXResolution", i11[41487] = "FocalPlaneYResolution", i11[41488] = "FocalPlaneResolutionUnit", i11[41492] = "SubjectLocation", i11[41493] = "ExposureIndex", i11[41495] = "SensingMethod", i11[41728] = "FileSource", i11[41729] = "SceneType", i11[41730] = "CFAPattern", i11[41985] = "CustomRendered", i11[41986] = "ExposureMode", i11[41987] = "WhiteBalance", i11[41988] = "DigitalZoomRatio", i11[41989] = "FocalLengthIn35mmFilm", i11[41990] = "SceneCaptureType", i11[41991] = "GainControl", i11[41992] = "Contrast", i11[41993] = "Saturation", i11[41994] = "Sharpness", i11[41995] = "DeviceSettingDescription", i11[41996] = "SubjectDistanceRange", i11;
})();
var t8 = ["GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "GPSHPositioningError"];
var o3 = (() => {
  const e8 = [];
  return e8[1024] = "GTModelTypeGeoKey", e8[1025] = "GTRasterTypeGeoKey", e8[1026] = "GTCitationGeoKey", e8[2048] = "GeographicTypeGeoKey", e8[2049] = "GeogCitationGeoKey", e8[2050] = "GeogGeodeticDatumGeoKey", e8[2051] = "GeogPrimeMeridianGeoKey", e8[2052] = "GeogLinearUnitsGeoKey", e8[2053] = "GeogLinearUnitSizeGeoKey", e8[2054] = "GeogAngularUnitsGeoKey", e8[2055] = "GeogAngularUnitSizeGeoKey", e8[2056] = "GeogEllipsoidGeoKey", e8[2057] = "GeogSemiMajorAxisGeoKey", e8[2058] = "GeogSemiMinorAxisGeoKey", e8[2059] = "GeogInvFlatteningGeoKey", e8[2061] = "GeogPrimeMeridianLongGeoKey", e8[2060] = "GeogAzimuthUnitsGeoKey", e8[3072] = "ProjectedCSTypeGeoKey", e8[3073] = "PCSCitationGeoKey", e8[3074] = "ProjectionGeoKey", e8[3075] = "ProjCoordTransGeoKey", e8[3076] = "ProjLinearUnitsGeoKey", e8[3077] = "ProjLinearUnitSizeGeoKey", e8[3078] = "ProjStdParallel1GeoKey", e8[3079] = "ProjStdParallel2GeoKey", e8[3080] = "ProjNatOriginLongGeoKey", e8[3081] = "ProjNatOriginLatGeoKey", e8[3082] = "ProjFalseEastingGeoKey", e8[3083] = "ProjFalseNorthingGeoKey", e8[3084] = "ProjFalseOriginLongGeoKey", e8[3085] = "ProjFalseOriginLatGeoKey", e8[3086] = "ProjFalseOriginEastingGeoKey", e8[3087] = "ProjFalseOriginNorthingGeoKey", e8[3088] = "ProjCenterLongGeoKey", e8[3090] = "ProjCenterEastingGeoKey", e8[3091] = "ProjCenterNorthingGeoKey", e8[3092] = "ProjScaleAtNatOriginGeoKey", e8[3093] = "ProjScaleAtCenterGeoKey", e8[3094] = "ProjAzimuthAngleGeoKey", e8[3095] = "ProjStraightVertPoleLongGeoKey", e8[4096] = "VerticalCSTypeGeoKey", e8[4097] = "VerticalCitationGeoKey", e8[4098] = "VerticalDatumGeoKey", e8[4099] = "VerticalUnitsGeoKey", e8;
})();
var S = (i11, t11) => {
  let o10 = (t11 || e6)[i11];
  return void 0 === o10 && (o10 = "unknown" + String(i11)), o10;
};
var E = /* @__PURE__ */ new Map();
E.set("EXIFIFD", i5), E.set("GPSIFD", t8);
var n5 = { TIFF_TAGS: e6, ifdTags: E, GEO_KEYS: o3, getTagName: S };

// node_modules/@arcgis/core/layers/support/rasterFormats/utils.js
var r10 = (() => {
  const r16 = new ArrayBuffer(4), n14 = new Uint8Array(r16);
  return new Uint32Array(r16)[0] = 1, 1 === n14[0];
})();

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffDecoder.js
var f4 = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, -1, -1, -1, 8, 8, 8];
var u4 = 4294967296;
var c4 = /* @__PURE__ */ new Set([1, 5, 6, 7, 8, 34712, 34887]);
function h2(e8, t11) {
  let n14 = "unknown";
  return 3 === e8 ? n14 = 64 === t11 ? "f64" : "f32" : 1 === e8 ? 1 === t11 ? n14 = "u1" : 2 === t11 ? n14 = "u2" : 4 === t11 ? n14 = "u4" : t11 <= 8 ? n14 = "u8" : t11 <= 16 ? n14 = "u16" : t11 <= 32 && (n14 = "u32") : 2 === e8 && (t11 <= 8 ? n14 = "s8" : t11 <= 16 ? n14 = "s16" : t11 <= 32 && (n14 = "s32")), n14;
}
function g(e8) {
  let t11 = null;
  switch (e8 ? e8.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      t11 = Uint8Array;
      break;
    case "u16":
      t11 = Uint16Array;
      break;
    case "u32":
      t11 = Uint32Array;
      break;
    case "s8":
      t11 = Int8Array;
      break;
    case "s16":
      t11 = Int16Array;
      break;
    case "s32":
      t11 = Int32Array;
      break;
    case "f64":
      t11 = Float64Array;
      break;
    default:
      t11 = Float32Array;
  }
  return t11;
}
function E2(e8, t11) {
  return { x: t11[0] * e8.x + t11[1] * e8.y + t11[2], y: t11[3] * e8.x + t11[4] * e8.y + t11[5] };
}
function T(e8, t11) {
  var _a;
  return (_a = e8.get(t11)) == null ? void 0 : _a.values;
}
function I(e8, t11) {
  var _a;
  return (_a = e8.get(t11)) == null ? void 0 : _a.values;
}
function w(e8, t11) {
  var _a, _b;
  return (_b = (_a = e8.get(t11)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
}
function p3(e8, t11) {
  var _a, _b;
  return (_b = (_a = e8.get(t11)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
}
function d(e8, t11, n14, a16 = 0, i11 = n5.TIFF_TAGS, s14 = 4) {
  const l9 = 8 === s14, o10 = l9 ? k(new DataView(e8, n14, 8), 0, t11) : new DataView(e8, n14, 2).getUint16(0, t11), f11 = 4 + 2 * s14, u14 = l9 ? 8 : 2, c11 = u14 + o10 * f11;
  if (n14 + c11 > e8.byteLength)
    return { success: false, ifd: null, nextIFD: null, requiredBufferSize: c11 };
  const h10 = n14 + c11 + 4 <= e8.byteLength ? C(new DataView(e8, n14 + c11, 8 === s14 ? 8 : 4), 0, t11, 8 === s14) : null, g7 = n14 + u14, E4 = /* @__PURE__ */ new Map();
  let T4, I5, w6, p10, d8, S4 = 0, y7 = 0;
  for (let m8 = 0; m8 < o10; m8++) {
    I5 = new DataView(e8, g7 + f11 * m8, f11), w6 = I5.getUint16(0, t11), d8 = I5.getUint16(2, t11), p10 = n5.getTagName(w6, i11);
    const n15 = [];
    2 === s14 ? (S4 = I5.getUint16(4, t11), y7 = I5.getUint16(6, t11)) : 4 === s14 ? (S4 = I5.getUint32(4, t11), y7 = I5.getUint32(8, t11)) : 8 === s14 && (S4 = C(I5, 4, t11, true), y7 = C(I5, 12, t11, true), n15.push(I5.getUint32(12, t11)), n15.push(I5.getUint32(16, t11))), T4 = { id: w6, type: d8, valueCount: S4, valueOffset: y7, valueOffsets: n15, values: null }, L(e8, t11, T4, a16, false, s14), E4.set(p10, T4);
  }
  return { success: true, ifd: E4, nextIFD: h10, requiredBufferSize: c11 };
}
var S2 = (e8, t11) => c3(e8, { inputOffset: t11 }).pixels[0];
function y3(e8, t11) {
  if (1 !== t11 && 2 !== t11 && 4 !== t11)
    return e8;
  const n14 = new Uint8Array(e8), a16 = 8 / t11, i11 = new Uint8Array(e8.byteLength * a16);
  let s14 = 0;
  const r16 = 2 ** t11 - 1;
  for (let l9 = 0; l9 < n14.length; l9++) {
    const e9 = n14[l9];
    for (let n15 = 0; n15 < a16; n15++)
      i11[s14++] = e9 << t11 * n15 >>> 8 - t11 & r16;
  }
  return i11.buffer;
}
function m(e8, n14, a16) {
  const i11 = new t4();
  i11.parse(e8), i11.colorTransform = 6 === a16 ? -1 : 0;
  const s14 = i11.getData(i11.width, i11.height, 1 !== n14);
  return new Uint8Array(s14.buffer);
}
function A(e8) {
  const t11 = new f2(e8).getBytes(), n14 = new ArrayBuffer(t11.length), a16 = new Uint8Array(n14);
  return a16.set(t11), a16;
}
async function M2(e8, t11, a16, s14, r16) {
  const o10 = r10 === t11, f11 = p3(a16, "BITSPERSAMPLE"), u14 = p3(a16, "SAMPLESPERPIXEL") ?? 1, c11 = p3(a16, "PHOTOMETRICINTERPRETATION"), E4 = p3(a16, "SAMPLEFORMAT") ?? 1, T4 = h2(E4, f11), I5 = p3(a16, "COMPRESSION") ?? 1, w6 = g(T4);
  let d8, M6, P4;
  if (34887 === I5)
    return await a6(), S2(e8, s14);
  if (1 === I5)
    d8 = e8.slice(s14, s14 + r16), M6 = new Uint8Array(d8);
  else if (8 === I5 || 32946 === I5)
    M6 = new Uint8Array(e8, s14, r16), M6 = A(M6), d8 = M6.buffer;
  else if (6 === I5)
    M6 = new Uint8Array(e8, s14, r16), M6 = m(M6, u14, c11), d8 = M6.buffer;
  else if (7 === I5) {
    const t12 = a16.get("JPEGTABLES").values, n14 = t12.length - 2;
    M6 = new Uint8Array(n14 + r16 - 2);
    for (let e9 = 0; e9 < n14; e9++)
      M6[e9] = t12[e9];
    const i11 = new Uint8Array(e8, s14 + 2, r16 - 2);
    for (let e9 = 0; e9 < i11.length; e9++)
      M6[n14 + e9] = i11[e9];
    M6 = m(M6, u14, c11), d8 = M6.buffer;
  } else {
    if (5 !== I5)
      throw new Error("tiff-decode: unsupport compression " + I5);
    M6 = i4(e8, s14, r16, t11), d8 = M6.buffer;
  }
  if (d8 = y3(d8, f11), "u8" === T4 || "s8" === T4 || o10)
    P4 = new w6(d8);
  else {
    d8 = new ArrayBuffer(M6.length);
    const e9 = new Uint8Array(d8);
    switch (T4) {
      case "u16":
      case "s16":
        for (let t12 = 0; t12 < M6.length; t12 += 2)
          e9[t12] = M6[t12 + 1], e9[t12 + 1] = M6[t12];
        break;
      case "u32":
      case "s32":
      case "f32":
        for (let t12 = 0; t12 < M6.length; t12 += 4)
          e9[t12] = M6[t12 + 3], e9[t12 + 1] = M6[t12 + 2], e9[t12 + 2] = M6[t12 + 1], e9[t12 + 3] = M6[t12];
    }
    P4 = new w6(d8);
  }
  const O3 = p3(a16, "PREDICTOR") ?? 1, b5 = p3(a16, "TILEWIDTH"), x6 = p3(a16, "TILELENGTH");
  if (O3 > 1 && (5 === I5 || 8 === I5 || 32946 === I5) && b5 && x6) {
    const e9 = D(a16), t12 = new w6(P4.length);
    t12.set(P4), P4 = W(t12, x6, b5, 3 === E4 && 3 === O3, e9 ? 1 : u14);
  }
  return P4;
}
async function P(e8, t11, n14) {
  const a16 = I(n14, "TILEOFFSETS");
  if (void 0 === a16)
    return null;
  const i11 = I(n14, "TILEBYTECOUNTS"), { width: s14, height: r16, pixelType: l9, tileWidth: o10, tileHeight: f11 } = R([n14]), u14 = D(n14, t11), c11 = p3(n14, "SAMPLESPERPIXEL") || t11.planes, h10 = s14 * r16, E4 = p3(n14, "BITSPERSAMPLE"), T4 = 34887 === (p3(n14, "COMPRESSION") ?? 1), w6 = g(l9), d8 = [];
  for (let g7 = 0; g7 < c11; g7++)
    d8.push(new w6(h10));
  let S4, y7, m8, A4, P4, O3, b5, x6, L3, U4, N2, G3, k5;
  const F2 = Math.ceil(s14 / o10);
  if (E4 % 8 == 0) {
    if (T4 && u14 && c11 > 1) {
      const l10 = Math.round(a16.length / c11);
      for (S4 = 0; S4 < l10; S4++) {
        O3 = Math.floor(S4 / F2) * f11, b5 = S4 % F2 * o10, x6 = O3 * s14 + b5;
        for (let l11 = 0; l11 < c11; l11++) {
          const u15 = S4 * c11 + l11;
          if (0 !== i11[u15])
            for (m8 = await M2(e8, t11.littleEndian, n14, a16[u15], i11[u15]), U4 = 0, L3 = x6, G3 = Math.min(o10, s14 - b5), N2 = Math.min(f11, r16 - O3), k5 = d8[l11], A4 = 0; A4 < N2; A4++)
              for (L3 = x6 + A4 * s14, U4 = A4 * o10, P4 = 0; P4 < G3; P4++, L3++, U4++)
                k5[L3] = m8[U4];
        }
      }
    } else
      for (S4 = 0; S4 < a16.length; S4++)
        if (0 !== i11[S4])
          for (O3 = Math.floor(S4 / F2) * f11, b5 = S4 % F2 * o10, x6 = O3 * s14 + b5, m8 = await M2(e8, t11.littleEndian, n14, a16[S4], i11[S4]), U4 = 0, L3 = x6, G3 = Math.min(o10, s14 - b5), N2 = Math.min(f11, r16 - O3), y7 = 0; y7 < c11; y7++)
            if (k5 = d8[y7], u14 || T4)
              for (A4 = 0; A4 < N2; A4++)
                for (L3 = x6 + A4 * s14, U4 = o10 * f11 * y7 + A4 * o10, P4 = 0; P4 < G3; P4++, L3++, U4++)
                  k5[L3] = m8[U4];
            else
              for (A4 = 0; A4 < N2; A4++)
                for (L3 = x6 + A4 * s14, U4 = A4 * o10 * c11 + y7, P4 = 0; P4 < G3; P4++, L3++, U4 += c11)
                  k5[L3] = m8[U4];
  }
  return { width: s14, height: r16, pixelType: l9, pixels: d8 };
}
var O = (e8, t11, n14) => {
  const a16 = r10 === t11.littleEndian, s14 = I(n14, "STRIPOFFSETS");
  if (void 0 === s14)
    return null;
  const { width: r16, height: o10, pixelType: f11 } = R([n14]), u14 = p3(n14, "SAMPLESPERPIXEL") || t11.planes, c11 = p3(n14, "PHOTOMETRICINTERPRETATION"), h10 = r16 * o10, E4 = p3(n14, "BITSPERSAMPLE"), T4 = g(f11), w6 = new T4(h10 * u14), d8 = I(n14, "STRIPBYTECOUNTS"), S4 = p3(n14, "ROWSPERSTRIP"), M6 = p3(n14, "COMPRESSION") ?? 1;
  let P4, O3, b5, x6, L3, D4, U4, N2, G3, k5 = S4;
  if (E4 % 8 == 0)
    for (P4 = 0; P4 < s14.length; P4++) {
      if (L3 = P4 * (S4 * r16) * u14, k5 = (P4 + 1) * S4 > o10 ? o10 - P4 * S4 : S4, "u8" === f11 || "s8" === f11 || a16)
        8 === M6 || 32946 === M6 ? (U4 = new Uint8Array(e8, s14[P4], d8[P4]), U4 = A(U4), D4 = U4.buffer) : 6 === M6 ? (U4 = new Uint8Array(e8, s14[P4], d8[P4]), U4 = m(U4, u14, c11), D4 = U4.buffer) : 5 === M6 ? (U4 = i4(e8, s14[P4], d8[P4], t11.littleEndian), D4 = U4.buffer) : (d8[P4] !== k5 * r16 * u14 * E4 / 8 && console.log("strip byte counts is different than expected"), D4 = e8.slice(s14[P4], s14[P4] + d8[P4])), D4 = y3(D4, E4), x6 = new T4(D4);
      else {
        switch (6 === M6 || 8 === M6 || 32946 === M6 ? (U4 = new Uint8Array(e8, s14[P4], d8[P4]), N2 = A(U4), D4 = N2.buffer) : (d8[P4] !== k5 * r16 * u14 * E4 / 8 && console.log("strip byte counts is different than expected"), D4 = new ArrayBuffer(d8[P4]), U4 = new Uint8Array(e8, s14[P4], d8[P4]), N2 = new Uint8Array(D4)), f11) {
          case "u16":
          case "s16":
            for (b5 = 0; b5 < U4.length; b5 += 2)
              N2[b5] = U4[b5 + 1], N2[b5 + 1] = U4[b5];
            break;
          case "u32":
          case "s32":
          case "f32":
            for (b5 = 0; b5 < U4.length; b5 += 4)
              N2[b5] = U4[b5 + 3], N2[b5 + 1] = U4[b5 + 2], N2[b5 + 2] = U4[b5 + 1], N2[b5 + 3] = U4[b5];
        }
        D4 = y3(D4, E4), x6 = new T4(D4);
      }
      w6.set(x6, L3);
    }
  const F2 = [];
  if (1 === u14)
    F2.push(w6);
  else
    for (P4 = 0; P4 < u14; P4++) {
      for (G3 = new T4(h10), O3 = 0; O3 < h10; O3++)
        G3[O3] = w6[O3 * u14 + P4];
      F2.push(G3);
    }
  return { width: r16, height: o10, pixelType: f11, pixels: F2 };
};
var b = (e8, t11, n14) => {
  if (!(e8 && e8.length > 0 && t11 && n14))
    return null;
  let a16, i11, s14;
  const r16 = e8[0].length, l9 = e8.length, o10 = new Uint8Array(r16);
  for (let f11 = 0; f11 < l9; f11++)
    if (a16 = e8[f11], i11 = t11[f11], s14 = n14[f11], 0 === f11)
      for (let e9 = 0; e9 < r16; e9++)
        o10[e9] = a16[e9] < i11 || a16[e9] > s14 ? 0 : 1;
    else
      for (let e9 = 0; e9 < r16; e9++)
        o10[e9] && (o10[e9] = a16[e9] < i11 || a16[e9] > s14 ? 0 : 1);
  return o10;
};
var x2 = (e8) => {
  if (!e8)
    return null;
  const t11 = e8.match(/<Item(.*?)Item>/gi);
  if (!t11 || 0 === t11.length)
    return null;
  const n14 = /* @__PURE__ */ new Map();
  let a16, i11, s14, r16, l9;
  for (let w6 = 0; w6 < t11.length; w6++)
    a16 = t11[w6], i11 = a16.slice(6, a16.indexOf(">")), r16 = a16.indexOf("sample="), r16 > -1 && (l9 = a16.slice(r16 + 8, a16.indexOf('"', r16 + 8))), r16 = a16.indexOf("name="), r16 > -1 && (i11 = a16.slice(r16 + 6, a16.indexOf('"', r16 + 6))), i11 && (s14 = a16.slice(a16.indexOf(">") + 1, a16.indexOf("</Item>")).trim(), null != l9 ? n14.has(i11) ? n14.get(i11)[l9] = s14 : n14.set(i11, [s14]) : n14.set(i11, s14)), l9 = null;
  const o10 = n14.get("STATISTICS_MINIMUM"), f11 = n14.get("STATISTICS_MAXIMUM"), u14 = n14.get("STATISTICS_MEAN"), c11 = n14.get("STATISTICS_STDDEV");
  let h10 = null;
  if (o10 && f11) {
    h10 = [];
    for (let e9 = 0; e9 < o10.length; e9++)
      h10.push({ min: parseFloat(o10[e9]), max: parseFloat(f11[e9]), avg: u14 && parseFloat(u14[e9]), stddev: c11 && parseFloat(c11[e9]) });
  }
  const g7 = n14.get("BandName"), E4 = n14.get("WavelengthMin"), T4 = n14.get("WavelengthMax");
  let I5 = null;
  if (g7) {
    I5 = [];
    for (let e9 = 0; e9 < g7.length; e9++)
      I5.push({ BandName: g7[e9], WavelengthMin: E4 && parseFloat(E4[e9]), WavelengthMax: T4 && parseFloat(T4[e9]) });
  }
  return { statistics: h10, bandProperties: I5, dataType: n14.get("DataType"), rawMetadata: n14 };
};
function L(e8, t11, n14, a16 = 0, i11 = false, s14 = 4) {
  if (n14.values)
    return true;
  const r16 = n14.type, l9 = n14.valueCount;
  let o10 = n14.valueOffset, c11 = [];
  const h10 = f4[r16], g7 = 8 * h10, E4 = l9 * h10, T4 = l9 * f4[r16] * 8;
  let I5, w6;
  const p10 = 8 === s14 ? 64 : 32, d8 = n14.valueOffsets;
  if (T4 > p10) {
    if (E4 > (i11 ? e8.byteLength : e8 ? e8.byteLength - o10 + a16 : 0))
      return n14.offlineOffsetSize = [o10, E4], n14.values = null, false;
  }
  if (T4 <= p10) {
    if (!t11)
      if (p10 <= 32)
        o10 >>>= 32 - T4;
      else {
        const e9 = (d8 == null ? void 0 : d8.length) ? d8[0] : o10 >>> 0, t12 = (d8 == null ? void 0 : d8.length) ? d8[1] : Math.round((o10 - e9) / u4);
        T4 <= 32 ? (o10 = e9 >>> 32 - T4, d8[0] = o10) : (o10 = e9 * 2 ** (32 - T4) + (t12 >>> 32 - T4), d8[0] = e9, d8[1] = t12 >>> 32 - T4);
      }
    if (1 === l9 && g7 === p10)
      c11 = [o10];
    else if (64 === p10) {
      const e9 = (d8 == null ? void 0 : d8.length) ? d8[0] : o10 >>> 0, t12 = (d8 == null ? void 0 : d8.length) ? d8[1] : Math.round((o10 - e9) / u4);
      let n15 = e9, a17 = 32;
      for (w6 = 1; w6 <= l9; w6++) {
        const e10 = 32 - g7 * w6 % 32;
        if (a17 < g7) {
          const i12 = n15 << e10 >>> 32 - a17, s15 = t12 << 32 - a17 >>> 32 - a17;
          n15 = t12, c11.push(i12 + s15 * 2 ** (g7 - a17)), a17 -= 32 - (g7 - a17);
        } else
          c11.push(n15 << e10 >>> 32 - g7), a17 -= g7;
        0 === a17 && (a17 = 32, n15 = t12);
      }
    } else
      for (w6 = 1; w6 <= l9; w6++) {
        const e9 = 32 - g7 * w6;
        c11.push(o10 << e9 >>> 32 - g7);
      }
  } else {
    o10 -= a16, i11 && (o10 = 0);
    for (let n15 = o10; n15 < o10 + E4; n15 += h10) {
      switch (r16) {
        case 1:
        case 2:
        case 7:
          I5 = new DataView(e8, n15, 1).getUint8(0);
          break;
        case 3:
          I5 = new DataView(e8, n15, 2).getUint16(0, t11);
          break;
        case 4:
        case 13:
          I5 = new DataView(e8, n15, 4).getUint32(0, t11);
          break;
        case 5:
          I5 = new DataView(e8, n15, 4).getUint32(0, t11) / new DataView(e8, n15 + 4, 4).getUint32(0, t11);
          break;
        case 6:
          I5 = new DataView(e8, n15, 1).getInt8(0);
          break;
        case 8:
          I5 = new DataView(e8, n15, 2).getInt16(0, t11);
          break;
        case 9:
          I5 = new DataView(e8, n15, 4).getInt32(0, t11);
          break;
        case 10:
          I5 = new DataView(e8, n15, 4).getInt32(0, t11) / new DataView(e8, n15 + 4, 4).getInt32(0, t11);
          break;
        case 11:
          I5 = new DataView(e8, n15, 4).getFloat32(0, t11);
          break;
        case 12:
          I5 = new DataView(e8, n15, 8).getFloat64(0, t11);
          break;
        case 16:
        case 18:
          I5 = k(new DataView(e8, n15, 8), 0, t11);
          break;
        case 17:
          I5 = F(new DataView(e8, n15, 8), 0, t11);
          break;
        default:
          I5 = null;
      }
      c11.push(I5);
    }
  }
  if (2 === r16) {
    let e9 = "";
    const t12 = c11;
    for (c11 = [], w6 = 0; w6 < t12.length; w6++)
      0 === t12[w6] && "" !== e9 ? (c11.push(e9), e9 = "") : e9 += String.fromCharCode(t12[w6]);
    "" === e9 && 0 !== c11.length || c11.push(e9);
  }
  return n14.values = c11, true;
}
function R(e8) {
  const t11 = e8[0], n14 = p3(t11, "TILEWIDTH"), a16 = p3(t11, "TILELENGTH"), i11 = p3(t11, "IMAGEWIDTH"), s14 = p3(t11, "IMAGELENGTH"), r16 = p3(t11, "BITSPERSAMPLE"), l9 = p3(t11, "SAMPLESPERPIXEL"), o10 = p3(t11, "SAMPLEFORMAT") ?? 1, f11 = h2(o10, r16), u14 = D(t11), g7 = T(t11, "GDAL_NODATA");
  let d8 = null;
  (g7 == null ? void 0 : g7.length) && (d8 = g7.map((e9) => parseFloat(e9)), d8.some((e9) => isNaN(e9)) && (d8 = null));
  const S4 = p3(t11, "COMPRESSION") ?? 1;
  let y7;
  switch (S4) {
    case 1:
      y7 = "NONE";
      break;
    case 2:
    case 3:
    case 4:
    case 32771:
      y7 = "CCITT";
      break;
    case 5:
      y7 = "LZW";
      break;
    case 6:
    case 7:
      y7 = "JPEG";
      break;
    case 32773:
      y7 = "PACKBITS";
      break;
    case 8:
    case 32946:
      y7 = "DEFLATE";
      break;
    case 34712:
      y7 = "JPEG2000";
      break;
    case 34887:
      y7 = "LERC";
      break;
    default:
      y7 = String(S4);
  }
  let m8 = true, A4 = "";
  c4.has(S4) || (m8 = false, A4 += "unsupported tag compression " + S4), o10 > 3 && (m8 = false, A4 += "unsupported tag sampleFormat " + o10), 1 !== r16 && 2 !== r16 && 4 !== r16 && r16 % 8 != 0 && (m8 = false, A4 += "unsupported tag bitsPerSample " + r16);
  const M6 = w(t11, "GEOASCIIPARAMS");
  let P4;
  if (M6) {
    const e9 = M6.split("|").find((e10) => e10.includes("ESRI PE String = ")), t12 = e9 ? e9.replace("ESRI PE String = ", "") : "";
    P4 = t12.startsWith("COMPD_CS") || t12.startsWith("PROJCS") || t12.startsWith("GEOGCS") ? { wkid: null, wkt: t12 } : null;
  }
  const O3 = I(t11, "GEOTIEPOINTS"), b5 = I(t11, "GEOPIXELSCALE"), L3 = I(t11, "GEOTRANSMATRIX"), R4 = t11.has("GEOKEYDIRECTORY") ? t11.get("GEOKEYDIRECTORY").data : null;
  let G3, k5, F2 = false, C6 = false;
  if (R4) {
    F2 = 2 === p3(R4, "GTRasterTypeGeoKey");
    const e9 = p3(R4, "GTModelTypeGeoKey");
    if (2 === e9) {
      const e10 = p3(R4, "GeographicTypeGeoKey");
      e10 >= 1024 && e10 <= 32766 && (P4 = { wkid: e10 }), P4 || 32767 !== e10 || (C6 = true, P4 = { wkid: 4326 });
    } else if (1 === e9) {
      const e10 = p3(R4, "ProjectedCSTypeGeoKey");
      e10 >= 1024 && e10 <= 32766 && (P4 = { wkid: e10 });
    }
  }
  if (b5 && O3 && O3.length >= 6 ? (G3 = [b5[0], 0, O3[3] - O3[0] * b5[0], 0, -Math.abs(b5[1]), O3[4] - O3[1] * b5[1]], F2 && (G3[2] -= 0.5 * G3[0] + 0.5 * G3[1], G3[5] -= 0.5 * G3[3] + 0.5 * G3[4])) : L3 && 16 === L3.length && (G3 = F2 ? [L3[0], L3[1], L3[3] - 0.5 * L3[0], L3[4], L3[5], L3[7] - 0.5 * L3[5]] : [L3[0], L3[1], L3[3], L3[4], L3[5], L3[7]]), G3) {
    const e9 = [{ x: 0, y: s14 }, { x: 0, y: 0 }, { x: i11, y: s14 }, { x: i11, y: 0 }];
    let t12, n15 = Number.POSITIVE_INFINITY, a17 = Number.POSITIVE_INFINITY, r17 = Number.NEGATIVE_INFINITY, l10 = Number.NEGATIVE_INFINITY;
    for (let i12 = 0; i12 < e9.length; i12++)
      t12 = E2(e9[i12], G3), n15 = t12.x > n15 ? n15 : t12.x, r17 = t12.x < r17 ? r17 : t12.x, a17 = t12.y > a17 ? a17 : t12.y, l10 = t12.y < l10 ? l10 : t12.y;
    k5 = { xmin: n15, xmax: r17, ymin: a17, ymax: l10, spatialReference: P4 };
  } else
    k5 = { xmin: -0.5, ymin: 0.5 - s14, xmax: i11 - 0.5, ymax: 0.5, spatialReference: P4 };
  C6 && (k5.xmax - k5.xmin > 400 || Math.max(Math.abs(k5.xmin), Math.abs(k5.xmax)) > 361) && (P4 = null, k5.spatialReference = null);
  const v6 = U(e8);
  let B4, W3, H2, Y2, _3;
  if (v6.length > 0) {
    H2 = Math.round(Math.log(i11 / p3(v6[0], "IMAGEWIDTH")) / Math.LN2);
    const e9 = v6[v6.length - 1];
    Y2 = Math.round(Math.log(i11 / p3(e9, "IMAGEWIDTH")) / Math.LN2), B4 = p3(e9, "TILEWIDTH"), W3 = p3(e9, "TILELENGTH");
  }
  B4 = null != Y2 && Y2 > 0 ? B4 || n14 : null, W3 = null != Y2 && Y2 > 0 ? W3 || a16 : null, n14 && (_3 = [{ maxCol: Math.ceil(i11 / n14) - 1, maxRow: Math.ceil(s14 / a16) - 1, minRow: 0, minCol: 0 }], v6.forEach((e9) => {
    _3.push({ maxCol: Math.ceil(p3(e9, "IMAGEWIDTH") / p3(e9, "TILEWIDTH")) - 1, maxRow: Math.ceil(p3(e9, "IMAGELENGTH") / p3(e9, "TILELENGTH")) - 1, minRow: 0, minCol: 0 });
  }));
  const K = w(e8[0], "GDAL_METADATA"), X = x2(K);
  A4 += " " + V({ width: i11, height: s14, tileWidth: n14, tileHeight: a16, planes: l9, ifds: e8 });
  return { width: i11, height: s14, tileWidth: n14, tileHeight: a16, planes: l9, isBSQ: u14, pixelType: f11, compression: y7, noData: d8, hasMaskBand: N(e8).length === v6.length + 1, isSupported: m8, message: A4, extent: k5, isPseudoGeographic: C6, affine: b5 ? null : G3, firstPyramidLevel: H2, maximumPyramidLevel: Y2, pyramidBlockWidth: B4, pyramidBlockHeight: W3, tileBoundary: _3, metadata: X };
}
function D(e8, t11) {
  const n14 = T(e8, "PLANARCONFIGURATION");
  return n14 ? 2 === n14[0] : !!t11 && t11.isBSQ;
}
function U(e8) {
  return e8.filter((e9) => 1 === p3(e9, "NEWSUBFILETYPE"));
}
function N(e8) {
  return e8.filter((e9) => {
    const t11 = 4 == (4 & (p3(e9, "NEWSUBFILETYPE") ?? 0)), n14 = 4 === p3(e9, "PHOTOMETRICINTERPRETATION");
    return t11 && n14;
  });
}
function G(e8) {
  const { littleEndian: t11, isBigTiff: n14, firstIFDPos: a16 } = v2(e8);
  let i11 = a16;
  const s14 = [];
  do {
    const a17 = B(e8, t11, i11, 0, n5.TIFF_TAGS, n14 ? 8 : 4);
    if (!a17.success)
      break;
    s14.push(a17.ifd), i11 = a17.nextIFD;
  } while (i11 > 0);
  return { ...R(s14), littleEndian: t11, isBigTiff: n14, ifds: s14, pyramidIFDs: U(s14), maskIFDs: N(s14) };
}
function k(e8, t11, n14) {
  const a16 = e8.getUint32(t11, n14), i11 = e8.getUint32(t11 + 4, n14);
  return n14 ? i11 * u4 + a16 : a16 * u4 + i11;
}
function F(e8, t11, n14) {
  let a16 = n14 ? e8.getInt32(t11, n14) : e8.getUint32(t11, n14), i11 = n14 ? e8.getUint32(t11 + 4, n14) : e8.getInt32(t11 + 4, n14);
  const s14 = (n14 ? a16 : i11) >= 0 ? 1 : -1;
  n14 ? a16 *= s14 : i11 *= s14;
  return s14 * (n14 ? i11 * u4 + a16 : a16 * u4 + i11);
}
function C(e8, t11, n14, a16) {
  return a16 ? k(e8, t11, n14) : e8.getUint32(t11, n14);
}
function v2(e8) {
  const t11 = new DataView(e8, 0, 16), n14 = t11.getUint16(0, false);
  let a16 = null;
  if (18761 === n14)
    a16 = true;
  else {
    if (19789 !== n14)
      throw new Error("unexpected endianess byte");
    a16 = false;
  }
  const i11 = t11.getUint16(2, a16);
  if (42 !== i11 && 43 !== i11)
    throw new Error("unexpected tiff identifier");
  let s14 = 4;
  const r16 = 43 === i11;
  if (r16) {
    const e9 = t11.getUint16(s14, a16);
    if (s14 += 2, 8 !== e9)
      throw new Error("unsupported bigtiff version");
    if (0 !== t11.getUint16(s14, a16))
      throw new Error("unsupported bigtiff version");
    s14 += 2;
  }
  return { littleEndian: a16, isBigTiff: r16, firstIFDPos: C(t11, s14, a16, r16) };
}
function B(t11, n14, a16, i11 = 0, s14 = n5.TIFF_TAGS, l9 = 4) {
  const o10 = d(t11, n14, a16, i11, s14, l9);
  let f11;
  const u14 = o10.ifd;
  if (u14) {
    if (n5.ifdTags.forEach((e8, a17) => {
      u14.has(a17) && (f11 = u14.get(a17), f11.data = d(t11, n14, f11.valueOffset - i11, i11, e8).ifd);
    }), u14.has("GEOKEYDIRECTORY")) {
      f11 = u14.get("GEOKEYDIRECTORY");
      const e8 = f11.values;
      if (e8 && e8.length > 4) {
        const a17 = e8[0] + "." + e8[1] + "." + e8[2];
        f11.data = d(t11, n14, f11.valueOffset + 6 - i11, i11, n5.GEO_KEYS, 2).ifd, f11.data && f11.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a17] });
      }
    }
    if (u14.has("XMP")) {
      f11 = u14.get("XMP");
      const t12 = f11.values;
      "number" == typeof t12[0] && 7 === f11.type && (f11.values = [r9(new Uint8Array(t12))]);
    }
  }
  return o10;
}
function V(e8) {
  const { width: t11, height: n14, tileHeight: a16, tileWidth: i11 } = e8, s14 = e8.planes, r16 = i11 ? i11 * a16 : t11 * n14, l9 = p3(e8.ifds[0], "BITSPERSAMPLE");
  let o10 = "";
  return r16 * s14 > 2 ** 30 / (l9 > 8 ? l9 / 8 : 1) && (o10 = i11 ? "tiled tiff exceeding 1 gigabits per tile is not supported" : "scanline tiff exceeding 1 gigabits is not supported"), o10;
}
function W(e8, t11, n14, a16, i11) {
  const s14 = a16 ? 4 : 1, r16 = n14 * s14 * i11;
  a16 && (e8 = new Uint8Array(e8.buffer));
  for (let f11 = 0; f11 < t11; f11++) {
    const t12 = f11 * r16;
    for (let n15 = i11; n15 < r16; n15++)
      e8[t12 + n15] += e8[t12 + n15 - i11];
  }
  if (!a16)
    return e8;
  const l9 = new Uint8Array(e8.length), o10 = n14 * i11;
  for (let f11 = 0; f11 < t11; f11++) {
    const t12 = f11 * r16;
    for (let n15 = 0; n15 < o10; n15++)
      for (let a17 = 0; a17 < s14; a17++)
        l9[t12 + n15 * s14 + a17] = e8[t12 + n15 + (s14 - a17 - 1) * o10];
  }
  return new Float32Array(l9.buffer);
}
async function H(e8, t11) {
  const { headerInfo: n14, ifd: a16, offsets: i11, sizes: r16 } = t11, l9 = [];
  for (let s14 = 0; s14 < i11.length; s14++) {
    const t12 = await M2(e8, n14.littleEndian, a16, i11[s14], r16[s14] || e8.byteLength);
    l9.push(t12);
  }
  const o10 = D(a16, n14), f11 = p3(a16, "BITSPERSAMPLE"), u14 = h2(p3(a16, "SAMPLEFORMAT") ?? 1, f11), c11 = p3(a16, "SAMPLESPERPIXEL") || n14.planes, E4 = g(u14), T4 = p3(a16, "TILEWIDTH"), I5 = p3(a16, "TILELENGTH"), w6 = p3(a16, "COMPRESSION") ?? 1, d8 = T4 * I5;
  let S4;
  const y7 = [];
  let m8 = l9[0];
  const A4 = 34887 === w6;
  for (let s14 = 0; s14 < c11; s14++) {
    if (S4 = new E4(d8), l9.length === c11)
      m8 = l9[s14], m8.length === d8 && (S4 = m8);
    else if (m8.length)
      if (o10 || A4)
        S4 = m8.length === d8 ? m8 : m8.slice(d8 * s14, d8 * (s14 + 1));
      else
        for (let e9 = 0; e9 < d8; e9++)
          S4[e9] = m8[e9 * c11 + s14];
    y7.push(S4);
  }
  const P4 = n14.noData ? n14.noData[0] : t11.noDataValue, O3 = n14.metadata ? n14.metadata.statistics : null, x6 = O3 ? O3.map((e9) => e9.min) : null, L3 = O3 ? O3.map((e9) => e9.max) : null, R4 = { pixelType: u14, width: T4, height: I5, pixels: y7, noDataValue: P4 };
  return null != P4 ? u(R4, P4) : x6 && L3 && t11.applyMinMaxConstraint && (R4.mask = b(y7, x6, L3)), R4;
}
async function Y(e8, t11 = {}) {
  const n14 = t11.pyramidLevel || 0, a16 = t11.headerInfo || G(e8), { ifds: i11, noData: r16 } = a16;
  if (0 === i11.length)
    throw new Error("no valid image file directory");
  const l9 = V(a16);
  if (l9)
    throw l9;
  let o10 = null;
  const f11 = -1 === n14 ? i11[i11.length - 1] : i11[n14], u14 = r16 ?? t11.noDataValue;
  return o10 = a16.tileWidth ? await P(e8, a16, f11) : await O(e8, a16, f11), o10 ? (null != u14 && u(o10, u14), o10) : o10;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/RasterCodec.js
var f5 = function(t11) {
  var e8, a16, i11, s14, r16, n14;
  function o10(t12) {
    var e9, a17, i12, s15, r17, n15, o11, h10, c11, l9, p10, d8, u14;
    for (this.data = t12, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, r17 = null; ; ) {
      switch (e9 = this.readUInt32(), h10 = (function() {
        var t13, e10;
        for (e10 = [], t13 = 0; t13 < 4; ++t13)
          e10.push(String.fromCharCode(this.data[this.pos++]));
        return e10;
      }).call(this).join(""), h10) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e9);
          break;
        case "fcTL":
          r17 && this.animation.frames.push(r17), this.pos += 4, r17 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, s15 = this.readUInt16(), i12 = this.readUInt16() || 100, r17.delay = 1e3 * s15 / i12, r17.disposeOp = this.data[this.pos++], r17.blendOp = this.data[this.pos++], r17.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === h10 && (this.pos += 4, e9 -= 4), t12 = (null != r17 ? r17.data : void 0) || this.imgData, p10 = 0; 0 <= e9 ? p10 < e9 : p10 > e9; 0 <= e9 ? ++p10 : --p10)
            t12.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (this.transparency.indexed = this.read(e9), (c11 = 255 - this.transparency.indexed.length) > 0)
                for (d8 = 0; 0 <= c11 ? d8 < c11 : d8 > c11; 0 <= c11 ? ++d8 : --d8)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e9)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e9);
          }
          break;
        case "tEXt":
          n15 = (l9 = this.read(e9)).indexOf(0), o11 = String.fromCharCode.apply(String, l9.slice(0, n15)), this.text[o11] = String.fromCharCode.apply(String, l9.slice(n15 + 1));
          break;
        case "IEND":
          return r17 && this.animation.frames.push(r17), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (u14 = this.colorType) || 6 === u14, a17 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a17, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e9;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  return o10.load = function(t12, e9, a17) {
    var i12;
    return "function" == typeof e9 && (a17 = e9), (i12 = new XMLHttpRequest()).open("GET", t12, true), i12.responseType = "arraybuffer", i12.onload = function() {
      var t13;
      return t13 = new o10(new Uint8Array(i12.response || i12.mozResponseArrayBuffer)), "function" == typeof (null != e9 ? e9.getContext : void 0) && t13.render(e9), "function" == typeof a17 ? a17(t13) : void 0;
    }, i12.send(null);
  }, a16 = 1, i11 = 2, e8 = 0, o10.prototype.read = function(t12) {
    var e9, a17;
    for (a17 = [], e9 = 0; 0 <= t12 ? e9 < t12 : e9 > t12; 0 <= t12 ? ++e9 : --e9)
      a17.push(this.data[this.pos++]);
    return a17;
  }, o10.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o10.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o10.prototype.decodePixels = function(t12) {
    var e9, a17, i12, s15, r17, n15, o11, h10, l9, p10, d8, u14, f11, m8, g7, w6, y7, x6, b5, k5, T4, I5, C6;
    if (null == t12 && (t12 = this.imgData), 0 === t12.length)
      return new Uint8Array(0);
    for (t12 = (t12 = new f2(t12)).getBytes(), w6 = (u14 = this.pixelBitlength / 8) * this.width, f11 = new Uint8Array(w6 * this.height), n15 = t12.length, g7 = 0, m8 = 0, a17 = 0; m8 < n15; ) {
      switch (t12[m8++]) {
        case 0:
          for (s15 = b5 = 0; b5 < w6; s15 = b5 += 1)
            f11[a17++] = t12[m8++];
          break;
        case 1:
          for (s15 = k5 = 0; k5 < w6; s15 = k5 += 1)
            e9 = t12[m8++], r17 = s15 < u14 ? 0 : f11[a17 - u14], f11[a17++] = (e9 + r17) % 256;
          break;
        case 2:
          for (s15 = T4 = 0; T4 < w6; s15 = T4 += 1)
            e9 = t12[m8++], i12 = (s15 - s15 % u14) / u14, y7 = g7 && f11[(g7 - 1) * w6 + i12 * u14 + s15 % u14], f11[a17++] = (y7 + e9) % 256;
          break;
        case 3:
          for (s15 = I5 = 0; I5 < w6; s15 = I5 += 1)
            e9 = t12[m8++], i12 = (s15 - s15 % u14) / u14, r17 = s15 < u14 ? 0 : f11[a17 - u14], y7 = g7 && f11[(g7 - 1) * w6 + i12 * u14 + s15 % u14], f11[a17++] = (e9 + Math.floor((r17 + y7) / 2)) % 256;
          break;
        case 4:
          for (s15 = C6 = 0; C6 < w6; s15 = C6 += 1)
            e9 = t12[m8++], i12 = (s15 - s15 % u14) / u14, r17 = s15 < u14 ? 0 : f11[a17 - u14], 0 === g7 ? y7 = x6 = 0 : (y7 = f11[(g7 - 1) * w6 + i12 * u14 + s15 % u14], x6 = i12 && f11[(g7 - 1) * w6 + (i12 - 1) * u14 + s15 % u14]), o11 = r17 + y7 - x6, h10 = Math.abs(o11 - r17), p10 = Math.abs(o11 - y7), d8 = Math.abs(o11 - x6), l9 = h10 <= p10 && h10 <= d8 ? r17 : p10 <= d8 ? y7 : x6, f11[a17++] = (e9 + l9) % 256;
          break;
        default:
          throw new Error("Invalid filter algorithm: " + t12[m8 - 1]);
      }
      g7++;
    }
    return f11;
  }, o10.prototype.decodePalette = function() {
    var t12, e9, a17, i12, s15, r17, n15, o11, h10;
    for (a17 = this.palette, r17 = this.transparency.indexed || [], s15 = new Uint8Array((r17.length || 0) + a17.length), i12 = 0, a17.length, t12 = 0, e9 = n15 = 0, o11 = a17.length; n15 < o11; e9 = n15 += 3)
      s15[i12++] = a17[e9], s15[i12++] = a17[e9 + 1], s15[i12++] = a17[e9 + 2], s15[i12++] = null != (h10 = r17[t12++]) ? h10 : 255;
    return s15;
  }, o10.prototype.copyToImageData = function(t12, e9) {
    var a17, i12, s15, r17, n15, o11, h10, c11, l9, p10, d8;
    if (i12 = this.colors, l9 = null, a17 = this.hasAlphaChannel, this.palette.length && (l9 = null != (d8 = this._decodedPalette) ? d8 : this._decodedPalette = this.decodePalette(), i12 = 4, a17 = true), c11 = (s15 = t12.data || t12).length, n15 = l9 || e9, r17 = o11 = 0, 1 === i12)
      for (; r17 < c11; )
        h10 = l9 ? 4 * e9[r17 / 4] : o11, p10 = n15[h10++], s15[r17++] = p10, s15[r17++] = p10, s15[r17++] = p10, s15[r17++] = a17 ? n15[h10++] : this.transparency.grayscale && this.transparency.grayscale === p10 ? 0 : 255, o11 = h10;
    else
      for (; r17 < c11; )
        h10 = l9 ? 4 * e9[r17 / 4] : o11, s15[r17++] = n15[h10++], s15[r17++] = n15[h10++], s15[r17++] = n15[h10++], s15[r17++] = a17 ? n15[h10++] : this.transparency.rgb && this.transparency.rgb[1] === n15[h10 - 3] && this.transparency.rgb[3] === n15[h10 - 2] && this.transparency.rgb[5] === n15[h10 - 1] ? 0 : 255, o11 = h10;
  }, o10.prototype.decode = function() {
    var t12;
    return t12 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t12, this.decodePixels()), t12;
  }, r16 = t11.document && t11.document.createElement("canvas"), n14 = r16 && r16.getContext("2d"), s14 = function(t12) {
    var e9;
    return n14.width = t12.width, n14.height = t12.height, n14.clearRect(0, 0, t12.width, t12.height), n14.putImageData(t12, 0, 0), (e9 = new Image()).src = r16.toDataURL(), e9;
  }, o10.prototype.decodeFrames = function(t12) {
    var e9, a17, i12, r17, n15, o11, h10, c11;
    if (this.animation) {
      for (c11 = [], a17 = n15 = 0, o11 = (h10 = this.animation.frames).length; n15 < o11; a17 = ++n15)
        e9 = h10[a17], i12 = t12.createImageData(e9.width, e9.height), r17 = this.decodePixels(new Uint8Array(e9.data)), this.copyToImageData(i12, r17), e9.imageData = i12, c11.push(e9.image = s14(i12));
      return c11;
    }
  }, o10.prototype.renderFrame = function(t12, s15) {
    var r17, n15, o11;
    return r17 = (n15 = this.animation.frames)[s15], o11 = n15[s15 - 1], 0 === s15 && t12.clearRect(0, 0, this.width, this.height), (null != o11 ? o11.disposeOp : void 0) === a16 ? t12.clearRect(o11.xOffset, o11.yOffset, o11.width, o11.height) : (null != o11 ? o11.disposeOp : void 0) === i11 && t12.putImageData(o11.imageData, o11.xOffset, o11.yOffset), r17.blendOp === e8 && t12.clearRect(r17.xOffset, r17.yOffset, r17.width, r17.height), t12.drawImage(r17.image, r17.xOffset, r17.yOffset);
  }, o10.prototype.animate = function(t12) {
    var e9, a17, i12, s15, r17, n15, o11 = this;
    return a17 = 0, n15 = this.animation, s15 = n15.numFrames, i12 = n15.frames, r17 = n15.numPlays, (e9 = function() {
      var n16, h10;
      if (n16 = a17++ % s15, h10 = i12[n16], o11.renderFrame(t12, n16), s15 > 1 && a17 / s15 < r17)
        return o11.animation._timeout = setTimeout(e9, h10.delay);
    })();
  }, o10.prototype.stopAnimation = function() {
    var t12;
    return clearTimeout(null != (t12 = this.animation) ? t12._timeout : void 0);
  }, o10.prototype.render = function(t12) {
    var e9, a17;
    return t12._png && t12._png.stopAnimation(), t12._png = this, t12.width = this.width, t12.height = this.height, e9 = t12.getContext("2d"), this.animation ? (this.decodeFrames(e9), this.animate(e9)) : (a17 = e9.createImageData(this.width, this.height), this.copyToImageData(a17, this.decodePixels()), e9.putImageData(a17, 0, 0));
  }, o10;
}(self);
var m2 = /* @__PURE__ */ new Set(["jpg", "png", "bmp", "gif"]);
async function g2(e8, i11) {
  if (!r10)
    throw new s2("rasterCoded:decode", "lerc decoder is not supported on big endian platform");
  await a6();
  const { offset: s14 } = i11, { width: o10, height: h10, pixelType: c11, statistics: l9, depthCount: p10, noDataValues: d8, bandMasks: f11, pixels: m8, mask: g7 } = c3(e8, { inputOffset: s14, returnInterleaved: i11.returnInterleaved });
  return new u2({ width: o10, height: h10, pixelType: c11.toLowerCase(), pixels: m8, mask: g7, statistics: l9, bandMasks: f11, depthCount: p10, noDataValues: d8 });
}
async function w2(t11, i11) {
  const s14 = await Y(t11, { ...i11, noDataValue: null });
  r(s14);
  const r16 = new u2({ width: s14.width, height: s14.height, pixels: s14.pixels, pixelType: s14.pixelType.toLowerCase(), mask: s14.mask, statistics: null });
  return r16.updateStatistics(), r16;
}
async function y4(t11, e8) {
  const i11 = await H(t11, e8.customOptions), s14 = new u2({ width: i11.width, height: i11.height, pixels: i11.pixels, pixelType: i11.pixelType.toLowerCase(), mask: i11.mask, statistics: null });
  return s14.updateStatistics(), s14;
}
function x3(t11, e8) {
  const i11 = e8.pixelType || "u8", s14 = u2.getPixelArrayConstructor(i11), r16 = "u8" === i11 ? t11 : new s14(t11.buffer), n14 = [], o10 = e8.planes || 1;
  if (1 === o10)
    n14.push(r16);
  else
    for (let a16 = 0; a16 < o10; a16++) {
      const i12 = (e8.width || 1) * (e8.height || t11.length), h11 = new s14(i12);
      for (let t12 = 0; t12 < i12; t12++)
        h11[t12] = r16[t12 * o10 + a16];
      n14.push(h11);
    }
  const h10 = new u2({ width: e8.width || 1, height: e8.height || t11.length, pixels: n14, pixelType: i11, statistics: null });
  return h10.updateStatistics(), h10;
}
function b2(t11, e8) {
  return x3(new f2(new Uint8Array(t11)).getBytes(), e8);
}
function k2(t11, e8) {
  return x3(i4(t11, e8.offset, e8.eof, !e8.isInputBigEndian), e8);
}
function T2(t11, e8, i11) {
  const { pixelTypeCtor: s14 } = D2(e8.pixelType), r16 = (0, a7.decode)(t11, { width: e8.width, height: e8.height, pixelType: s14, format: i11 }), n14 = new u2({ width: e8.width, height: e8.height, pixels: r16.pixels, pixelType: e8.pixelType, mask: r16.mask, statistics: null });
  return n14.updateStatistics(), n14;
}
function I2(t11, e8) {
  const i11 = r5.decode(t11, e8.hasNoZlibMask ?? void 0), r16 = new u2({ width: i11.width, height: i11.height, pixels: i11.pixels, pixelType: "U8", mask: i11.mask, statistics: null });
  return r16.updateStatistics(), r16;
}
function C2(t11, e8) {
  const i11 = new Uint8Array(t11), s14 = new f5(i11), { width: r16, height: n14 } = e8, o10 = r16 * n14, h10 = s14.decode();
  let c11, l9 = 0, p10 = 0;
  const d8 = new Uint8Array(o10);
  for (l9 = 0; l9 < o10; l9++)
    d8[l9] = h10[4 * l9 + 3];
  const u14 = new u2({ width: r16, height: n14, pixels: [], pixelType: "U8", mask: d8, statistics: [] });
  for (l9 = 0; l9 < 3; l9++) {
    for (c11 = new Uint8Array(o10), p10 = 0; p10 < o10; p10++)
      c11[p10] = h10[4 * p10 + l9];
    u14.addData({ pixels: c11 });
  }
  return u14.updateStatistics(), u14;
}
async function v3(t11, e8, s14, r16) {
  const n14 = new i2(), o10 = { applyJpegMask: false, format: e8, ...s14 }, h10 = await n14.decode(t11, o10, r16), c11 = new u2(h10);
  return c11.updateStatistics(), c11;
}
function U2(e8) {
  if (null == e8)
    throw new s2("rasterCodec:decode", "parameter encodeddata is required.");
  const a16 = new Uint8Array(e8, 0, 10);
  let i11 = "";
  return 255 === a16[0] && 216 === a16[1] ? i11 = "jpg" : 137 === a16[0] && 80 === a16[1] && 78 === a16[2] && 71 === a16[3] ? i11 = "png" : 67 === a16[0] && 110 === a16[1] && 116 === a16[2] && 90 === a16[3] && 73 === a16[4] && 109 === a16[5] && 97 === a16[6] && 103 === a16[7] && 101 === a16[8] && 32 === a16[9] ? i11 = "lerc" : 76 === a16[0] && 101 === a16[1] && 114 === a16[2] && 99 === a16[3] && 50 === a16[4] && 32 === a16[5] ? i11 = "lerc2" : 73 === a16[0] && 73 === a16[1] && 42 === a16[2] && 0 === a16[3] || 77 === a16[0] && 77 === a16[1] && 0 === a16[2] && 42 === a16[3] || 73 === a16[0] && 73 === a16[1] && 43 === a16[2] && 0 === a16[3] || 77 === a16[0] && 77 === a16[1] && 0 === a16[2] && 43 === a16[3] ? i11 = "tiff" : 71 === a16[0] && 73 === a16[1] && 70 === a16[2] ? i11 = "gif" : 66 === a16[0] && 77 === a16[1] ? i11 = "bmp" : String.fromCharCode.apply(null, a16).toLowerCase().includes("error") && (i11 = "error"), i11;
}
function A2(e8) {
  let a16 = null;
  switch (e8) {
    case "lerc":
    case "lerc2":
      a16 = g2;
      break;
    case "jpg":
      a16 = I2;
      break;
    case "png":
      a16 = C2;
      break;
    case "bsq":
    case "bip":
      a16 = (t11, a17) => T2(t11, a17, e8);
      break;
    case "tiff":
      a16 = w2;
      break;
    case "deflate":
      a16 = b2;
      break;
    case "lzw":
      a16 = k2;
      break;
    case "error":
      a16 = () => {
        throw new s2("rasterCodec:decode", "input data contains error");
      };
      break;
    default:
      a16 = () => {
        throw new s2("rasterCodec:decode", "unsupported raster format");
      };
  }
  return a16;
}
function D2(t11) {
  let e8 = null, a16 = null;
  switch (t11 ? t11.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      a16 = 255, e8 = Uint8Array;
      break;
    case "u16":
      a16 = a16 || 65535, e8 = Uint16Array;
      break;
    case "u32":
      a16 = a16 || 2 ** 32 - 1, e8 = Uint32Array;
      break;
    case "s8":
      a16 = a16 || -128, e8 = Int8Array;
      break;
    case "s16":
      a16 = a16 || -32768, e8 = Int16Array;
      break;
    case "s32":
      a16 = a16 || 0 - 2 ** 31, e8 = Int32Array;
      break;
    default:
      e8 = Float32Array;
  }
  return { pixelTypeCtor: e8, noDataValue: a16 };
}
function O2(t11, e8 = 1) {
  if (!t11)
    return;
  const { pixels: i11, width: s14, height: r16, mask: n14 } = t11;
  if (!i11 || 0 === i11.length)
    return;
  const o10 = i11.length, h10 = s14 - 1, c11 = r16 - 1, l9 = [];
  let p10, d8, u14, f11, m8, g7, w6 = null;
  const y7 = u2.getPixelArrayConstructor(t11.pixelType);
  if (0 === e8) {
    for (p10 = 0; p10 < o10; p10++) {
      for (m8 = i11[p10], g7 = new y7(h10 * c11), d8 = 0; d8 < c11; d8++)
        for (f11 = d8 * s14, u14 = 0; u14 < h10; u14++)
          g7[d8 * h10 + u14] = m8[f11 + u14];
      l9.push(g7);
    }
    if (null != n14)
      for (w6 = new Uint8Array(h10 * c11), d8 = 0; d8 < c11; d8++)
        for (f11 = d8 * s14, u14 = 0; u14 < h10; u14++)
          w6[d8 * h10 + u14] = n14[f11 + u14];
  } else {
    for (p10 = 0; p10 < o10; p10++) {
      for (m8 = i11[p10], g7 = new y7(h10 * c11), d8 = 0; d8 < c11; d8++)
        for (f11 = d8 * s14, u14 = 0; u14 < h10; u14++)
          g7[d8 * h10 + u14] = (m8[f11 + u14] + m8[f11 + u14 + 1] + m8[f11 + s14 + u14] + m8[f11 + s14 + u14 + 1]) / 4;
      l9.push(g7);
    }
    if (n14)
      for (w6 = new Uint8Array(h10 * c11), d8 = 0; d8 < c11; d8++)
        for (f11 = d8 * s14, u14 = 0; u14 < h10; u14++)
          w6[d8 * h10 + u14] = Math.min.apply(null, [n14[f11 + u14], n14[f11 + u14 + 1], n14[f11 + s14 + u14], n14[f11 + s14 + u14 + 1]]);
  }
  t11.width = h10, t11.height = c11, t11.mask = w6, t11.pixels = l9;
}
function P2(t11) {
  let e8 = U2(t11);
  return "lerc2" === e8 ? e8 = "lerc" : "error" === e8 && (e8 = ""), e8;
}
async function j(e8, a16 = {}, i11) {
  if (null == e8)
    throw new s2("rasterCodec:decode", "missing encodeddata parameter.");
  let s14 = a16.format && a16.format.toLowerCase();
  if (!("bsq" !== s14 && "bip" !== s14 || null != a16.width && null != a16.height))
    throw new s2("rasterCodec:decode", "requires width and height in options parameter.");
  if ("tiff" === s14 && a16.customOptions)
    return y4(e8, a16);
  if ((!s14 || "bsq" !== s14 && "bip" !== s14 && "deflate" !== s14 && "lzw" !== s14) && (s14 = U2(e8)), a16.useCanvas && m2.has(s14))
    return v3(e8, s14, a16, i11);
  const r16 = A2(s14);
  a16.isPoint && (null != (a16 = { ...a16 }).width && a16.width++, null != a16.height && a16.height++);
  const n14 = await r16(e8, a16);
  return n14 ? ("jpg" !== s14 && null != a16.noDataValue && 1 === n14.depthCount && u(n14, a16.noDataValue, { customFloatTolerance: a16.tolerance }), a16.isPoint && O2(n14), n14) : n14;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
var n6;
var l4;
!function(t11) {
  t11[t11.matchAny = 0] = "matchAny", t11[t11.matchAll = 1] = "matchAll";
}(n6 || (n6 = {})), function(t11) {
  t11[t11.bestMatch = 0] = "bestMatch", t11[t11.fail = 1] = "fail";
}(l4 || (l4 = {}));
var i6 = 6;
function o4(t11) {
  return null != t11 && "esri.layers.support.PixelBlock" === t11.declaredClass && t11.pixels && t11.pixels.length > 0;
}
function r11(e8) {
  var _a;
  if (!(e8 == null ? void 0 : e8.length) || e8.some((t11) => !o4(t11)))
    return null;
  if (1 === e8.length)
    return ((_a = e8[0]) == null ? void 0 : _a.clone()) ?? null;
  const n14 = e8, { width: l9, height: i11, pixelType: s14 } = n14[0];
  if (n14.some((t11) => t11.width !== l9 || t11.height !== i11))
    return null;
  const r16 = n14.map(({ mask: t11 }) => t11).filter((t11) => null != t11);
  let a16 = null;
  r16.length && (a16 = new Uint8Array(l9 * i11), a16.set(r16[0]), r16.length > 1 && m3(r16.slice(1), a16));
  const h10 = [];
  n14.forEach(({ pixels: t11 }) => h10.push(...t11));
  const f11 = n14.map(({ statistics: t11 }) => t11).filter((t11) => t11 == null ? void 0 : t11.length), c11 = [];
  return f11.forEach((t11) => c11.push(...t11)), new u2({ pixelType: s14, width: l9, height: i11, mask: a16, pixels: h10, statistics: c11.length ? c11 : null });
}
function a8(t11) {
  if (!t11)
    return;
  const e8 = t11.colormap;
  if (!e8 || 0 === e8.length)
    return;
  const n14 = e8.sort((t12, e9) => t12[0] - e9[0]);
  let l9 = 0;
  n14[0][0] < 0 && (l9 = n14[0][0]);
  const i11 = Math.max(256, n14[n14.length - 1][0] - l9 + 1), o10 = new Uint8Array(4 * i11), s14 = [];
  let r16, a16 = 0, h10 = 0;
  const f11 = 5 === n14[0].length;
  if (i11 > 65536)
    return n14.forEach((t12) => {
      s14[t12[0] - l9] = f11 ? t12.slice(1) : t12.slice(1).concat([255]);
    }), { indexed2DColormap: s14, offset: l9, alphaSpecified: f11 };
  if (t11.fillUnspecified)
    for (r16 = n14[h10], a16 = r16[0] - l9; a16 < i11; a16++)
      o10[4 * a16] = r16[1], o10[4 * a16 + 1] = r16[2], o10[4 * a16 + 2] = r16[3], o10[4 * a16 + 3] = f11 ? r16[4] : 255, a16 === r16[0] - l9 && (r16 = h10 === n14.length - 1 ? r16 : n14[++h10]);
  else
    for (a16 = 0; a16 < n14.length; a16++)
      r16 = n14[a16], h10 = 4 * (r16[0] - l9), o10[h10] = r16[1], o10[h10 + 1] = r16[2], o10[h10 + 2] = r16[3], o10[h10 + 3] = f11 ? r16[4] : 255;
  return { indexedColormap: o10, offset: l9, alphaSpecified: f11 };
}
function h3(t11, e8) {
  if (!o4(t11))
    return t11;
  if (!e8 || !e8.indexedColormap && !e8.indexed2DColormap)
    return t11;
  const n14 = t11.clone(), l9 = n14.pixels;
  let i11 = n14.mask;
  const s14 = n14.width * n14.height;
  if (1 !== l9.length)
    return t11;
  const { indexedColormap: r16, indexed2DColormap: a16, offset: h10, alphaSpecified: f11 } = e8;
  let c11 = 0;
  const u14 = l9[0], p10 = new Uint8Array(u14.length), x6 = new Uint8Array(u14.length), d8 = new Uint8Array(u14.length);
  let m8, g7 = 0;
  if (r16) {
    const t12 = r16.length - 1;
    if (null != i11)
      for (c11 = 0; c11 < s14; c11++)
        i11[c11] && (g7 = 4 * (u14[c11] - h10), g7 < h10 || g7 > t12 ? i11[c11] = 0 : (p10[c11] = r16[g7], x6[c11] = r16[g7 + 1], d8[c11] = r16[g7 + 2], i11[c11] = r16[g7 + 3]));
    else {
      for (i11 = new Uint8Array(s14), c11 = 0; c11 < s14; c11++)
        g7 = 4 * (u14[c11] - h10), g7 < h10 || g7 > t12 ? i11[c11] = 0 : (p10[c11] = r16[g7], x6[c11] = r16[g7 + 1], d8[c11] = r16[g7 + 2], i11[c11] = r16[g7 + 3]);
      n14.mask = i11;
    }
  } else if (a16)
    if (null != i11)
      for (c11 = 0; c11 < s14; c11++)
        i11[c11] && (m8 = a16[u14[c11]], p10[c11] = m8[0], x6[c11] = m8[1], d8[c11] = m8[2], i11[c11] = m8[3]);
    else {
      for (i11 = new Uint8Array(s14), c11 = 0; c11 < s14; c11++)
        m8 = a16[u14[c11]], p10[c11] = m8[0], x6[c11] = m8[1], d8[c11] = m8[2], i11[c11] = m8[3];
      n14.mask = i11;
    }
  return n14.pixels = [p10, x6, d8], n14.statistics = null, n14.pixelType = "u8", n14.maskIsAlpha = f11, n14;
}
function f6(e8, n14) {
  if (!o4(e8))
    return null;
  const { pixels: l9, mask: i11 } = e8, s14 = l9.length;
  let r16 = n14.lut;
  const { offset: a16 } = n14;
  r16 && 1 === r16[0].length && (r16 = l9.map(() => r16));
  const h10 = [], f11 = n14.outputPixelType || "u8";
  for (let t11 = 0; t11 < s14; t11++) {
    const e9 = c5(l9[t11], i11, r16[t11], a16 || 0, f11);
    h10.push(e9);
  }
  const u14 = new u2({ width: e8.width, height: e8.height, pixels: h10, mask: i11, pixelType: f11 });
  return u14.updateStatistics(), u14;
}
function c5(e8, n14, l9, i11, o10) {
  const s14 = e8.length, r16 = u2.createEmptyBand(o10, s14);
  if (n14)
    for (let t11 = 0; t11 < s14; t11++)
      n14[t11] && (r16[t11] = l9[e8[t11] - i11]);
  else
    for (let t11 = 0; t11 < s14; t11++)
      r16[t11] = l9[e8[t11] - i11];
  return r16;
}
function u5(t11, e8) {
  if (!o4(t11))
    return null;
  const n14 = t11.clone(), { pixels: l9 } = n14, i11 = n14.width * n14.height, s14 = e8.length, r16 = Math.floor(s14 / 2), a16 = e8[Math.floor(r16)], h10 = l9[0];
  let f11, c11, u14, p10, x6, d8, m8 = false;
  const g7 = new Uint8Array(i11), y7 = new Uint8Array(i11), w6 = new Uint8Array(i11);
  let k5 = n14.mask;
  const M6 = 4 === e8[0].mappedColor.length;
  for (k5 || (k5 = new Uint8Array(i11), k5.fill(M6 ? 255 : 1), n14.mask = k5), x6 = 0; x6 < i11; x6++)
    if (k5[x6]) {
      for (f11 = h10[x6], m8 = false, d8 = r16, c11 = a16, u14 = 0, p10 = s14 - 1; p10 - u14 > 1; ) {
        if (f11 === c11.value) {
          m8 = true;
          break;
        }
        f11 > c11.value ? u14 = d8 : p10 = d8, d8 = Math.floor((u14 + p10) / 2), c11 = e8[Math.floor(d8)];
      }
      m8 || (f11 === e8[u14].value ? (c11 = e8[u14], m8 = true) : f11 === e8[p10].value ? (c11 = e8[p10], m8 = true) : f11 < e8[u14].value ? (m8 = false, c11 = null) : f11 > e8[u14].value && (f11 < e8[p10].value ? (c11 = e8[u14], m8 = true) : p10 === s14 - 1 ? (m8 = false, c11 = null) : (c11 = e8[p10], m8 = true))), m8 ? (g7[x6] = c11.mappedColor[0], y7[x6] = c11.mappedColor[1], w6[x6] = c11.mappedColor[2], k5[x6] = c11.mappedColor[3]) : g7[x6] = y7[x6] = w6[x6] = k5[x6] = 0;
    }
  return n14.pixels = [g7, y7, w6], n14.mask = k5, n14.pixelType = "u8", n14.maskIsAlpha = M6, n14;
}
function p4(n14, l9) {
  if (!o4(n14))
    return null;
  const { width: i11, height: s14 } = n14, { inputRanges: r16, outputValues: a16, outputPixelType: h10, noDataRanges: f11, allowUnmatched: c11, isLastInputRangeInclusive: u14 } = l9, p10 = n14.pixels[0], x6 = u2.createEmptyBand(h10, p10.length), d8 = n14.mask, m8 = new Uint8Array(i11 * s14);
  d8 ? m8.set(d8) : m8.fill(255);
  const g7 = n14.pixelType.startsWith("f") ? 1e-6 : 0, y7 = r16.map((t11) => t11 - g7);
  y7[0] = r16[0], y7[y7.length - 1] = r16[r16.length - 1] + (u14 ? 1e-6 : 0);
  const w6 = r16.length / 2, [k5, M6] = s6(h10);
  for (let t11 = 0; t11 < s14; t11++)
    for (let e8 = 0; e8 < i11; e8++) {
      const n15 = t11 * i11 + e8;
      if (m8[n15]) {
        const t12 = p10[n15];
        let e9 = false;
        for (let l10 = w6 - 1; l10 >= 0; l10--)
          if (t12 === y7[2 * l10] || t12 > y7[2 * l10] && t12 < y7[2 * l10 + 1]) {
            x6[n15] = a16[l10], e9 = true;
            break;
          }
        e9 || (c11 ? x6[n15] = t12 > M6 ? M6 : t12 < k5 ? k5 : t12 : m8[n15] = 0);
      }
    }
  const A4 = f11 == null ? void 0 : f11.length;
  if (A4)
    for (let t11 = 0; t11 < s14; t11++)
      for (let e8 = 0; e8 < i11; e8++) {
        const n15 = t11 * i11 + e8;
        if (!d8 || d8[n15]) {
          const t12 = p10[n15];
          for (let e9 = 0; e9 < A4; e9 += 2)
            if (t12 >= f11[e9] && t12 <= f11[e9 + 1]) {
              x6[n15] = 0, m8[n15] = 0;
              break;
            }
        }
      }
  return new u2({ width: i11, height: s14, pixelType: h10, pixels: [x6], mask: m8 });
}
function x4(t11, e8, n14, l9) {
  const i11 = null != n14 && n14.length >= 2 ? new Set(n14) : null, o10 = 1 === (n14 == null ? void 0 : n14.length) ? n14[0] : null, s14 = !!(e8 == null ? void 0 : e8.length);
  for (let r16 = 0; r16 < t11.length; r16++)
    if (l9[r16]) {
      const n15 = t11[r16];
      if (s14) {
        let t12 = false;
        for (let l10 = 0; l10 < e8.length; l10 += 2)
          if (n15 >= e8[l10] && n15 <= e8[l10 + 1]) {
            t12 = true;
            break;
          }
        t12 || (l9[r16] = 0);
      }
      l9[r16] && (n15 === o10 || (i11 == null ? void 0 : i11.has(n15))) && (l9[r16] = 0);
    }
}
function d2(t11, e8) {
  const n14 = t11[0].length;
  for (let l9 = 0; l9 < n14; l9++)
    if (e8[l9]) {
      let n15 = false;
      for (let e9 = 0; e9 < t11.length; e9++)
        if (t11[e9][l9]) {
          n15 = true;
          break;
        }
      n15 || (e8[l9] = 0);
    }
}
function m3(t11, e8) {
  const n14 = t11[0].length;
  for (let l9 = 0; l9 < n14; l9++)
    if (e8[l9]) {
      let n15 = false;
      for (let e9 = 0; e9 < t11.length; e9++)
        if (0 === t11[e9][l9]) {
          n15 = true;
          break;
        }
      n15 && (e8[l9] = 0);
    }
}
function g3(e8, n14) {
  if (!o4(e8))
    return null;
  const { width: l9, height: i11, pixels: s14 } = e8, r16 = l9 * i11, a16 = new Uint8Array(r16);
  e8.mask ? a16.set(e8.mask) : a16.fill(255);
  const h10 = s14.length, { includedRanges: f11, noDataValues: u14, outputPixelType: p10, matchAll: g7, lookups: y7 } = n14;
  if (y7) {
    const t11 = [];
    for (let e9 = 0; e9 < h10; e9++) {
      const n15 = y7[e9], l10 = c5(s14[e9], a16, n15.lut, n15.offset || 0, "u8");
      t11.push(l10);
    }
    1 === t11.length ? a16.set(t11[0]) : g7 ? d2(t11, a16) : m3(t11, a16);
  } else if (g7) {
    const t11 = [];
    for (let e9 = 0; e9 < h10; e9++) {
      const n15 = new Uint8Array(r16);
      n15.set(a16), x4(s14[e9], f11 == null ? void 0 : f11.slice(2 * e9, 2 * e9 + 2), u14 == null ? void 0 : u14[e9], n15), t11.push(n15);
    }
    1 === t11.length ? a16.set(t11[0]) : d2(t11, a16);
  } else
    for (let t11 = 0; t11 < h10; t11++)
      x4(s14[t11], f11 == null ? void 0 : f11.slice(2 * t11, 2 * t11 + 2), u14 == null ? void 0 : u14[t11], a16);
  return new u2({ width: l9, height: i11, pixelType: p10, pixels: s14, mask: a16 });
}
function y5(n14) {
  const { srcPixelType: l9, inputRanges: i11, outputValues: o10, allowUnmatched: s14, noDataRanges: r16, isLastInputRangeInclusive: a16, outputPixelType: h10 } = n14;
  if ("u8" !== l9 && "s8" !== l9 && "u16" !== l9 && "s16" !== l9)
    return null;
  const f11 = l9.includes("16") ? 65536 : 256, c11 = l9.includes("s") ? -f11 / 2 : 0, u14 = u2.createEmptyBand(h10, f11), p10 = new Uint8Array(f11);
  s14 && p10.fill(255);
  const [x6, d8] = s6(h10);
  if ((i11 == null ? void 0 : i11.length) && (o10 == null ? void 0 : o10.length)) {
    const t11 = 1e-6, e8 = i11.map((e9) => e9 - t11);
    e8[0] = i11[0], a16 && (e8[e8.length - 1] = i11[i11.length - 1]);
    for (let n15 = 0; n15 < e8.length; n15++) {
      const t12 = o10[n15] > d8 ? d8 : o10[n15] < x6 ? x6 : o10[n15], l10 = Math.ceil(e8[2 * n15] - c11), i12 = Math.floor(e8[2 * n15 + 1] - c11);
      for (let e9 = l10; e9 <= i12; e9++)
        u14[e9] = t12, p10[e9] = 255;
    }
  }
  if (r16 == null ? void 0 : r16.length)
    for (let t11 = 0; t11 < r16.length; t11++) {
      const e8 = Math.ceil(r16[2 * t11] - c11), n15 = Math.floor(r16[2 * t11 + 1] - c11);
      for (let t12 = e8; t12 <= n15; t12++)
        p10[t12] = 0;
    }
  return { lut: u14, offset: c11, mask: p10 };
}
function w3(t11, e8, n14) {
  if ("u8" !== t11 && "s8" !== t11 && "u16" !== t11 && "s16" !== t11)
    return null;
  const l9 = t11.includes("16") ? 65536 : 256, i11 = t11.includes("s") ? -l9 / 2 : 0, o10 = new Uint8Array(l9);
  if (e8)
    for (let s14 = 0; s14 < e8.length; s14++) {
      const t12 = Math.ceil(e8[2 * s14] - i11), n15 = Math.floor(e8[2 * s14 + 1] - i11);
      for (let e9 = t12; e9 <= n15; e9++)
        o10[e9] = 255;
    }
  else
    o10.fill(255);
  if (n14)
    for (let s14 = 0; s14 < n14.length; s14++)
      o10[n14[s14] - i11] = 0;
  return { lut: o10, offset: i11 };
}
function k3(t11, e8, n14, l9, i11, o10, s14, r16) {
  return { xmin: i11 <= n14 * t11 ? 0 : i11 < n14 * t11 + t11 ? i11 - n14 * t11 : t11, ymin: o10 <= l9 * e8 ? 0 : o10 < l9 * e8 + e8 ? o10 - l9 * e8 : e8, xmax: i11 + s14 <= n14 * t11 ? 0 : i11 + s14 < n14 * t11 + t11 ? i11 + s14 - n14 * t11 : t11, ymax: o10 + r16 <= l9 * e8 ? 0 : o10 + r16 < l9 * e8 + e8 ? o10 + r16 - l9 * e8 : e8 };
}
function A3(t11, e8, n14, l9, i11, o10) {
  const { width: s14, height: r16 } = n14.block, { x: a16, y: h10 } = n14.offset, { width: f11, height: c11 } = n14.mosaic, u14 = k3(s14, r16, l9, i11, a16, h10, f11, c11);
  let p10 = 0, x6 = 0;
  if (o10) {
    const t12 = o10.hasGCSSShiftTransform ? 360 : o10.halfWorldWidth ?? 0, e9 = s14 * o10.resolutionX, n15 = o10.startX + l9 * e9;
    n15 < t12 && n15 + e9 > t12 ? x6 = o10.rightPadding : n15 >= t12 && (p10 = o10.leftMargin - o10.rightPadding, x6 = 0);
  }
  if (u14.xmax -= x6, "number" != typeof e8)
    for (let d8 = u14.ymin; d8 < u14.ymax; d8++) {
      const n15 = (i11 * r16 + d8 - h10) * f11 + (l9 * s14 - a16) + p10, o11 = d8 * s14;
      for (let l10 = u14.xmin; l10 < u14.xmax; l10++)
        t11[n15 + l10] = e8[o11 + l10];
    }
  else
    for (let d8 = u14.ymin; d8 < u14.ymax; d8++) {
      const n15 = (i11 * r16 + d8 - h10) * f11 + (l9 * s14 - a16) + p10;
      for (let l10 = u14.xmin; l10 < u14.xmax; l10++)
        t11[n15 + l10] = e8;
    }
}
function U3(e8, n14, l9 = {}) {
  var _a;
  const { clipOffset: i11, clipSize: s14, alignmentInfo: r16, blockWidths: a16 } = l9;
  if (a16)
    return b3(e8, n14, { blockWidths: a16 });
  const h10 = e8.find((t11) => o4(t11));
  if (null == h10)
    return null;
  const f11 = s14 ? s14.width : n14.width, c11 = s14 ? s14.height : n14.height, u14 = h10.width, p10 = h10.height, x6 = n14.width / u14, d8 = n14.height / p10, m8 = { offset: i11 || { x: 0, y: 0 }, mosaic: s14 || n14, block: { width: u14, height: p10 } }, g7 = h10.pixelType, y7 = u2.getPixelArrayConstructor(g7), w6 = h10.pixels.length, k5 = [];
  let M6, U4;
  for (let t11 = 0; t11 < w6; t11++) {
    U4 = new y7(f11 * c11);
    for (let n15 = 0; n15 < d8; n15++)
      for (let l10 = 0; l10 < x6; l10++) {
        const i12 = e8[n15 * x6 + l10];
        o4(i12) && (M6 = i12.pixels[t11], A3(U4, M6, m8, l10, n15, r16));
      }
    k5.push(U4);
  }
  const T4 = e8.some((t11) => null == t11 || null != t11.mask && t11.mask.length > 0), v6 = e8.some((t11) => null != t11 && t11.bandMasks && t11.bandMasks.length > 1), C6 = T4 ? new Uint8Array(f11 * c11) : void 0, B4 = v6 ? [] : void 0;
  if (C6) {
    for (let t11 = 0; t11 < d8; t11++)
      for (let n15 = 0; n15 < x6; n15++) {
        const l10 = e8[t11 * x6 + n15], i12 = null != l10 ? l10.mask : null;
        A3(C6, null != i12 ? i12 : l10 ? 255 : 0, m8, n15, t11, r16);
      }
    if (B4)
      for (let t11 = 0; t11 < w6; t11++) {
        const n15 = new Uint8Array(f11 * c11);
        for (let l10 = 0; l10 < d8; l10++)
          for (let i12 = 0; i12 < x6; i12++) {
            const o10 = e8[l10 * x6 + i12], s15 = ((_a = o10 == null ? void 0 : o10.bandMasks) == null ? void 0 : _a[t11]) ?? (o10 == null ? void 0 : o10.mask);
            A3(n15, null != s15 ? s15 : o10 ? 255 : 0, m8, i12, l10, r16);
          }
        B4.push(n15);
      }
  }
  const S4 = new u2({ width: f11, height: c11, pixels: k5, pixelType: g7, bandMasks: B4, mask: C6 });
  return S4.updateStatistics(), S4;
}
function b3(e8, n14, l9) {
  var _a;
  const i11 = e8.find((t11) => null != t11);
  if (null == i11)
    return null;
  const s14 = e8.some((t11) => null == t11 || !!t11.mask), { width: r16, height: a16 } = n14, h10 = s14 ? new Uint8Array(r16 * a16) : null, { blockWidths: f11 } = l9, c11 = [], u14 = i11.getPlaneCount(), p10 = u2.getPixelArrayConstructor(i11.pixelType);
  if (s14)
    for (let t11 = 0, y7 = 0; t11 < e8.length; y7 += f11[t11], t11++) {
      const n15 = e8[t11];
      if (!o4(n15))
        continue;
      const l10 = n15.mask;
      for (let e9 = 0; e9 < a16; e9++)
        for (let i12 = 0; i12 < f11[t11]; i12++)
          h10[e9 * r16 + i12 + y7] = null == l10 ? 255 : l10[e9 * n15.width + i12];
    }
  const x6 = e8.some((t11) => null != t11 && t11.bandMasks && t11.bandMasks.length > 1), d8 = x6 ? [] : void 0, m8 = r16 * a16;
  for (let t11 = 0; t11 < u14; t11++) {
    const n15 = new p10(m8), l10 = x6 ? new Uint8Array(m8) : void 0;
    for (let i12 = 0, s15 = 0; i12 < e8.length; s15 += f11[i12], i12++) {
      const h11 = e8[i12];
      if (!o4(h11))
        continue;
      const c12 = h11.pixels[t11];
      if (null != c12) {
        for (let t12 = 0; t12 < a16; t12++)
          for (let e9 = 0; e9 < f11[i12]; e9++)
            n15[t12 * r16 + e9 + s15] = c12[t12 * h11.width + e9];
        if (l10) {
          const e9 = ((_a = h11.bandMasks) == null ? void 0 : _a[t11]) ?? h11.mask;
          for (let t12 = 0; t12 < a16; t12++)
            for (let n16 = 0; n16 < f11[i12]; n16++)
              l10[t12 * r16 + n16 + s15] = e9 ? e9[t12 * h11.width + n16] : 255;
        }
      }
    }
    c11.push(n15), d8 && l10 && d8.push(l10);
  }
  const g7 = new u2({ width: r16, height: a16, mask: h10, bandMasks: d8, pixels: c11, pixelType: i11.pixelType });
  return g7.updateStatistics(), g7;
}
function T3(t11, e8, n14) {
  if (!o4(t11))
    return null;
  const { width: l9, height: i11 } = t11, s14 = e8.x, r16 = e8.y, a16 = n14.width + s14, h10 = n14.height + r16;
  if (s14 < 0 || r16 < 0 || a16 > l9 || h10 > i11)
    return t11;
  if (0 === s14 && 0 === r16 && a16 === l9 && h10 === i11)
    return t11;
  t11.mask || (t11.mask = new Uint8Array(l9 * i11));
  const f11 = t11.mask;
  for (let o10 = 0; o10 < i11; o10++) {
    const t12 = o10 * l9;
    for (let e9 = 0; e9 < l9; e9++)
      f11[t12 + e9] = o10 < r16 || o10 >= h10 || e9 < s14 || e9 >= a16 ? 0 : 1;
  }
  return t11.updateStatistics(), t11;
}
function v4(t11) {
  if (!o4(t11))
    return null;
  const e8 = t11.clone(), { width: n14, height: l9, pixels: i11 } = t11, s14 = i11[0], r16 = e8.pixels[0], a16 = t11.mask;
  for (let o10 = 2; o10 < l9 - 1; o10++) {
    const t12 = /* @__PURE__ */ new Map();
    for (let l10 = o10 - 2; l10 < o10 + 2; l10++)
      for (let e10 = 0; e10 < 4; e10++) {
        const i12 = l10 * n14 + e10;
        S3(t12, s14[i12], a16 ? a16[i12] : 1);
      }
    r16[o10 * n14] = C3(t12), r16[o10 * n14 + 1] = r16[o10 * n14 + 2] = r16[o10 * n14];
    let e9 = 3;
    for (; e9 < n14 - 1; e9++) {
      let l10 = (o10 - 2) * n14 + e9 + 1;
      S3(t12, s14[l10], a16 ? a16[l10] : 1), l10 = (o10 - 1) * n14 + e9 + 1, S3(t12, s14[l10], a16 ? a16[l10] : 1), l10 = o10 * n14 + e9 + 1, S3(t12, s14[l10], a16 ? a16[l10] : 1), l10 = (o10 + 1) * n14 + e9 + 1, S3(t12, s14[l10], a16 ? a16[l10] : 1), l10 = (o10 - 2) * n14 + e9 - 3, B2(t12, s14[l10], a16 ? a16[l10] : 1), l10 = (o10 - 1) * n14 + e9 - 3, B2(t12, s14[l10], a16 ? a16[l10] : 1), l10 = o10 * n14 + e9 - 3, B2(t12, s14[l10], a16 ? a16[l10] : 1), l10 = (o10 + 1) * n14 + e9 - 3, B2(t12, s14[l10], a16 ? a16[l10] : 1), r16[o10 * n14 + e9] = C3(t12);
    }
    r16[o10 * n14 + e9 + 1] = r16[o10 * n14 + e9];
  }
  for (let o10 = 0; o10 < n14; o10++)
    r16[o10] = r16[n14 + o10] = r16[2 * n14 + o10], r16[(l9 - 1) * n14 + o10] = r16[(l9 - 2) * n14 + o10];
  return e8.updateStatistics(), e8;
}
function C3(t11) {
  if (0 === t11.size)
    return 0;
  let e8 = 0, n14 = -1, l9 = 0;
  const i11 = t11.keys();
  let o10 = i11.next();
  for (; !o10.done; )
    l9 = t11.get(o10.value), l9 > e8 && (n14 = o10.value, e8 = l9), o10 = i11.next();
  return n14;
}
function B2(t11, e8, n14) {
  if (0 === n14)
    return;
  const l9 = t11.get(e8);
  1 === l9 ? t11.delete(e8) : t11.set(e8, l9 - 1);
}
function S3(t11, e8, n14) {
  0 !== n14 && t11.set(e8, t11.has(e8) ? t11.get(e8) + 1 : 1);
}
function P3(e8, n14, l9) {
  let { x: i11, y: s14 } = n14;
  const { width: r16, height: a16 } = l9;
  if (0 === i11 && 0 === s14 && a16 === e8.height && r16 === e8.width)
    return e8;
  const { width: h10, height: f11 } = e8, c11 = Math.max(0, s14), u14 = Math.max(0, i11), p10 = Math.min(i11 + r16, h10), x6 = Math.min(s14 + a16, f11);
  if (p10 < 0 || x6 < 0 || !o4(e8))
    return null;
  i11 = Math.max(0, -i11), s14 = Math.max(0, -s14);
  const { pixels: d8 } = e8, m8 = r16 * a16, g7 = d8.length, y7 = [];
  for (let o10 = 0; o10 < g7; o10++) {
    const n15 = d8[o10], l10 = u2.createEmptyBand(e8.pixelType, m8);
    for (let t11 = c11; t11 < x6; t11++) {
      const e9 = t11 * h10;
      let o11 = (t11 + s14 - c11) * r16 + i11;
      for (let t12 = u14; t12 < p10; t12++)
        l10[o11++] = n15[e9 + t12];
    }
    y7.push(l10);
  }
  const w6 = new Uint8Array(m8), k5 = e8.mask;
  for (let t11 = c11; t11 < x6; t11++) {
    const e9 = t11 * h10;
    let n15 = (t11 + s14 - c11) * r16 + i11;
    for (let t12 = u14; t12 < p10; t12++)
      w6[n15++] = k5 ? k5[e9 + t12] : 1;
  }
  const M6 = new u2({ width: l9.width, height: l9.height, pixelType: e8.pixelType, pixels: y7, mask: w6 });
  return M6.updateStatistics(), M6;
}
function _(e8, n14 = true) {
  if (!o4(e8))
    return null;
  const { pixels: l9, width: i11, height: s14, mask: r16, pixelType: a16 } = e8, h10 = [], f11 = Math.round(i11 / 2), c11 = Math.round(s14 / 2), u14 = s14 - 1, p10 = i11 - 1;
  for (let o10 = 0; o10 < l9.length; o10++) {
    const e9 = l9[o10], r17 = u2.createEmptyBand(a16, f11 * c11);
    let x7 = 0;
    for (let t11 = 0; t11 < s14; t11 += 2)
      for (let l10 = 0; l10 < i11; l10 += 2) {
        const o11 = e9[t11 * i11 + l10];
        if (n14) {
          const n15 = l10 === p10 ? o11 : e9[t11 * i11 + l10 + 1], s15 = t11 === u14 ? o11 : e9[t11 * i11 + l10 + i11], a17 = l10 === p10 ? s15 : t11 === u14 ? n15 : e9[t11 * i11 + l10 + i11 + 1];
          r17[x7++] = (o11 + n15 + s15 + a17) / 4;
        } else
          r17[x7++] = o11;
      }
    h10.push(r17);
  }
  let x6 = null;
  if (null != r16) {
    x6 = new Uint8Array(f11 * c11);
    let t11 = 0;
    for (let e9 = 0; e9 < s14; e9 += 2)
      for (let l10 = 0; l10 < i11; l10 += 2) {
        const o10 = r16[e9 * i11 + l10];
        if (n14) {
          const n15 = l10 === p10 ? o10 : r16[e9 * i11 + l10 + 1], s15 = e9 === u14 ? o10 : r16[e9 * i11 + l10 + i11], a17 = l10 === p10 ? s15 : e9 === u14 ? n15 : r16[e9 * i11 + l10 + i11 + 1];
          x6[t11++] = o10 * n15 * s15 * a17 ? 1 : 0;
        } else
          x6[t11++] = o10;
      }
  }
  return new u2({ width: f11, height: c11, pixelType: a16, pixels: h10, mask: x6 });
}
function W2(t11, e8, n14) {
  if (!o4(t11))
    return null;
  const { width: l9, height: i11 } = e8;
  let { width: s14, height: r16 } = t11;
  const a16 = /* @__PURE__ */ new Map(), h10 = { x: 0, y: 0 }, f11 = null == n14 ? 1 : 1 + n14;
  let c11 = t11;
  for (let o10 = 0; o10 < f11; o10++) {
    const t12 = Math.ceil(s14 / l9), n15 = Math.ceil(r16 / i11);
    for (let s15 = 0; s15 < n15; s15++) {
      h10.y = s15 * i11;
      for (let n16 = 0; n16 < t12; n16++) {
        h10.x = n16 * l9;
        const t13 = P3(c11, h10, e8);
        a16.set(`${o10}/${s15}/${n16}`, t13);
      }
    }
    o10 < f11 - 1 && (c11 = _(c11)), s14 = Math.round(s14 / 2), r16 = Math.round(r16 / 2);
  }
  return a16;
}
function E3(t11, e8, n14, l9, i11 = 0) {
  const { width: o10, height: s14 } = t11, { width: r16, height: a16 } = e8, h10 = l9.cols, f11 = l9.rows, c11 = Math.ceil(r16 / h10 - 0.1 / h10), u14 = Math.ceil(a16 / f11 - 0.1 / f11);
  let p10, x6, d8, m8, g7, y7, w6;
  const k5 = c11 * h10, M6 = k5 * u14 * f11, A4 = new Float32Array(M6), U4 = new Float32Array(M6), b5 = new Uint32Array(M6), T4 = new Uint32Array(M6);
  let v6, C6, B4 = 0;
  for (let S4 = 0; S4 < u14; S4++)
    for (let t12 = 0; t12 < c11; t12++) {
      p10 = 12 * (S4 * c11 + t12), x6 = n14[p10], d8 = n14[p10 + 1], m8 = n14[p10 + 2], g7 = n14[p10 + 3], y7 = n14[p10 + 4], w6 = n14[p10 + 5];
      for (let e9 = 0; e9 < f11; e9++) {
        B4 = (S4 * f11 + e9) * k5 + t12 * h10, C6 = (e9 + 0.5) / f11;
        for (let t13 = 0; t13 < e9; t13++)
          v6 = (t13 + 0.5) / h10, A4[B4 + t13] = (x6 * v6 + d8 * C6 + m8) * o10 + i11, U4[B4 + t13] = (g7 * v6 + y7 * C6 + w6) * s14 + i11, b5[B4 + t13] = Math.floor(A4[B4 + t13]), T4[B4 + t13] = Math.floor(U4[B4 + t13]);
      }
      p10 += 6, x6 = n14[p10], d8 = n14[p10 + 1], m8 = n14[p10 + 2], g7 = n14[p10 + 3], y7 = n14[p10 + 4], w6 = n14[p10 + 5];
      for (let e9 = 0; e9 < f11; e9++) {
        B4 = (S4 * f11 + e9) * k5 + t12 * h10, C6 = (e9 + 0.5) / f11;
        for (let t13 = e9; t13 < h10; t13++)
          v6 = (t13 + 0.5) / h10, A4[B4 + t13] = (x6 * v6 + d8 * C6 + m8) * o10 + i11, U4[B4 + t13] = (g7 * v6 + y7 * C6 + w6) * s14 + i11, b5[B4 + t13] = Math.floor(A4[B4 + t13]), T4[B4 + t13] = Math.floor(U4[B4 + t13]);
      }
    }
  return { offsets_x: A4, offsets_y: U4, offsets_xi: b5, offsets_yi: T4, gridWidth: k5 };
}
function I3(t11, e8) {
  const { coefficients: n14, spacing: l9 } = e8, { offsets_x: i11, offsets_y: o10, gridWidth: s14 } = E3(t11, t11, n14, { rows: l9[0], cols: l9[1] }), { width: r16, height: a16 } = t11, h10 = new Float32Array(r16 * a16), f11 = 180 / Math.PI;
  for (let c11 = 0; c11 < a16; c11++)
    for (let t12 = 0; t12 < r16; t12++) {
      const e9 = c11 * s14 + t12, n15 = 0 === c11 ? e9 : e9 - s14, l10 = c11 === a16 - 1 ? e9 : e9 + s14, u14 = i11[n15] - i11[l10], p10 = o10[l10] - o10[n15];
      if (isNaN(u14) || isNaN(p10))
        h10[c11 * r16 + t12] = 90;
      else {
        let e10 = Math.atan2(p10, u14) * f11;
        e10 = (360 + e10) % 360, h10[c11 * r16 + t12] = e10;
      }
    }
  return h10;
}
function R2(e8, n14, l9, i11, s14 = "nearest") {
  if (!o4(e8))
    return null;
  "majority" === s14 && (e8 = v4(e8));
  const { pixels: r16, mask: a16, bandMasks: h10, pixelType: f11 } = e8, c11 = e8.width, u14 = e8.height, p10 = u2.getPixelArrayConstructor(f11), x6 = r16.length, { width: d8, height: m8 } = n14;
  let g7 = false;
  for (let t11 = 0; t11 < l9.length; t11 += 3)
    -1 === l9[t11] && -1 === l9[t11 + 1] && -1 === l9[t11 + 2] && (g7 = true);
  const { offsets_x: y7, offsets_y: w6, offsets_xi: k5, offsets_yi: M6, gridWidth: A4 } = E3({ width: c11, height: u14 }, n14, l9, i11, "majority" === s14 ? 0.5 : 0);
  let U4;
  const b5 = (t11, e9, n15, l10) => {
    const i12 = t11 instanceof Float32Array || t11 instanceof Float64Array ? 0 : 0.5;
    for (let o10 = 0; o10 < m8; o10++) {
      U4 = o10 * A4;
      for (let s15 = 0; s15 < d8; s15++) {
        if (y7[U4] < 0 || w6[U4] < 0)
          t11[o10 * d8 + s15] = 0;
        else if (l10)
          t11[o10 * d8 + s15] = e9[k5[U4] + M6[U4] * c11];
        else {
          const l11 = Math.floor(y7[U4]), r17 = Math.floor(w6[U4]), a17 = Math.ceil(y7[U4]), h11 = Math.ceil(w6[U4]), f12 = y7[U4] - l11, u15 = w6[U4] - r17;
          if (!n15 || n15[l11 + r17 * c11] && n15[a17 + r17 * c11] && n15[l11 + h11 * c11] && n15[a17 + h11 * c11]) {
            const n16 = (1 - f12) * e9[l11 + r17 * c11] + f12 * e9[a17 + r17 * c11], p11 = (1 - f12) * e9[l11 + h11 * c11] + f12 * e9[a17 + h11 * c11];
            t11[o10 * d8 + s15] = (1 - u15) * n16 + u15 * p11 + i12;
          } else
            t11[o10 * d8 + s15] = e9[k5[U4] + M6[U4] * c11];
        }
        U4++;
      }
    }
  }, T4 = [];
  let C6;
  const B4 = (h10 == null ? void 0 : h10.length) === x6, S4 = [];
  for (let t11 = 0; t11 < x6; t11++) {
    if (B4) {
      const e9 = new Uint8Array(d8 * m8);
      b5(e9, h10[t11], h10[t11], true), S4.push(e9);
    }
    C6 = new p10(d8 * m8), b5(C6, r16[t11], B4 ? h10[t11] : a16, "nearest" === s14 || "majority" === s14), T4.push(C6);
  }
  const P4 = new u2({ width: d8, height: m8, pixelType: f11, pixels: T4, bandMasks: B4 ? S4 : void 0 });
  if (null != a16)
    P4.mask = new Uint8Array(d8 * m8), b5(P4.mask, a16, a16, true);
  else if (g7) {
    P4.mask = new Uint8Array(d8 * m8);
    for (let t11 = 0; t11 < d8 * m8; t11++)
      P4.mask[t11] = y7[t11] < 0 || w6[t11] < 0 ? 0 : 1;
  }
  return P4.updateStatistics(), P4;
}

// node_modules/@arcgis/core/renderers/support/stretchRendererUtils.js
var n7 = new s4({ none: "none", standardDeviation: "standard-deviation", histogramEqualization: "histogram-equalization", minMax: "min-max", percentClip: "percent-clip", sigmoid: "sigmoid" });
var a9 = { 0: "none", 3: "standardDeviation", 4: "histogramEqualization", 5: "minMax", 6: "percentClip", 9: "sigmoid" };

// node_modules/@arcgis/core/layers/support/rasterFunctions/stretchUtils.js
var i7 = 1;
var o5 = [0.299, 0.587, 0.114];
function r12(t11, n14 = 256) {
  n14 = Math.min(n14, 256);
  const { size: s14, counts: e8 } = t11, i11 = new Uint8Array(s14), o10 = e8.reduce((t12, s15) => t12 + s15 / n14, 0);
  let r16 = 0, a16 = 0, l9 = 0, u14 = o10;
  for (let f11 = 0; f11 < s14; f11++)
    if (l9 += e8[f11], !(f11 < s14 - 1 && l9 + e8[f11 + 1] < u14)) {
      for (; r16 < n14 - 1 && u14 < l9; )
        r16++, u14 += o10;
      for (let t12 = a16; t12 <= f11; t12++)
        i11[t12] = r16;
      a16 = f11 + 1;
    }
  for (let f11 = a16; f11 < s14; f11++)
    i11[f11] = n14 - 1;
  return i11;
}
function a10(t11) {
  const { minCutOff: n14, maxCutOff: s14, gamma: e8, pixelType: i11, rounding: o10 } = t11, r16 = t11.outMin || 0, a16 = t11.outMax || 255;
  if (!["u8", "u16", "s8", "s16"].includes(i11))
    return null;
  const u14 = n14.length;
  let f11, c11, m8 = 0;
  "s8" === i11 ? m8 = -127 : "s16" === i11 && (m8 = -32767);
  let h10 = 256;
  ["u16", "s16"].includes(i11) && (h10 = 65536);
  const g7 = [], p10 = [], x6 = a16 - r16;
  for (f11 = 0; f11 < u14; f11++)
    p10[f11] = s14[f11] - n14[f11], g7[f11] = 0 === p10[f11] ? 0 : x6 / p10[f11];
  let M6;
  const y7 = [];
  let b5, v6, k5;
  if (e8 && e8.length >= u14) {
    const t12 = d3(u14, e8);
    for (f11 = 0; f11 < u14; f11++) {
      for (k5 = [], c11 = 0; c11 < h10; c11++)
        if (0 !== p10[f11])
          if (b5 = c11 + m8, M6 = (b5 - n14[f11]) / p10[f11], v6 = 1, e8[f11] > 1 && (v6 -= (1 / x6) ** (M6 * t12[f11])), b5 < s14[f11] && b5 > n14[f11]) {
            const t13 = v6 * x6 * M6 ** (1 / e8[f11]) + r16;
            k5[c11] = "floor" === o10 ? Math.floor(t13) : "round" === o10 ? Math.round(t13) : t13;
          } else
            b5 >= s14[f11] ? k5[c11] = a16 : k5[c11] = r16;
        else
          k5[c11] = r16;
      y7[f11] = k5;
    }
  } else
    for (f11 = 0; f11 < u14; f11++) {
      for (k5 = [], c11 = 0; c11 < h10; c11++)
        if (b5 = c11 + m8, b5 <= n14[f11])
          k5[c11] = r16;
        else if (b5 >= s14[f11])
          k5[c11] = a16;
        else {
          const t12 = (b5 - n14[f11]) * g7[f11] + r16;
          k5[c11] = "floor" === o10 ? Math.floor(t12) : "round" === o10 ? Math.round(t12) : t12;
        }
      y7[f11] = k5;
    }
  if (null != t11.contrastOffset) {
    const n15 = l5(t11.contrastOffset, t11.brightnessOffset);
    for (f11 = 0; f11 < u14; f11++)
      for (k5 = y7[f11], c11 = 0; c11 < h10; c11++)
        k5[c11] = n15[k5[c11]];
  }
  return { lut: y7, offset: m8 };
}
function l5(t11, n14) {
  const s14 = Math.min(Math.max(t11, -100), 100), e8 = Math.min(Math.max(n14 ?? 0, -100), 100), i11 = 255, o10 = 128;
  let r16 = 0, a16 = 0;
  const l9 = new Uint8Array(256);
  for (r16 = 0; r16 < 256; r16++)
    s14 > 0 && s14 < 100 ? a16 = (200 * r16 - 100 * i11 + 2 * i11 * e8) / (2 * (100 - s14)) + o10 : s14 <= 0 && s14 > -100 ? a16 = (200 * r16 - 100 * i11 + 2 * i11 * e8) * (100 + s14) / 2e4 + o10 : 100 === s14 ? (a16 = 200 * r16 - 100 * i11 + (i11 + 1) * (100 - s14) + 2 * i11 * e8, a16 = a16 > 0 ? i11 : 0) : -100 === s14 && (a16 = o10), l9[r16] = a16 > i11 ? i11 : a16 < 0 ? 0 : a16;
  return l9;
}
function u6(t11, n14, s14) {
  const e8 = [];
  for (let i11 = 0; i11 < n14.length; i11++) {
    let r16 = 0, a16 = 0, l9 = 0;
    "min" in n14[i11] ? { min: r16, max: a16, avg: l9 } = n14[i11] : [r16, a16, l9] = n14[i11];
    let u14 = l9 ?? 0;
    "u8" !== t11 && (u14 = 255 * (u14 - r16) / (a16 - r16)), s14 && (u14 *= o5[i11]), e8.push(f7(u14));
  }
  return e8;
}
function f7(t11) {
  if (t11 <= 0 || t11 >= 255)
    return i7;
  let n14 = 0;
  150 !== t11 && (n14 = t11 <= 150 ? 45 * Math.cos(0.01047 * t11) : 17 * Math.sin(0.021 * t11));
  const s14 = 255, e8 = t11 + n14, o10 = Math.log(t11 / s14), r16 = Math.log(e8 / s14);
  if (0 === r16)
    return i7;
  const a16 = o10 / r16;
  return isNaN(a16) ? i7 : Math.min(9.9, Math.max(0.01, a16));
}
function c6(t11, n14, s14, e8) {
  let i11 = 1 / 0, o10 = -1 / 0, r16 = 0, a16 = 0;
  const l9 = t11.length;
  for (let d8 = 0; d8 < l9; d8++) {
    const s15 = t11[d8];
    n14 && !n14[d8] || (i11 = s15 < i11 ? s15 : i11, o10 = s15 > o10 ? s15 : o10, r16 += s15, a16++);
  }
  if (0 === a16)
    return { statistics: { min: 0, max: 0, avg: 0, stddev: 0 }, histogram: null };
  const u14 = r16 / a16;
  let f11 = 0;
  for (let d8 = 0; d8 < l9; d8++)
    n14 && !n14[d8] || (f11 += (t11[d8] - u14) ** 2);
  const c11 = n14 ? n14.filter((t12) => t12).length : l9, m8 = { min: i11, max: o10, avg: u14, stddev: c11 <= 1 ? 0 : Math.sqrt(f11 / (c11 - 1)) };
  if (!e8)
    return { statistics: m8, histogram: null };
  if (["u8", "s8", "u4", "u2", "u1"].includes(s14)) {
    const s15 = o10 - i11 + 1, e9 = new Uint32Array(s15);
    for (let o11 = 0; o11 < l9; o11++)
      n14 && !n14[o11] || e9[t11[o11] - i11]++;
    return { statistics: m8, histogram: { min: i11 - 0.5, max: o10 + 0.5, size: s15, counts: e9 } };
  }
  const h10 = 256, g7 = new Uint32Array(h10), p10 = (o10 - i11) / h10;
  if (0 === p10)
    return { statistics: m8, histogram: { min: i11, max: o10, size: 1, counts: new Uint32Array(1).fill(a16) } };
  const x6 = new Uint32Array(h10 + 1);
  for (let d8 = 0; d8 < l9; d8++)
    n14 && !n14[d8] || x6[Math.floor((t11[d8] - i11) / p10)]++;
  for (let d8 = 0; d8 < h10 - 1; d8++)
    g7[d8] = x6[d8];
  return g7[h10 - 1] = x6[h10 - 1] + x6[h10], { statistics: m8, histogram: { min: i11, max: o10, size: h10, counts: g7 } };
}
function m4(t11) {
  const { pixels: n14, mask: s14, pixelType: e8, bandMasks: i11 } = t11, o10 = n14.map((t12, n15) => c6(t12, (i11 == null ? void 0 : i11[n15]) ?? s14, e8, true));
  return { statistics: o10.map(({ statistics: t12 }) => t12), histograms: o10.map(({ histogram: t12 }) => t12) };
}
function h4(t11) {
  var _a;
  if (null == t11 || !((_a = t11.pixels) == null ? void 0 : _a.length))
    return null;
  const { pixels: n14, mask: s14, bandMasks: e8, pixelType: i11 } = t11, o10 = t11.width * t11.height, r16 = n14.length;
  let a16, l9, u14, f11, c11;
  const m8 = [], h10 = [];
  let g7, p10, x6, d8, M6, y7, b5, v6, k5, w6;
  const z2 = 256;
  for (f11 = 0; f11 < r16; f11++) {
    g7 = new Uint32Array(z2), x6 = n14[f11];
    const r17 = (e8 == null ? void 0 : e8[f11]) ?? s14;
    if ("u8" === i11)
      if (a16 = -0.5, l9 = 255.5, r17)
        for (c11 = 0; c11 < o10; c11++)
          r17[c11] && g7[x6[c11]]++;
      else
        for (c11 = 0; c11 < o10; c11++)
          g7[x6[c11]]++;
    else {
      let n15 = false;
      t11.statistics || (t11.updateStatistics(), n15 = true);
      const s15 = t11.statistics;
      if (a16 = s15[f11].minValue, l9 = s15[f11].maxValue, u14 = (l9 - a16) / z2, 0 === u14) {
        !s15 || t11.validPixelCount || n15 || t11.updateStatistics();
        const e9 = (t11.validPixelCount || t11.width * t11.height) / z2;
        for (let t12 = 0; t12 < z2; t12++)
          g7[t12] = Math.round(e9 * (t12 + 1)) - Math.round(e9 * t12);
      } else {
        for (p10 = new Uint32Array(z2 + 1), c11 = 0; c11 < o10; c11++)
          r17 && !r17[c11] || p10[Math.floor((x6[c11] - a16) / u14)]++;
        for (c11 = 0; c11 < z2 - 1; c11++)
          g7[c11] = p10[c11];
        g7[z2 - 1] = p10[z2 - 1] + p10[z2];
      }
    }
    for (m8.push({ min: a16, max: l9, size: z2, counts: g7 }), d8 = 0, M6 = 0, v6 = 0, c11 = 0; c11 < z2; c11++)
      d8 += g7[c11], M6 += c11 * g7[c11];
    for (k5 = M6 / d8, c11 = 0; c11 < z2; c11++)
      v6 += g7[c11] * (c11 - k5) ** 2;
    w6 = Math.sqrt(v6 / (d8 - 1)), u14 = (l9 - a16) / z2, y7 = (k5 + 0.5) * u14 + a16, b5 = w6 * u14, h10.push({ min: a16, max: l9, avg: y7, stddev: b5 });
  }
  return { statistics: h10, histograms: m8 };
}
function g4(t11) {
  const n14 = [];
  for (let s14 = 0; s14 < t11.length; s14++) {
    const { min: e8, max: i11, size: o10, counts: r16 } = t11[s14];
    let a16 = 0, l9 = 0;
    for (let t12 = 0; t12 < o10; t12++)
      a16 += r16[t12], l9 += t12 * r16[t12];
    const u14 = l9 / a16;
    let f11 = 0;
    for (let t12 = 0; t12 < o10; t12++)
      f11 += r16[t12] * (t12 - u14) ** 2;
    const c11 = (i11 - e8) / o10, m8 = (u14 + 0.5) * c11 + e8, h10 = Math.sqrt(f11 / (a16 - 1)) * c11;
    n14.push({ min: e8, max: i11, avg: m8, stddev: h10 });
  }
  return n14;
}
function p5(n14, i11) {
  var _a;
  const { pixelBlock: o10, bandIds: a16, returnHistogramLut: l9, rasterInfo: u14 } = i11;
  let f11 = null, c11 = null, m8 = n14.stretchType;
  if ("number" == typeof m8 && (m8 = a9[m8]), n14.dra)
    if ("minMax" === m8 && null != o10 && o10.statistics)
      f11 = o10.statistics.map((t11) => [t11.minValue, t11.maxValue, 0, 0]);
    else {
      const t11 = h4(o10);
      f11 = null != t11 ? t11.statistics : null, c11 = null != t11 ? t11.histograms : null;
    }
  else
    f11 = ((_a = n14.statistics) == null ? void 0 : _a.length) > 0 ? n14.statistics : u14.statistics, c11 = "histograms" in n14 ? n14.histograms : void 0, c11 || (c11 = u14.histograms);
  "percentClip" !== m8 && "histogramEqualization" !== m8 || (c11 == null ? void 0 : c11.length) || (m8 = "minMax");
  const g7 = (f11 == null ? void 0 : f11.length) || (c11 == null ? void 0 : c11.length) || u14.bandCount, p10 = [], d8 = [];
  let M6, y7, b5, v6, k5, w6, z2, C6, O3;
  f11 && !Array.isArray(f11[0]) && (f11 = f11.map((t11) => [t11.min, t11.max, t11.avg, t11.stddev]));
  const [A4, U4] = s6(u14.pixelType);
  if (!(f11 == null ? void 0 : f11.length)) {
    for (f11 = [], C6 = 0; C6 < g7; C6++)
      f11.push([A4, U4, 1, 1]);
    "standardDeviation" === m8 && (m8 = "minMax");
  }
  switch (m8) {
    case "none":
      for (C6 = 0; C6 < g7; C6++)
        p10[C6] = A4, d8[C6] = U4;
      break;
    case "minMax":
      for (C6 = 0; C6 < g7; C6++) {
        const t11 = f11[C6];
        p10[C6] = t11[0], d8[C6] = t11[1];
      }
      break;
    case "standardDeviation":
      for (C6 = 0; C6 < g7; C6++) {
        const t11 = f11[C6];
        p10[C6] = t11[2] - n14.numberOfStandardDeviations * t11[3], d8[C6] = t11[2] + n14.numberOfStandardDeviations * t11[3], p10[C6] < t11[0] && (p10[C6] = t11[0]), d8[C6] > t11[1] && (d8[C6] = t11[1]);
      }
      break;
    case "histogramEqualization":
      for (r(c11), C6 = 0; C6 < g7; C6++)
        p10[C6] = c11[C6].min, d8[C6] = c11[C6].max;
      break;
    case "percentClip":
      for (r(c11), C6 = 0; C6 < c11.length; C6++) {
        for (M6 = c11[C6], k5 = new Uint32Array(M6.size), v6 = [...M6.counts], v6.length >= 20 && (v6[0] = v6[1] = v6[2] = v6[v6.length - 1] = v6[v6.length - 2] = 0), b5 = 0, y7 = (M6.max - M6.min) / M6.size, z2 = -0.5 === M6.min && 1 === y7 ? 0.5 : 0, O3 = 0; O3 < M6.size; O3++)
          b5 += v6[O3], k5[O3] = b5;
        for (w6 = (n14.minPercent || 0) * b5 / 100, p10[C6] = M6.min + z2, O3 = 0; O3 < M6.size; O3++)
          if (k5[O3] > w6) {
            p10[C6] = M6.min + y7 * (O3 + z2);
            break;
          }
        for (w6 = (1 - (n14.maxPercent || 0) / 100) * b5, d8[C6] = M6.max + z2, O3 = M6.size - 2; O3 >= 0; O3--)
          if (k5[O3] < w6) {
            d8[C6] = M6.min + y7 * (O3 + 2 - z2);
            break;
          }
        if (d8[C6] < p10[C6]) {
          const t11 = p10[C6];
          p10[C6] = d8[C6], d8[C6] = t11;
        }
      }
      break;
    default:
      for (C6 = 0; C6 < g7; C6++) {
        const t11 = f11[C6];
        p10[C6] = t11[0], d8[C6] = t11[1];
      }
  }
  let T4, q, P4;
  "histogramEqualization" === m8 ? (r(c11), q = c11[0].size || 256, T4 = 0, l9 && (P4 = c11.map((t11) => r12(t11)))) : (q = n14.max || 255, T4 = n14.min || 0);
  return x5({ minCutOff: p10, maxCutOff: d8, outMax: q, outMin: T4, histogramLut: P4 }, a16);
}
function x5(t11, n14) {
  if (null == n14 || 0 === n14.length)
    return t11;
  const s14 = Math.max.apply(null, n14), { minCutOff: e8, maxCutOff: i11, outMin: o10, outMax: r16, histogramLut: a16 } = t11;
  return e8.length === n14.length || e8.length <= s14 ? t11 : { minCutOff: n14.map((t12) => e8[t12]), maxCutOff: n14.map((t12) => i11[t12]), histogramLut: a16 ? n14.map((t12) => a16[t12]) : null, outMin: o10, outMax: r16 };
}
function d3(t11, n14) {
  const s14 = new Float32Array(t11);
  for (let e8 = 0; e8 < t11; e8++)
    n14[e8] > 1 ? n14[e8] > 2 ? s14[e8] = 6.5 + (n14[e8] - 2) ** 2.5 : s14[e8] = 6.5 + 100 * (2 - n14[e8]) ** 4 : s14[e8] = 1;
  return s14;
}
function M3(t11, s14) {
  var _a;
  if (null == t11 || !((_a = t11.pixels) == null ? void 0 : _a.length))
    return t11;
  const { mask: e8, bandMasks: i11, width: o10, height: r16, pixels: a16 } = t11, { minCutOff: l9, maxCutOff: u14, gamma: f11 } = s14, c11 = s14.outMin || 0, m8 = s14.outMax || 255, h10 = o10 * r16, g7 = s14.outputPixelType || "u8", p10 = t11.pixels.map(() => u2.createEmptyBand(g7, h10)), x6 = p10.length, M6 = m8 - c11, y7 = [], b5 = [];
  for (let n14 = 0; n14 < x6; n14++)
    b5[n14] = u14[n14] - l9[n14], y7[n14] = 0 === b5[n14] ? 0 : M6 / b5[n14];
  const v6 = g7.startsWith("u") || g7.startsWith("s"), k5 = f11 && f11.length >= x6, w6 = !!s14.isRenderer;
  if (k5) {
    const t12 = d3(x6, f11);
    for (let n14 = 0; n14 < x6; n14++) {
      const s15 = (i11 == null ? void 0 : i11[n14]) ?? e8;
      for (let e9 = 0; e9 < h10; e9++)
        if (null == s15 || s15[e9]) {
          if (0 === b5[n14]) {
            p10[n14][e9] = c11;
            continue;
          }
          const s16 = a16[n14][e9], i12 = (s16 - l9[n14]) / b5[n14];
          let o11 = 1;
          if (f11[n14] > 1 && (o11 -= (1 / M6) ** (i12 * t12[n14])), s16 < u14[n14] && s16 > l9[n14]) {
            const t13 = o11 * M6 * i12 ** (1 / f11[n14]) + c11;
            p10[n14][e9] = w6 ? Math.floor(t13) : v6 ? Math.round(t13) : t13;
          } else
            s16 >= u14[n14] ? p10[n14][e9] = m8 : p10[n14][e9] = c11;
        }
    }
  } else
    for (let n14 = 0; n14 < x6; n14++) {
      const t12 = (i11 == null ? void 0 : i11[n14]) ?? e8;
      for (let s15 = 0; s15 < h10; s15++)
        if (null == t12 || t12[s15]) {
          const t13 = a16[n14][s15];
          if (t13 < u14[n14] && t13 > l9[n14]) {
            const e9 = (t13 - l9[n14]) * y7[n14] + c11;
            p10[n14][s15] = w6 ? Math.floor(e9) : v6 ? Math.round(e9) : e9;
          } else
            t13 >= u14[n14] ? p10[n14][s15] = m8 : p10[n14][s15] = c11;
        }
    }
  const z2 = new u2({ width: o10, height: r16, mask: e8, bandMasks: i11, pixels: p10, pixelType: g7 });
  return z2.updateStatistics(), z2;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var r13 = /* @__PURE__ */ new Map();
r13.set("meter-per-second", 1), r13.set("kilometer-per-hour", 0.277778), r13.set("knots", 0.514444), r13.set("feet-per-second", 0.3048), r13.set("mile-per-hour", 0.44704);
var o6 = 180 / Math.PI;
var s9 = new s4({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function a11(t11, e8) {
  return r13.get(t11) / r13.get(e8) || 1;
}
function h5(t11) {
  return (450 - t11) % 360;
}
function l6(t11, e8 = "geographic") {
  const [n14, r16] = t11, i11 = Math.sqrt(n14 * n14 + r16 * r16);
  let s14 = Math.atan2(r16, n14) * o6;
  return s14 = (360 + s14) % 360, "geographic" === e8 && (s14 = h5(s14)), [i11, s14];
}
function c7(t11, e8 = "geographic") {
  let n14 = t11[1];
  "geographic" === e8 && (n14 = h5(n14)), n14 %= 360;
  const r16 = t11[0];
  return [r16 * Math.cos(n14 / o6), r16 * Math.sin(n14 / o6)];
}
function u7(t11, e8, r16, o10 = "geographic") {
  if (!o4(t11) || null == r16)
    return t11;
  const i11 = "vector-magdir" === e8 ? t11.clone() : f8(t11, e8), s14 = i11.pixels[1];
  for (let n14 = 0; n14 < s14.length; n14++)
    s14[n14] = "geographic" === o10 ? (s14[n14] + r16[n14] + 270) % 360 : (s14[n14] + 360 - r16[n14]) % 360;
  return "vector-magdir" === e8 ? i11 : f8(i11, "vector-magdir");
}
function f8(t11, r16, o10 = "geographic", i11 = 1) {
  if (!o4(t11))
    return t11;
  const { pixels: s14, width: a16, height: h10 } = t11, u14 = a16 * h10, f11 = s14[0], p10 = s14[1], m8 = t11.pixelType.startsWith("f") ? t11.pixelType : "f32", d8 = u2.createEmptyBand(m8, u14), g7 = u2.createEmptyBand(m8, u14);
  let x6 = 0;
  for (let e8 = 0; e8 < h10; e8++)
    for (let t12 = 0; t12 < a16; t12++)
      "vector-uv" === r16 ? ([d8[x6], g7[x6]] = l6([f11[x6], p10[x6]], o10), d8[x6] *= i11) : ([d8[x6], g7[x6]] = c7([f11[x6], p10[x6]], o10), d8[x6] *= i11, g7[x6] *= i11), x6++;
  const M6 = new u2({ pixelType: m8, width: t11.width, height: t11.height, mask: t11.mask, validPixelCount: t11.validPixelCount, maskIsAlpha: t11.maskIsAlpha, pixels: [d8, g7] });
  return M6.updateStatistics(), M6;
}
function p6(t11, e8, r16 = 1) {
  if (1 === r16 || !o4(t11))
    return t11;
  const o10 = t11.clone(), { pixels: i11, width: s14, height: a16 } = o10, h10 = i11[0], l9 = i11[1];
  let c11 = 0;
  for (let n14 = 0; n14 < a16; n14++)
    for (let t12 = 0; t12 < s14; t12++)
      "vector-uv" === e8 ? (h10[c11] *= r16, l9[c11] *= r16) : h10[c11] *= r16, c11++;
  return o10.updateStatistics(), o10;
}
var d4 = g5(0, 0, 0);
function g5(t11 = 0, e8 = 0, n14 = Math.PI, r16 = true) {
  r16 && (n14 = (2 * Math.PI - n14) % (2 * Math.PI));
  const o10 = r16 ? -1 : 1, i11 = 13 * o10, s14 = -7 * o10, a16 = -2 * o10, h10 = -16 * o10, l9 = 21.75, [c11, u14] = M4(0, e8 + i11, n14, l9), [f11, p10] = M4(t11 - 5.5, e8 + s14, n14, l9), [m8, d8] = M4(t11 + 5.5, e8 + s14, n14, l9), [g7, x6] = M4(t11 - 1.5, e8 + a16, n14, l9), [k5, w6] = M4(t11 + 1.5, e8 + a16, n14, l9), [y7, P4] = M4(t11 - 1.5, e8 + h10, n14, l9), [b5, v6] = M4(t11 + 1.5, e8 + h10, n14, l9);
  return [c11, u14, f11, p10, g7, x6, k5, w6, m8, d8, y7, P4, b5, v6];
}
function M4(t11, e8, n14, r16 = 1) {
  const o10 = Math.sqrt(t11 * t11 + e8 * e8) / r16, i11 = (2 * Math.PI + Math.atan2(e8, t11)) % (2 * Math.PI);
  return [o10, (2 * Math.PI + i11 - n14) % (2 * Math.PI)];
}

// node_modules/@arcgis/core/layers/support/RasterBandInfo.js
var t9;
function n8(e8) {
  return e8 = Number(e8), isNaN(e8) ? void 0 : e8;
}
var o7 = t9 = class extends l {
  constructor() {
    super(...arguments), this.name = null, this.minWavelength = void 0, this.maxWavelength = void 0, this.radianceBias = void 0, this.radianceGain = void 0, this.reflectanceBias = void 0, this.reflectanceGain = void 0, this.solarIrradiance = void 0;
  }
  clone() {
    return new t9({ name: this.name, minWavelength: this.minWavelength, maxWavelength: this.maxWavelength, radianceBias: this.radianceBias, radianceGain: this.radianceGain, reflectanceBias: this.reflectanceBias, reflectanceGain: this.reflectanceGain, solarIrradiance: this.solarIrradiance });
  }
};
e([y({ json: { name: "BandName", write: true } })], o7.prototype, "name", void 0), e([y({ json: { name: "WavelengthMin", read: { reader: n8 }, write: true } })], o7.prototype, "minWavelength", void 0), e([y({ json: { name: "WavelengthMax", read: { reader: n8 }, write: true } })], o7.prototype, "maxWavelength", void 0), e([y({ json: { name: "RadianceBias", read: { reader: n8 }, write: true } })], o7.prototype, "radianceBias", void 0), e([y({ json: { name: "RadianceGain", read: { reader: n8 }, write: true } })], o7.prototype, "radianceGain", void 0), e([y({ json: { name: "ReflectanceBias", read: { reader: n8 }, write: true } })], o7.prototype, "reflectanceBias", void 0), e([y({ json: { name: "ReflectanceGain", read: { reader: n8 }, write: true } })], o7.prototype, "reflectanceGain", void 0), e([y({ json: { name: "SolarIrradiance", read: { reader: n8 }, write: true } })], o7.prototype, "solarIrradiance", void 0), o7 = t9 = e([a2("esri.layers.support.RasterBandInfo")], o7);
var s10 = o7;

// node_modules/@arcgis/core/layers/support/RasterSensorInfo.js
var a12;
function n9(o10) {
  return o10 = Number(o10), isNaN(o10) ? void 0 : o10;
}
var u8 = a12 = class extends l {
  constructor() {
    super(...arguments), this.acquisitionDate = void 0, this.cloudCover = void 0, this.productName = void 0, this.sensorName = null, this.sensorAzimuth = void 0, this.sensorElevation = void 0, this.sunAzimuth = void 0, this.sunElevation = void 0;
  }
  readAcquisitionDate(o10) {
    return new Date(o10);
  }
  writeAcquisitionDate(o10, e8) {
    e8.AcquisitionDate = o10.getTime();
  }
  clone() {
    return new a12({ acquisitionDate: this.acquisitionDate, cloudCover: this.cloudCover, productName: this.productName, sensorName: this.sensorName, sensorAzimuth: this.sensorAzimuth, sensorElevation: this.sensorElevation, sunAzimuth: this.sunAzimuth, sunElevation: this.sunElevation });
  }
};
e([y({ json: { name: "AcquisitionDate", write: true } })], u8.prototype, "acquisitionDate", void 0), e([o("acquisitionDate")], u8.prototype, "readAcquisitionDate", null), e([r2("acquisitionDate")], u8.prototype, "writeAcquisitionDate", null), e([y({ json: { name: "CloudCover", read: { reader: n9 }, write: true } })], u8.prototype, "cloudCover", void 0), e([y({ json: { name: "ProductName", write: true } })], u8.prototype, "productName", void 0), e([y({ json: { name: "SensorName", write: true } })], u8.prototype, "sensorName", void 0), e([y({ json: { name: "SensorAzimuth", read: { reader: n9 }, write: true } })], u8.prototype, "sensorAzimuth", void 0), e([y({ json: { name: "SensorElevation", read: { reader: n9 }, write: true } })], u8.prototype, "sensorElevation", void 0), e([y({ json: { name: "SunAzimuth", read: { reader: n9 }, write: true } })], u8.prototype, "sunAzimuth", void 0), e([y({ json: { name: "SunElevation", read: { reader: n9 }, write: true } })], u8.prototype, "sunElevation", void 0), u8 = a12 = e([a2("esri.layers.support.RasterSensorInfo")], u8);
var p7 = u8;

// node_modules/@arcgis/core/layers/support/RasterStorageInfo.js
var p8;
var l7 = p8 = class extends l {
  constructor() {
    super(...arguments), this.blockWidth = void 0, this.blockHeight = void 0, this.compression = null, this.origin = null, this.firstPyramidLevel = null, this.maximumPyramidLevel = null, this.pyramidScalingFactor = 2, this.pyramidBlockWidth = null, this.pyramidBlockHeight = null, this.isVirtualTileInfo = false, this.tileInfo = null, this.transposeInfo = null, this.blockBoundary = null;
  }
  clone() {
    return new p8({ blockWidth: this.blockWidth, blockHeight: this.blockHeight, compression: this.compression, origin: a(this.origin), firstPyramidLevel: this.firstPyramidLevel, maximumPyramidLevel: this.maximumPyramidLevel, pyramidResolutions: a(this.pyramidResolutions), pyramidScalingFactor: this.pyramidScalingFactor, pyramidBlockWidth: this.pyramidBlockWidth, pyramidBlockHeight: this.pyramidBlockHeight, isVirtualTileInfo: this.isVirtualTileInfo, tileInfo: a(this.tileInfo), transposeInfo: a(this.transposeInfo), blockBoundary: a(this.blockBoundary) });
  }
};
e([y({ type: Number, json: { write: true } })], l7.prototype, "blockWidth", void 0), e([y({ type: Number, json: { write: true } })], l7.prototype, "blockHeight", void 0), e([y({ type: String, json: { write: true } })], l7.prototype, "compression", void 0), e([y({ type: x, json: { write: true } })], l7.prototype, "origin", void 0), e([y({ type: Number, json: { write: true } })], l7.prototype, "firstPyramidLevel", void 0), e([y({ type: Number, json: { write: true } })], l7.prototype, "maximumPyramidLevel", void 0), e([y({ json: { write: true } })], l7.prototype, "pyramidResolutions", void 0), e([y({ type: Number, json: { write: true } })], l7.prototype, "pyramidScalingFactor", void 0), e([y({ type: Number, json: { write: true } })], l7.prototype, "pyramidBlockWidth", void 0), e([y({ type: Number, json: { write: true } })], l7.prototype, "pyramidBlockHeight", void 0), e([y({ type: Boolean, json: { write: true } })], l7.prototype, "isVirtualTileInfo", void 0), e([y({ json: { write: true } })], l7.prototype, "tileInfo", void 0), e([y()], l7.prototype, "transposeInfo", void 0), e([y()], l7.prototype, "blockBoundary", void 0), l7 = p8 = e([a2("esri.layers.support.RasterStorageInfo")], l7);
var n10 = l7;

// node_modules/@arcgis/core/layers/support/RasterInfo.js
var h6;
var u9 = h6 = class extends l {
  constructor(t11) {
    super(t11), this.attributeTable = null, this.bandCount = null, this.colormap = null, this.extent = null, this.format = void 0, this.height = null, this.width = null, this.histograms = null, this.keyProperties = {}, this.multidimensionalInfo = null, this.noDataValue = null, this.pixelSize = null, this.pixelType = null, this.isPseudoSpatialReference = false, this.spatialReference = null, this.statistics = null, this.storageInfo = null, this.transform = null;
  }
  get bandInfos() {
    const t11 = this.keyProperties.BandProperties;
    if (!(t11 == null ? void 0 : t11.length)) {
      const t12 = [];
      for (let e9 = 1; e9 <= this.bandCount; e9++)
        t12.push(new s10({ name: "band_" + e9 }));
      return t12;
    }
    const e8 = t11.map((t12) => s10.fromJSON(t12));
    for (let o10 = 0; o10 < e8.length; o10++)
      e8[o10].name = e8[o10].name ?? "band_" + (o10 + 1);
    return e8;
  }
  get dataType() {
    var _a, _b;
    const t11 = ((_b = (_a = this.keyProperties) == null ? void 0 : _a.DataType) == null ? void 0 : _b.toLowerCase()) ?? "generic";
    return "stdtime" === t11 ? "standard-time" : t11;
  }
  get nativeExtent() {
    return this._get("nativeExtent") || this.extent;
  }
  set nativeExtent(t11) {
    t11 && this._set("nativeExtent", t11);
  }
  get nativePixelSize() {
    if (null == this.transform || !this.transform.affectsPixelSize)
      return this.pixelSize;
    const t11 = this.nativeExtent;
    return { x: t11.width / this.width, y: t11.height / this.height };
  }
  get hasMultidimensionalTranspose() {
    var _a;
    return !!((_a = this.storageInfo) == null ? void 0 : _a.transposeInfo);
  }
  get sensorInfo() {
    var _a;
    if ((_a = this.keyProperties) == null ? void 0 : _a.SensorName)
      return p7.fromJSON(this.keyProperties);
  }
  clone() {
    return new h6({ attributeTable: a(this.attributeTable), bandCount: this.bandCount, colormap: a(this.colormap), extent: a(this.extent), nativePixelSize: a(this.nativePixelSize), format: this.format, height: this.height, width: this.width, histograms: a(this.histograms), keyProperties: a(this.keyProperties), multidimensionalInfo: a(this.multidimensionalInfo), noDataValue: this.noDataValue, pixelSize: a(this.pixelSize), pixelType: this.pixelType, isPseudoSpatialReference: this.isPseudoSpatialReference, spatialReference: a(this.spatialReference), statistics: a(this.statistics), storageInfo: a(this.storageInfo), transform: a(this.transform) });
  }
};
e([y({ json: { write: true } })], u9.prototype, "attributeTable", void 0), e([y({ json: { write: true } })], u9.prototype, "bandCount", void 0), e([y({ readOnly: true })], u9.prototype, "bandInfos", null), e([y({ json: { write: true } })], u9.prototype, "colormap", void 0), e([y({ type: String, readOnly: true })], u9.prototype, "dataType", null), e([y({ type: M, json: { write: true } })], u9.prototype, "extent", void 0), e([y({ type: M, json: { write: true } })], u9.prototype, "nativeExtent", null), e([y({ json: { write: true } })], u9.prototype, "nativePixelSize", null), e([y({ json: { write: true } })], u9.prototype, "format", void 0), e([y({ json: { write: true } })], u9.prototype, "height", void 0), e([y({ json: { write: true } })], u9.prototype, "width", void 0), e([y({ json: { write: true } })], u9.prototype, "hasMultidimensionalTranspose", null), e([y({ json: { write: true } })], u9.prototype, "histograms", void 0), e([y({ json: { write: true } })], u9.prototype, "keyProperties", void 0), e([y({ json: { write: true } })], u9.prototype, "multidimensionalInfo", void 0), e([y({ json: { write: true } })], u9.prototype, "noDataValue", void 0), e([y({ json: { write: true } })], u9.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], u9.prototype, "pixelType", void 0), e([y()], u9.prototype, "isPseudoSpatialReference", void 0), e([y({ readOnly: true })], u9.prototype, "sensorInfo", null), e([y({ type: f, json: { write: true } })], u9.prototype, "spatialReference", void 0), e([y({ json: { write: true } })], u9.prototype, "statistics", void 0), e([y({ type: n10, json: { write: true } })], u9.prototype, "storageInfo", void 0), e([y({ json: { write: true } })], u9.prototype, "transform", void 0), u9 = h6 = e([a2("esri.layers.support.RasterInfo")], u9);
var m5 = u9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/surfaceUtils.js
var i8 = 1;
var s11 = 1 / 111e3;
function n11(t11) {
  let { altitude: e8, azimuth: i11 } = t11;
  const { hillshadeType: n14, pixelSizePower: a16 = 1, pixelSizeFactor: l9 = 1, scalingType: o10, isGCS: r16, resolution: c11 } = t11, h10 = "multi-directional" === n14 ? 2 * t11.zFactor : t11.zFactor, { x: u14, y: f11 } = c11;
  let d8 = h10 / (8 * u14), p10 = h10 / (8 * f11);
  if (r16 && h10 > 1e-3 && (d8 /= s11, p10 /= s11), "adjusted" === o10)
    if (r16) {
      const t12 = u14 * s11, e9 = f11 * s11;
      d8 = (h10 + t12 ** a16 * l9) / (8 * t12), p10 = (h10 + e9 ** a16 * l9) / (8 * e9);
    } else
      d8 = (h10 + u14 ** a16 * l9) / (8 * u14), p10 = (h10 + f11 ** a16 * l9) / (8 * f11);
  let x6 = (90 - e8) * Math.PI / 180, w6 = Math.cos(x6), y7 = (360 - i11 + 90) * Math.PI / 180, M6 = Math.sin(x6) * Math.cos(y7), m8 = Math.sin(x6) * Math.sin(y7);
  const A4 = [315, 270, 225, 360, 180, 0], g7 = [60, 60, 60, 60, 60, 90], k5 = new Float32Array([3, 5, 3, 2, 1, 4]), z2 = k5.reduce((t12, e9) => t12 + e9), F2 = k5.map((t12) => t12 / z2), P4 = "multi-directional" === n14 ? A4.length : 1, C6 = new Float32Array(6), Z = new Float32Array(6), v6 = new Float32Array(6);
  if ("multi-directional" === n14)
    for (let s14 = 0; s14 < P4; s14++)
      e8 = g7[s14], i11 = A4[s14], x6 = (90 - e8) * Math.PI / 180, w6 = Math.cos(x6), y7 = (360 - i11 + 90) * Math.PI / 180, M6 = Math.sin(x6) * Math.cos(y7), m8 = Math.sin(x6) * Math.sin(y7), C6[s14] = w6, Z[s14] = M6, v6[s14] = m8;
  else
    C6.fill(w6), Z.fill(M6), v6.fill(m8);
  return { resolution: c11, factor: [d8, p10], sinZcosA: M6, sinZsinA: m8, cosZ: w6, sinZcosAs: Z, sinZsinAs: v6, cosZs: C6, weights: F2, hillshadeType: ["traditional", "multi-directional"].indexOf(n14) };
}
function a13(t11, e8) {
  const { width: s14, height: n14 } = t11, a16 = s14 * n14, l9 = new Uint8Array(a16), o10 = null != t11.mask;
  let r16;
  if (o10) {
    r16 = new Uint8Array(t11.mask);
    for (let t12 = 0; t12 < r16.length; t12++)
      r16[t12] && (l9[t12] = 1, r16[t12] = 1);
  }
  const c11 = t11.pixels[0], h10 = new Float32Array(a16), u14 = new Float32Array(a16);
  let f11, d8 = 0;
  if (e8) {
    const { resolution: t12 } = e8, i11 = t12 ? (t12.x + t12.y) / 2 : 1;
    d8 = 200 * e8.zFactor / (i11 * i11), f11 = new Float32Array(a16);
  }
  const p10 = e8 == null ? void 0 : e8.curvatureType;
  let x6, w6, y7, M6, m8, A4, g7, k5;
  for (let z2 = i8; z2 < n14 - i8; z2++) {
    const t12 = z2 * s14;
    for (let e9 = i8; e9 < s14 - i8; e9++) {
      const i11 = t12 + e9;
      if (!r16 || 0 !== r16[i11]) {
        if (r16) {
          if (r16[i11 - s14 - 1] + r16[i11 - s14] + r16[i11 - s14 + 1] + r16[i11 - 1] + r16[i11 + 1] + r16[i11 + s14 - 1] + r16[i11 + s14] + r16[i11 + s14 + 1] < 7) {
            l9[i11] = 0;
            continue;
          }
          x6 = r16[i11 - s14 - 1] ? c11[i11 - s14 - 1] : c11[i11], w6 = r16[i11 - s14] ? c11[i11 - s14] : c11[i11], y7 = r16[i11 - s14 + 1] ? c11[i11 - s14 + 1] : c11[i11], M6 = r16[i11 - 1] ? c11[i11 - 1] : c11[i11], m8 = r16[i11 + 1] ? c11[i11 + 1] : c11[i11], A4 = r16[i11 + s14 - 1] ? c11[i11 + s14 - 1] : c11[i11], g7 = r16[i11 + s14] ? c11[i11 + s14] : c11[i11], k5 = r16[i11 + s14 + 1] ? c11[i11 + s14 + 1] : c11[i11];
        } else
          x6 = c11[i11 - s14 - 1], w6 = c11[i11 - s14], y7 = c11[i11 - s14 + 1], M6 = c11[i11 - 1], m8 = c11[i11 + 1], A4 = c11[i11 + s14 - 1], g7 = c11[i11 + s14], k5 = c11[i11 + s14 + 1];
        if (h10[i11] = y7 + m8 + m8 + k5 - (x6 + M6 + M6 + A4), u14[i11] = A4 + g7 + g7 + k5 - (x6 + w6 + w6 + y7), null != f11) {
          const t13 = c11[i11], e10 = 0.5 * (M6 + m8) - t13, s15 = 0.5 * (w6 + g7) - t13;
          if ("standard" === p10)
            f11[i11] = -d8 * (e10 + s15);
          else {
            const t14 = (-x6 + y7 + A4 - k5) / 4, n15 = (-M6 + m8) / 2, a17 = (w6 - g7) / 2, l10 = n15 * n15, o11 = a17 * a17, r17 = l10 + o11;
            r17 && (f11[i11] = "profile" === p10 ? d8 * (e10 * l10 + s15 * o11 + t14 * n15 * a17) / r17 : -d8 * (e10 * o11 + s15 * l10 - t14 * n15 * a17) / r17);
          }
        }
      }
    }
  }
  return { outMask: o10 ? l9 : null, dzxs: h10, dzys: u14, curvatures: f11 };
}
function l8(t11, e8, i11) {
  for (let s14 = 0; s14 < i11; s14++)
    t11[s14 * e8] = t11[s14 * e8 + 1], t11[(s14 + 1) * e8 - 1] = t11[(s14 + 1) * e8 - 2];
  for (let s14 = 1; s14 < e8 - 1; s14++)
    t11[s14] = t11[s14 + e8], t11[s14 + (i11 - 1) * e8] = t11[s14 + (i11 - 2) * e8];
}
function o8(s14, o10) {
  if (!o4(s14))
    return s14;
  const { factor: r16, sinZcosA: c11, sinZsinA: h10, cosZ: u14, sinZcosAs: f11, sinZsinAs: d8, cosZs: p10, weights: x6 } = n11(o10), [w6, y7] = r16, M6 = "traditional" === o10.hillshadeType, { width: m8, height: A4 } = s14, g7 = new Uint8Array(m8 * A4), { dzxs: k5, dzys: z2, outMask: F2 } = a13(s14);
  for (let t11 = i8; t11 < A4 - i8; t11++) {
    const e8 = t11 * m8;
    for (let t12 = i8; t12 < m8 - i8; t12++) {
      const i11 = e8 + t12;
      if (!F2 || F2[i11]) {
        const t13 = k5[i11] * w6, e9 = z2[i11] * y7, s15 = Math.sqrt(1 + t13 * t13 + e9 * e9);
        let n14 = 0;
        if (M6) {
          let i12 = 255 * (u14 + h10 * e9 - c11 * t13) / s15;
          i12 < 0 && (i12 = 0), n14 = i12;
        } else {
          const i12 = d8.length;
          for (let a16 = 0; a16 < i12; a16++) {
            let i13 = 255 * (p10[a16] + d8[a16] * e9 - f11[a16] * t13) / s15;
            i13 < 0 && (i13 = 0), n14 += i13 * x6[a16];
          }
        }
        g7[i11] = 255 & n14;
      }
    }
  }
  l8(g7, m8, A4);
  return new u2({ width: m8, height: A4, pixels: [g7], mask: F2, pixelType: "u8", validPixelCount: s14.validPixelCount, statistics: [{ minValue: 0, maxValue: 255 }] });
}
function r14(t11, i11, s14, n14) {
  if (!o4(t11) || !o4(i11))
    return;
  const { min: a16, max: l9 } = n14, o10 = t11.pixels[0], { pixels: r16, mask: c11 } = i11, h10 = r16[0], u14 = 255.00001 / (l9 - a16), f11 = new Uint8ClampedArray(h10.length), d8 = new Uint8ClampedArray(h10.length), p10 = new Uint8ClampedArray(h10.length), x6 = s14.length - 1;
  for (let e8 = 0; e8 < h10.length; e8++) {
    if (c11 && 0 === c11[e8])
      continue;
    const t12 = Math.floor((h10[e8] - a16) * u14), [i12, n15] = s14[t12 < 0 ? 0 : t12 > x6 ? x6 : t12], l10 = o10[e8], r17 = l10 * n15, w6 = r17 * (1 - Math.abs(i12 % 2 - 1)), y7 = l10 - r17;
    switch (Math.floor(i12)) {
      case 0:
        f11[e8] = r17 + y7, d8[e8] = w6 + y7, p10[e8] = y7;
        break;
      case 1:
        f11[e8] = w6 + y7, d8[e8] = r17 + y7, p10[e8] = y7;
        break;
      case 2:
        f11[e8] = y7, d8[e8] = r17 + y7, p10[e8] = w6 + y7;
        break;
      case 3:
        f11[e8] = y7, d8[e8] = w6 + y7, p10[e8] = r17 + y7;
        break;
      case 4:
        f11[e8] = w6 + y7, d8[e8] = y7, p10[e8] = r17 + y7;
        break;
      case 5:
      case 6:
        f11[e8] = r17 + y7, d8[e8] = y7, p10[e8] = w6 + y7;
    }
  }
  t11.pixels = [f11, d8, p10], t11.updateStatistics();
}
function c8(n14, o10) {
  if (!o4(n14))
    return n14;
  const r16 = o10.zFactor, c11 = o10.pixelSizePower ?? 1, h10 = o10.pixelSizeFactor ?? 1, u14 = o10.slopeType, f11 = o10.isGCS, { x: d8, y: p10 } = o10.resolution;
  let x6 = r16 / (8 * d8), w6 = r16 / (8 * p10);
  f11 && Math.abs(r16 - 1) < 1e-4 && (x6 /= s11, w6 /= s11), "adjusted" === u14 && (x6 = (r16 + d8 ** c11 * h10) / (8 * d8), w6 = (r16 + p10 ** c11 * h10) / (8 * p10));
  const { dzxs: y7, dzys: M6, outMask: m8 } = a13(n14), { width: A4, height: g7 } = n14, k5 = new Float32Array(A4 * g7);
  for (let t11 = i8; t11 < g7 - i8; t11++) {
    const e8 = t11 * A4;
    for (let t12 = i8; t12 < A4 - i8; t12++) {
      const i11 = e8 + t12;
      if (!m8 || m8[i11]) {
        const s14 = y7[i11] * x6, n15 = M6[i11] * w6, a16 = Math.sqrt(s14 * s14 + n15 * n15);
        k5[e8 + t12] = "percent-rise" === u14 ? 100 * a16 : 57.2957795 * Math.atan(a16);
      }
    }
  }
  l8(k5, A4, g7);
  const z2 = new u2({ width: A4, height: g7, pixels: [k5], mask: m8, pixelType: "f32", validPixelCount: n14.validPixelCount });
  return z2.updateStatistics(), z2;
}
function h7(s14, n14 = {}) {
  if (!o4(s14))
    return s14;
  const { resolution: o10 } = n14, r16 = o10 ? 1 / o10.x : 1, c11 = o10 ? 1 / o10.y : 1, { dzxs: h10, dzys: u14, outMask: f11 } = a13(s14), { width: d8, height: p10 } = s14, x6 = new Float32Array(d8 * p10);
  for (let t11 = i8; t11 < p10 - i8; t11++) {
    const e8 = t11 * d8;
    for (let t12 = i8; t12 < d8 - i8; t12++) {
      const i11 = e8 + t12;
      if (!f11 || f11[i11]) {
        const s15 = h10[i11] * r16, n15 = u14[i11] * c11;
        let a16 = -1;
        0 === s15 && 0 === n15 || (a16 = 90 - 57.29578 * Math.atan2(n15, -s15), a16 < 0 && (a16 += 360), 360 === a16 ? a16 = 0 : a16 > 360 && (a16 %= 360)), x6[e8 + t12] = a16;
      }
    }
  }
  l8(x6, d8, p10);
  return new u2({ width: d8, height: p10, pixels: [x6], mask: f11, pixelType: "f32", validPixelCount: s14.validPixelCount, statistics: [{ minValue: -1, maxValue: 360 }] });
}
function u10(i11, s14) {
  if (!o4(i11))
    return i11;
  const { curvatures: n14, outMask: o10 } = a13(i11, s14), { width: r16, height: c11 } = i11;
  l8(n14, r16, c11);
  const h10 = new u2({ width: r16, height: c11, pixels: [n14], mask: o10, pixelType: "f32", validPixelCount: i11.validPixelCount });
  return h10.updateStatistics(), h10;
}

// node_modules/@arcgis/core/renderers/support/colorRampUtils.js
var n12 = ["random", "ndvi", "ndvi2", "ndvi3", "elevation", "gray", "hillshade"];
var C4 = [{ id: "aspect", type: "multipart", colorRamps: [{ fromColor: [190, 190, 190], toColor: [255, 45, 8] }, { fromColor: [255, 45, 8], toColor: [255, 181, 61] }, { fromColor: [255, 181, 61], toColor: [255, 254, 52] }, { fromColor: [255, 254, 52], toColor: [0, 251, 50] }, { fromColor: [0, 251, 50], toColor: [255, 254, 52] }, { fromColor: [0, 253, 255], toColor: [0, 181, 255] }, { fromColor: [0, 181, 255], toColor: [26, 35, 253] }, { fromColor: [26, 35, 253], toColor: [255, 57, 251] }, { fromColor: [255, 57, 251], toColor: [255, 45, 8] }] }, { id: "black-to-white", fromColor: [0, 0, 0], toColor: [255, 255, 255] }, { id: "blue-bright", fromColor: [204, 204, 255], toColor: [0, 0, 224] }, { id: "blue-light-to-dark", fromColor: [211, 229, 232], toColor: [46, 100, 140] }, { id: "blue-green-bright", fromColor: [203, 245, 234], toColor: [48, 207, 146] }, { id: "blue-green-light-to-dark", fromColor: [216, 242, 237], toColor: [21, 79, 74] }, { id: "brown-light-to-dark", fromColor: [240, 236, 170], toColor: [102, 72, 48] }, { id: "brown-to-blue-green-diverging-right", type: "multipart", colorRamps: [{ fromColor: [156, 85, 31], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [33, 130, 145] }] }, { id: "brown-to-blue-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [110, 70, 45], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [48, 100, 102] }] }, { id: "coefficient-bias", fromColor: [214, 214, 255], toColor: [0, 57, 148] }, { id: "cold-to-hot-diverging", type: "multipart", colorRamps: [{ fromColor: [69, 117, 181], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [214, 47, 39] }] }, { id: "condition-number", type: "multipart", colorRamps: [{ fromColor: [0, 97, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 34, 0] }] }, { id: "cyan-to-purple", type: "multipart", colorRamps: [{ fromColor: [0, 245, 245], toColor: [0, 0, 245] }, { fromColor: [0, 0, 245], toColor: [245, 0, 245] }] }, { id: "cyan-light-to-blue-dark", type: "multipart", colorRamps: [{ fromColor: [182, 237, 240], toColor: [31, 131, 224] }, { fromColor: [31, 131, 224], toColor: [9, 9, 145] }] }, { id: "distance", fromColor: [255, 200, 0], toColor: [0, 0, 255] }, { id: "elevation1", type: "multipart", colorRamps: [{ fromColor: [175, 240, 233], toColor: [255, 255, 179] }, { fromColor: [255, 255, 179], toColor: [0, 128, 64] }, { fromColor: [0, 128, 64], toColor: [252, 186, 3] }, { fromColor: [252, 186, 3], toColor: [128, 0, 0] }, { fromColor: [120, 0, 0], toColor: [105, 48, 13] }, { fromColor: [105, 48, 13], toColor: [171, 171, 171] }, { fromColor: [171, 171, 171], toColor: [255, 252, 255] }] }, { id: "elevation2", type: "multipart", colorRamps: [{ fromColor: [118, 219, 211], toColor: [255, 255, 199] }, { fromColor: [255, 255, 199], toColor: [255, 255, 128] }, { fromColor: [255, 255, 128], toColor: [217, 194, 121] }, { fromColor: [217, 194, 121], toColor: [135, 96, 38] }, { fromColor: [135, 96, 38], toColor: [150, 150, 181] }, { fromColor: [150, 150, 181], toColor: [181, 150, 181] }, { fromColor: [181, 150, 181], toColor: [255, 252, 255] }] }, { id: "errors", fromColor: [255, 235, 214], toColor: [196, 10, 10] }, { id: "gray-light-to-dark", fromColor: [219, 219, 219], toColor: [69, 69, 69] }, { id: "green-bright", fromColor: [204, 255, 204], toColor: [14, 204, 14] }, { id: "green-light-to-dark", fromColor: [220, 245, 233], toColor: [34, 102, 51] }, { id: "green-to-blue", type: "multipart", colorRamps: [{ fromColor: [32, 204, 16], toColor: [0, 242, 242] }, { fromColor: [0, 242, 242], toColor: [2, 33, 227] }] }, { id: "orange-bright", fromColor: [255, 235, 204], toColor: [240, 118, 5] }, { id: "orange-light-to-dark", fromColor: [250, 233, 212], toColor: [171, 65, 36] }, { id: "partial-spectrum", type: "multipart", colorRamps: [{ fromColor: [242, 241, 162], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }, { fromColor: [252, 3, 69], toColor: [176, 7, 237] }, { fromColor: [176, 7, 237], toColor: [2, 29, 173] }] }, { id: "partial-spectrum-1-diverging", type: "multipart", colorRamps: [{ fromColor: [135, 38, 38], toColor: [240, 149, 12] }, { fromColor: [240, 149, 12], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [74, 80, 181] }, { fromColor: [74, 80, 181], toColor: [39, 32, 122] }] }, { id: "partial-spectrum-2-diverging", type: "multipart", colorRamps: [{ fromColor: [115, 77, 42], toColor: [201, 137, 52] }, { fromColor: [201, 137, 52], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [91, 63, 176] }, { fromColor: [91, 63, 176], toColor: [81, 13, 97] }] }, { id: "pink-to-yellow-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [158, 30, 113], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [99, 110, 45] }] }, { id: "pink-to-yellow-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [97, 47, 73], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [22, 59, 15] }] }, { id: "precipitation", type: "multipart", colorRamps: [{ fromColor: [194, 82, 60], toColor: [237, 161, 19] }, { fromColor: [237, 161, 19], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 219, 0] }, { fromColor: [0, 219, 0], toColor: [32, 153, 143] }, { fromColor: [32, 153, 143], toColor: [11, 44, 122] }] }, { id: "prediction", type: "multipart", colorRamps: [{ fromColor: [40, 146, 199], toColor: [250, 250, 100] }, { fromColor: [250, 250, 100], toColor: [232, 16, 20] }] }, { id: "purple-bright", fromColor: [255, 204, 255], toColor: [199, 0, 199] }, { id: "purple-to-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [77, 32, 150], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [20, 122, 11] }] }, { id: "purple-to-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [67, 14, 89], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [24, 79, 15] }] }, { id: "purple-blue-bright", fromColor: [223, 184, 230], toColor: [112, 12, 242] }, { id: "purple-blue-light-to-dark", fromColor: [229, 213, 242], toColor: [93, 44, 112] }, { id: "purple-red-bright", fromColor: [255, 204, 225], toColor: [199, 0, 99] }, { id: "purple-red-light-to-dark", fromColor: [250, 215, 246], toColor: [143, 17, 57] }, { id: "red-bright", fromColor: [255, 204, 204], toColor: [219, 0, 0] }, { id: "red-light-to-dark", fromColor: [255, 224, 224], toColor: [143, 10, 10] }, { id: "red-to-blue-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [196, 69, 57], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [48, 95, 207] }] }, { id: "red-to-blue-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [107, 13, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [13, 53, 97] }] }, { id: "red-to-green", type: "multipart", colorRamps: [{ fromColor: [245, 0, 0], toColor: [245, 245, 0] }, { fromColor: [245, 245, 0], toColor: [0, 245, 0] }] }, { id: "red-to-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [186, 20, 20], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [54, 145, 33] }] }, { id: "red-to-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [97, 21, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [16, 69, 16] }] }, { id: "slope", type: "multipart", colorRamps: [{ fromColor: [56, 168, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }] }, { id: "spectrum-full-bright", type: "multipart", colorRamps: [{ fromColor: [255, 0, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 0, 255] }] }, { id: "spectrum-full-dark", type: "multipart", colorRamps: [{ fromColor: [153, 0, 0], toColor: [153, 153, 0] }, { fromColor: [153, 153, 0], toColor: [0, 153, 153] }, { fromColor: [0, 153, 153], toColor: [0, 0, 153] }] }, { id: "spectrum-full-light", type: "multipart", colorRamps: [{ fromColor: [255, 153, 153], toColor: [255, 255, 153] }, { fromColor: [255, 255, 153], toColor: [153, 255, 255] }, { fromColor: [153, 255, 255], toColor: [153, 153, 255] }] }, { id: "surface", type: "multipart", colorRamps: [{ fromColor: [112, 153, 89], toColor: [242, 238, 162] }, { fromColor: [242, 238, 162], toColor: [242, 206, 133] }, { fromColor: [242, 206, 133], toColor: [194, 140, 124] }, { fromColor: [194, 140, 124], toColor: [255, 242, 255] }] }, { id: "temperature", type: "multipart", colorRamps: [{ fromColor: [255, 252, 255], toColor: [255, 0, 255] }, { fromColor: [255, 0, 255], toColor: [0, 0, 255] }, { fromColor: [0, 0, 255], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 255, 0] }, { fromColor: [0, 255, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 128, 0] }, { fromColor: [255, 128, 0], toColor: [128, 0, 0] }] }, { id: "white-to-black", fromColor: [255, 255, 255], toColor: [0, 0, 0] }, { id: "yellow-to-dark-red", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [242, 167, 46] }, { fromColor: [242, 167, 46], toColor: [107, 0, 0] }] }, { id: "yellow-to-green-to-dark-blue", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [56, 224, 9] }, { fromColor: [56, 224, 9], toColor: [26, 147, 171] }, { fromColor: [26, 147, 171], toColor: [12, 16, 120] }] }, { id: "yellow-to-red", fromColor: [245, 245, 0], toColor: [255, 0, 0] }, { id: "yellow-green-bright", fromColor: [236, 252, 204], toColor: [157, 204, 16] }, { id: "yellow-green-light-to-dark", fromColor: [215, 240, 175], toColor: [96, 107, 45] }];
var a14 = new s4({ Aspect: "aspect", "Black to White": "black-to-white", "Blue Bright": "blue-bright", "Blue Light to Dark": "blue-light-to-dark", "Blue-Green Bright": "blue-green-bright", "Blue-Green Light to Dark": "blue-green-light-to-dark", "Brown Light to Dark": "brown-light-to-dark", "Brown to Blue Green Diverging, Bright": "brown-to-blue-green-diverging-right", "Brown to Blue Green Diverging, Dark": "brown-to-blue-green-diverging-dark", "Coefficient Bias": "coefficient-bias", "Cold to Hot Diverging": "cold-to-hot-diverging", "Condition Number": "condition-number", "Cyan to Purple": "cyan-to-purple", "Cyan-Light to Blue-Dark": "cyan-light-to-blue-dark", Distance: "distance", "Elevation #1": "elevation1", "Elevation #2": "elevation2", Errors: "errors", "Gray Light to Dark": "gray-light-to-dark", "Green Bright": "green-bright", "Green Light to Dark": "green-light-to-dark", "Green to Blue": "green-to-blue", "Orange Bright": "orange-bright", "Orange Light to Dark": "orange-light-to-dark", "Partial Spectrum": "partial-spectrum", "Partial Spectrum 1 Diverging": "partial-spectrum-1-diverging", "Partial Spectrum 2 Diverging": "partial-spectrum-2-diverging", "Pink to YellowGreen Diverging, Bright": "pink-to-yellow-green-diverging-bright", "Pink to YellowGreen Diverging, Dark": "pink-to-yellow-green-diverging-dark", Precipitation: "precipitation", Prediction: "prediction", "Purple Bright": "purple-bright", "Purple to Green Diverging, Bright": "purple-to-green-diverging-bright", "Purple to Green Diverging, Dark": "purple-to-green-diverging-dark", "Purple-Blue Bright": "purple-blue-bright", "Purple-Blue Light to Dark": "purple-blue-light-to-dark", "Purple-Red Bright": "purple-red-bright", "Purple-Red Light to Dark": "purple-red-light-to-dark", "Red Bright": "red-bright", "Red Light to Dark": "red-light-to-dark", "Red to Blue Diverging, Bright": "red-to-blue-diverging-bright", "Red to Blue Diverging, Dark": "red-to-blue-diverging-dark", "Red to Green": "red-to-green", "Red to Green Diverging, Bright": "red-to-green-diverging-bright", "Red to Green Diverging, Dark": "red-to-green-diverging-dark", Slope: "slope", "Spectrum-Full Bright": "spectrum-full-bright", "Spectrum-Full Dark": "spectrum-full-dark", "Spectrum-Full Light": "spectrum-full-light", Surface: "surface", Temperature: "temperature", "White to Black": "white-to-black", "Yellow to Dark Red": "yellow-to-dark-red", "Yellow to Green to Dark Blue": "yellow-to-green-to-dark-blue", "Yellow to Red": "yellow-to-red", "Yellow-Green Bright": "yellow-green-bright", "Yellow-Green Light to Dark": "yellow-green-light-to-dark" });
function m6(o10, r16) {
  if (!o10 || !r16 || o10.length !== r16.length)
    return false;
  for (let t11 = 0; t11 < o10.length; t11++)
    if (o10[t11] > r16[t11] + 2 || o10[t11] < r16[t11] - 2)
      return false;
  return true;
}
function g6(o10) {
  const r16 = o10.clone();
  return r16.fromColor = o10.toColor, r16.toColor = o10.fromColor, r16.algorithm = o10.algorithm, r16;
}
function p9(o10) {
  var _a;
  if ("multipart" === o10.type) {
    const r16 = o10.clone();
    return ((_a = r16.colorRamps) == null ? void 0 : _a.length) ? (r16.colorRamps = r16.colorRamps.reverse().map((o11) => g6(o11)), r16) : r16;
  }
  return g6(o10);
}
function u11(r16, t11) {
  if (!r16)
    return;
  const l9 = t11 ?? C4;
  let e8 = null;
  return "algorithmic" === r16.type ? l9.some((o10) => {
    if (m6(r16.fromColor.toRgb(), o10.fromColor) && m6(r16.toColor.toRgb(), o10.toColor))
      return e8 = o10.id, true;
  }) : "multipart" === r16.type && l9.some((t12) => {
    const l10 = r16.colorRamps, i11 = t12.colorRamps;
    if (l10 && i11 && l10.length === i11.length && !i11.some((r17, t13) => {
      if (!m6(l10[t13].fromColor.toRgb(), new h(r17.fromColor).toRgb()) || !m6(l10[t13].toColor.toRgb(), new h(r17.toColor).toRgb()))
        return true;
    })) {
      if (e8)
        return true;
      e8 = t12.id;
    }
  }), e8;
}
function f9(o10, r16, t11 = false) {
  if (!o10)
    return;
  let l9 = u11(o10, r16);
  return null != l9 || t11 || (l9 = u11(o10 = p9(o10), r16)), l9;
}
function s12(o10, r16 = false) {
  const t11 = "string" == typeof o10 ? o10 : f9(o10, void 0, r16);
  return t11 ? a14.toJSON(t11) : null;
}
function c9(o10, r16 = "esriCIELabAlgorithm") {
  const t11 = C4.find(({ id: r17 }) => r17 === o10);
  return t11 ? t11.colorRamps ? { type: "multipart", colorRamps: t11.colorRamps.map((o11) => ({ type: "algorithmic", algorithm: r16, fromColor: [...o11.fromColor], toColor: [...o11.toColor] })) } : { type: "algorithmic", algorithm: r16, fromColor: [...t11.fromColor], toColor: [...t11.toColor] } : null;
}
function d5(o10) {
  const r16 = (o10 = o10 || {}).numColors || 256, t11 = o10.distanceOffset || 0, l9 = null != o10.isCustomInterval ? o10.isCustomInterval : null !== o10.distanceInterval && o10.distanceInterval !== 1 / (r16 - 1), e8 = o10.distanceInterval || 1 / (r16 - 1);
  return { ...o10, numColors: r16, distanceOffset: t11, interpolateAlpha: !!o10.interpolateAlpha, distanceInterval: e8, isCustomInterval: l9, weights: o10.weights };
}
function h8(o10, r16, t11) {
  const { numColors: l9, distanceOffset: e8, distanceInterval: i11, isCustomInterval: n14 } = t11, C6 = 0 === o10.s, a16 = 0 === r16.s;
  let m8 = o10.h, g7 = r16.h;
  C6 && !a16 ? m8 = g7 : a16 && !C6 && (r16 = { ...r16, h: m8 }, g7 = m8);
  let p10, u14 = Math.abs(g7 - m8);
  const f11 = 360;
  u14 < f11 / 2 ? p10 = (g7 - m8) * i11 : (u14 = f11 - u14, p10 = m8 > g7 ? u14 * i11 : -u14 * i11);
  const s14 = (r16.s - o10.s) * i11, c11 = (r16.v - o10.v) * i11;
  let { s: d8, v: h10 } = o10, b5 = m8;
  if (e8) {
    const o11 = e8 / i11;
    b5 = (b5 + o11 * p10 + f11) % f11, d8 += o11 * s14, h10 += o11 * c11;
  }
  const v6 = [];
  for (let k5 = 0; k5 < l9 - 1; k5++)
    v6.push({ h: b5, s: d8, v: h10 }), b5 = (b5 + p10 + f11) % f11, d8 += s14, h10 += c11;
  return v6.push(n14 ? { h: b5, s: d8, v: h10 } : r16), v6;
}
function b4(o10, r16, t11) {
  const { numColors: l9, distanceOffset: e8, distanceInterval: i11, isCustomInterval: n14 } = t11;
  let { l: C6, a: a16, b: m8 } = o10;
  const g7 = (r16.l - C6) * i11, p10 = (r16.a - a16) * i11, u14 = (r16.b - m8) * i11, f11 = [];
  if (e8) {
    const o11 = e8 / i11;
    C6 += o11 * g7, a16 += o11 * p10, m8 += o11 * u14;
  }
  for (let s14 = 0; s14 < l9 - 1; s14++)
    f11.push({ l: C6, a: a16, b: m8 }), C6 += g7, a16 += p10, m8 += u14;
  return f11.push(n14 ? { l: C6, a: a16, b: m8 } : r16), f11;
}
function v5(o10, r16, t11) {
  const { numColors: l9, distanceOffset: e8, distanceInterval: i11, isCustomInterval: n14 } = t11, C6 = o10.h, a16 = r16.h, m8 = 2 * Math.PI;
  let g7;
  if (C6 <= a16) {
    const o11 = a16 - C6, r17 = a16 - C6 - m8;
    g7 = Math.abs(r17) < Math.abs(o11) ? r17 : o11;
  } else {
    const o11 = a16 + m8 - C6, r17 = a16 - C6;
    g7 = Math.abs(r17) < Math.abs(o11) ? r17 : o11;
  }
  const p10 = g7 * i11, u14 = (r16.l - o10.l) * i11, f11 = (r16.c - o10.c) * i11;
  let { l: s14, c: c11, h: d8 } = o10;
  if (e8) {
    const o11 = e8 / i11;
    s14 += o11 * u14, c11 += o11 * f11, d8 = (d8 + o11 * p10 + m8) % m8;
  }
  const h10 = [];
  for (let b5 = 0; b5 < l9 - 1; b5++)
    h10.push({ l: s14, c: c11, h: d8 }), s14 += u14, c11 += f11, d8 = (d8 + p10 + m8) % m8;
  return h10.push(n14 ? { l: s14, c: c11, h: d8 } : r16), h10;
}
function k4(o10, i11) {
  let { fromColor: n14, toColor: C6 } = o10;
  n14 = [...n14], C6 = [...C6], 3 === n14.length && (n14 = n14.concat([255])), 3 === C6.length && (C6 = C6.concat([255]));
  const a16 = o10.algorithm || "esriCIELabAlgorithm", m8 = d5(i11), { numColors: g7, distanceOffset: p10, isCustomInterval: u14, interpolateAlpha: f11 } = m8;
  if (1 === g7 && 0 === p10)
    return [n14];
  if (2 === g7 && 0 === p10 && !u14)
    return [n14, C6];
  const s14 = { r: n14[0], g: n14[1], b: n14[2] }, c11 = { r: C6[0], g: C6[1], b: C6[2] }, k5 = "esriCIELabAlgorithm" === a16 ? b4(z(s14), z(c11), m8) : "esriHSVAlgorithm" === a16 ? h8(y2(s14), y2(c11), m8) : v5(v(s14), v(c11), m8), y7 = [], R4 = n14[3] ?? 255, w6 = ((C6[3] ?? 255) - R4) / (g7 - 1);
  for (let r16 = 0; r16 < g7; r16++) {
    const { r: o11, g: t11, b: l9 } = p(k5[r16]), i12 = f11 ? Math.round(R4 + w6 * r16) : 255;
    y7.push([o11, t11, l9, i12]);
  }
  return y7;
}
function y6(o10, r16) {
  const { numColors: t11, interpolateAlpha: l9 } = d5(r16);
  let e8 = r16 == null ? void 0 : r16.weights;
  const { colorRamps: i11 } = o10;
  if (e8) {
    const o11 = e8.reduce((o12, r17) => o12 + r17);
    e8 = e8.map((r17) => r17 / o11);
  } else {
    e8 = [];
    for (let o11 = 0; o11 < i11.length; o11++)
      e8[o11] = 1 / i11.length;
  }
  const n14 = [];
  let C6 = 0, a16 = 0;
  const m8 = 1 / (t11 - 1);
  let g7 = false;
  for (let u14 = 0; u14 < i11.length; u14++) {
    let o11 = g7 ? 0 : C6 * m8 - a16, r17 = u14 === i11.length - 1 ? t11 - 1 - C6 : (e8[u14] - o11) / m8;
    if (g7 = Math.ceil(r17) === r17, r17 = Math.ceil(r17), 0 === r17)
      continue;
    o11 /= e8[u14];
    const p11 = k4(i11[u14], { numColors: r17, interpolateAlpha: l9, distanceOffset: o11, distanceInterval: m8 / e8[u14] });
    C6 += p11.length, n14.push(...p11), a16 += e8[u14];
  }
  const p10 = [...i11[i11.length - 1].toColor];
  return 3 === p10.length && p10.push(255), n14.push(p10), n14;
}
function R3(o10, r16) {
  const t11 = "toJSON" in o10 ? o10.toJSON() : o10;
  return "multipart" === t11.type ? y6(t11, r16) : k4(t11, r16);
}
function w4(o10, r16) {
  const t11 = R3(o10, r16), l9 = r16 == null ? void 0 : r16.interpolateAlpha;
  return t11.forEach((o11, r17) => {
    o11.unshift(r17), l9 || o11.pop();
  }), t11;
}
function B3(o10) {
  const r16 = y2(o10);
  return { type: "HsvColor", Hue: r16.h, Saturation: r16.s, Value: r16.v, AlphaValue: 255 };
}
function D3(o10) {
  const r16 = o10.toJSON();
  return { Algorithm: (r16 == null ? void 0 : r16.Algorithm) || "esriHSVAlgorithm", type: "AlgorithmicColorRamp", FromColor: B3(o10.fromColor), ToColor: B3(o10.toColor) };
}
function I4(o10) {
  const r16 = s12(o10);
  if (!r16)
    return null;
  if ("algorithmic" === o10.type)
    return { ...D3(o10), Name: r16 };
  if (o10.colorRamps) {
    const t11 = o10.colorRamps.map(D3);
    return { type: "MultiPartColorRamp", NumColorRamps: t11.length, ArrayOfColorRamp: t11, Name: r16 };
  }
  return null;
}
function G2(o10) {
  const r16 = o10.reverse().map((o11) => {
    const r17 = o11.toString(16);
    return r17.length < 2 ? "0" + r17 : r17;
  });
  return 4294967295 & Number.parseInt(r16.join(""), 16);
}

// node_modules/@arcgis/core/renderers/support/rasterRendererChecks.js
function n13(n14) {
  var _a, _b, _c;
  return ["u8", "s8"].includes(n14.pixelType) && null != ((_b = (_a = n14.statistics) == null ? void 0 : _a[0]) == null ? void 0 : _b.min) && null != ((_c = n14.statistics[0]) == null ? void 0 : _c.max) && 1 === n14.bandCount;
}
function t10(t11, e8) {
  const { attributeTable: u14, bandCount: r16 } = t11;
  if (null == u14 && n13(t11))
    return true;
  if (null == u14 || r16 > 1)
    return false;
  if (e8) {
    if (null == u14.fields.find((n14) => n14.name.toLowerCase() === e8.toLowerCase()))
      return false;
  }
  return true;
}
function e7(n14) {
  const { bandCount: t11, dataType: e8, pixelType: u14 } = n14;
  return "elevation" === e8 || "generic" === e8 && 1 === t11 && ("s16" === u14 || "s32" === u14 || "f32" === u14 || "f64" === u14);
}
function u12(n14, t11 = false) {
  const { bandCount: e8, colormap: u14, pixelType: r16 } = n14;
  return 1 === e8 && (!!(u14 == null ? void 0 : u14.length) || !t11 && "u8" === r16);
}
function r15(n14, t11 = false) {
  const { attributeTable: e8, bandCount: u14 } = n14;
  return 1 === u14 && (!t11 || null != e8 || null != n14.histograms);
}
function o9(n14) {
  const { dataType: t11 } = n14;
  return "vector-uv" === t11 || "vector-magdir" === t11;
}
function i9(n14) {
  const { dataType: t11 } = n14;
  return "vector-uv" === t11 || "vector-magdir" === t11;
}

// node_modules/@arcgis/core/renderers/support/RasterSymbolizer.js
var _2 = class extends l {
  constructor(e8) {
    super(e8);
  }
  bind() {
    const { rendererJSON: e8 } = this;
    if (!e8)
      return { success: false };
    let t11;
    switch (this.lookup = { rendererJSON: {} }, e8.type) {
      case "uniqueValue":
        t11 = this._updateUVRenderer(e8);
        break;
      case "rasterColormap":
        t11 = this._updateColormapRenderer(e8);
        break;
      case "rasterStretch":
        t11 = this._updateStretchRenderer(e8);
        break;
      case "classBreaks":
        t11 = this._updateClassBreaksRenderer(e8);
        break;
      case "rasterShadedRelief":
        t11 = this._updateShadedReliefRenderer(e8);
        break;
      case "vectorField":
        t11 = this._updateVectorFieldRenderer();
        break;
      case "flowRenderer":
        t11 = this._updateFlowRenderer();
    }
    return t11;
  }
  symbolize(e8) {
    let t11 = e8 && e8.pixelBlock;
    if (!C5(t11))
      return t11;
    if (e8.simpleStretchParams && "rasterStretch" === this.rendererJSON.type)
      return this.simpleStretch(t11, e8.simpleStretchParams);
    try {
      let r16;
      switch (t11.pixels.length > 3 && (t11 = t11.extractBands([0, 1, 2])), this.rendererJSON.type) {
        case "uniqueValue":
        case "rasterColormap":
          r16 = this._symbolizeColormap(t11);
          break;
        case "classBreaks":
          r16 = this._symbolizeClassBreaks(t11);
          break;
        case "rasterStretch":
          r16 = this._symbolizeStretch(t11, e8.bandIds);
          break;
        case "rasterShadedRelief": {
          const s14 = e8.extent, a16 = s14.spatialReference.isGeographic, o10 = { x: (s14.xmax - s14.xmin) / t11.width, y: (s14.ymax - s14.ymin) / t11.height };
          r16 = this._symbolizeShadedRelief(t11, { isGCS: a16, resolution: o10 });
          break;
        }
      }
      return r16;
    } catch (r16) {
      return s.getLogger(this).error("symbolize", r16.message), t11;
    }
  }
  simpleStretch(e8, t11) {
    if (!C5(e8))
      return e8;
    try {
      return e8.pixels.length > 3 && (e8 = e8.extractBands([0, 1, 2])), M3(e8, { ...t11, isRenderer: true });
    } catch (r16) {
      return s.getLogger(this).error("symbolize", r16.message), e8;
    }
  }
  generateWebGLParameters(e8) {
    if (["uniqueValue", "rasterColormap", "classBreaks"].includes(this.rendererJSON.type)) {
      const { indexedColormap: e9, offset: t12 } = this.lookup.colormapLut || {};
      return { colormap: e9, colormapOffset: t12, type: "lut" };
    }
    const { pixelBlock: t11, isGCS: r16, resolution: s14, bandIds: a16 } = e8, { rendererJSON: o10 } = this;
    return "rasterStretch" === o10.type ? this._generateStretchWebGLParams(t11, o10, a16) : "rasterShadedRelief" === o10.type ? this._generateShadedReliefWebGLParams(o10, r16, s14 ?? void 0) : "vectorField" === o10.type ? this._generateVectorFieldWebGLParams(o10) : null;
  }
  _isLUTChanged(e8) {
    if (!this.lookup || !this.lookup.rendererJSON)
      return true;
    if ("colorRamp" in this.rendererJSON) {
      const t11 = this.rendererJSON.colorRamp;
      return e8 ? JSON.stringify(t11) !== JSON.stringify(this.lookup.rendererJSON.colorRamp) : (this.rendererJSON, this.lookup.rendererJSON, JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON));
    }
    return JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON);
  }
  _symbolizeColormap(e8) {
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e8;
    }
    return h3(e8, this.lookup.colormapLut);
  }
  _symbolizeClassBreaks(e8) {
    const { canUseIndexedLUT: t11 } = this._analyzeClassBreaks(this.rendererJSON);
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e8;
    }
    return t11 ? h3(e8, this.lookup.colormapLut) : u5(e8, this.lookup.remapLut ?? []);
  }
  _symbolizeStretch(e8, t11) {
    var _a, _b;
    const { rasterInfo: r16 } = this, { pixelType: s14, bandCount: a16 } = r16, o10 = this.rendererJSON, n14 = ["u8", "u16", "s8", "s16"].includes(s14);
    let l9, c11;
    const { dra: p10 } = o10, { gamma: f11 } = this.lookup;
    if ("histogramEqualization" === o10.stretchType) {
      const s15 = p10 ? null : (_a = this.lookup) == null ? void 0 : _a.histogramLut, a17 = p5(o10, { rasterInfo: r16, pixelBlock: e8, bandIds: t11, returnHistogramLut: !s15 }), n15 = M3(e8, { ...a17, gamma: f11, isRenderer: true });
      c11 = f6(n15, { lut: p10 ? a17.histogramLut : s15, offset: 0 });
    } else if (n14) {
      if (p10) {
        const a17 = p5(o10, { rasterInfo: r16, pixelBlock: e8, bandIds: t11 });
        l9 = a10({ pixelType: s14, ...a17, gamma: f11, rounding: "floor" });
      } else if (this._isLUTChanged()) {
        if (!this.bind().success)
          return e8;
        l9 = this.lookup ? this.lookup.stretchLut : null;
      } else
        l9 = this.lookup ? this.lookup.stretchLut : null;
      if (!l9)
        return e8;
      a16 > 1 && null != t11 && t11.length === (e8 == null ? void 0 : e8.pixels.length) && (l9 == null ? void 0 : l9.lut.length) === a16 && (l9 = { lut: t11.map((e9) => l9.lut[e9]), offset: l9.offset }), c11 = f6(e8, l9);
    } else {
      const s15 = p5(o10, { rasterInfo: r16, pixelBlock: e8, bandIds: t11 });
      c11 = M3(e8, { ...s15, gamma: f11, isRenderer: true });
    }
    if (o10.colorRamp) {
      if (this._isLUTChanged(true)) {
        if (!this.bind().success)
          return e8;
      }
      c11 = h3(c11, (_b = this.lookup) == null ? void 0 : _b.colormapLut);
    }
    return c11;
  }
  _symbolizeShadedRelief(e8, t11) {
    var _a;
    const r16 = this.rendererJSON, s14 = { ...r16, ...t11 }, a16 = o8(e8, s14);
    if (!r16.colorRamp)
      return a16;
    let o10;
    if (this._isLUTChanged(true)) {
      if (!this.bind().success)
        return a16;
      o10 = this.lookup ? this.lookup.hsvMap : null;
    } else
      o10 = this.lookup ? this.lookup.hsvMap : null;
    if (!o10)
      return a16;
    const n14 = ((_a = this.rasterInfo.statistics) == null ? void 0 : _a[0]) ?? { min: 0, max: 8e3 };
    return r14(a16, e8, o10, n14), a16;
  }
  _isVectorFieldData() {
    const { bandCount: e8, dataType: t11 } = this.rasterInfo;
    return 2 === e8 && ("vector-magdir" === t11 || "vector-uv" === t11);
  }
  _updateVectorFieldRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateFlowRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateUVRenderer(e8) {
    var _a;
    const { bandCount: t11, attributeTable: r16, pixelType: s14 } = this.rasterInfo, a16 = e8.field1;
    if (!a16)
      return { success: false, error: "Unsupported renderer; missing UniqueValueRenderer.field." };
    const o10 = e8.defaultSymbol, n14 = 1 === t11 && ["u8", "s8"].includes(s14);
    if (!t10(this.rasterInfo, a16) && !n14)
      return { success: false, error: "Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table." };
    const i11 = [];
    if (null != r16) {
      const t12 = r16.fields.find((e9) => "value" === e9.name.toLowerCase());
      if (!t12)
        return { success: false, error: "Unsupported data; the data's raster attribute table does not have a value field." };
      r16.features.forEach((r17) => {
        var _a2, _b;
        const s15 = (_a2 = e8.uniqueValueInfos) == null ? void 0 : _a2.find((e9) => String(e9.value) === String(r17.attributes[a16])), n15 = (_b = s15 == null ? void 0 : s15.symbol) == null ? void 0 : _b.color;
        n15 ? i11.push([r17.attributes[t12.name]].concat(n15)) : o10 && i11.push([r17.attributes[t12.name]].concat(o10.color));
      });
    } else {
      if ("value" !== a16.toLowerCase())
        return { success: false, error: 'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.' };
      (_a = e8.uniqueValueInfos) == null ? void 0 : _a.forEach((e9) => {
        var _a2;
        const t12 = (_a2 = e9 == null ? void 0 : e9.symbol) == null ? void 0 : _a2.color;
        t12 ? i11.push([parseInt("" + e9.value, 10)].concat(t12)) : o10 && i11.push([parseInt("" + e9.value, 10)].concat(o10 == null ? void 0 : o10.color));
      });
    }
    if (0 === i11.length)
      return { success: false, error: "Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table." };
    const l9 = a8({ colormap: i11 });
    return this.lookup = { rendererJSON: e8, colormapLut: l9 }, this.canRenderInWebGL = true, { success: true };
  }
  _updateColormapRenderer(e8) {
    if (!u12(this.rasterInfo))
      return { success: false, error: "Unsupported data; the data source does not have a colormap." };
    const t11 = e8.colormapInfos.map((e9) => [e9.value].concat(e9.color)).sort((e9, t12) => e9[0] - t12[0]);
    if (!t11 || 0 === t11.length)
      return { success: false, error: "Unsupported renderer; ColormapRenderer must have meaningful colormapInfos." };
    const r16 = a8({ colormap: t11 });
    return this.lookup = { rendererJSON: e8, colormapLut: r16 }, this.canRenderInWebGL = true, { success: true };
  }
  _updateShadedReliefRenderer(e8) {
    if (!e7(this.rasterInfo))
      return { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.` };
    if (e8.colorRamp) {
      const r16 = w4(e8.colorRamp, { interpolateAlpha: true }), s14 = a8({ colormap: r16 }), a16 = [], o10 = s14.indexedColormap;
      for (let e9 = 0; e9 < o10.length; e9 += 4) {
        const r17 = y2({ r: o10[e9], g: o10[e9 + 1], b: o10[e9 + 2] });
        a16.push([r17.h / 60, r17.s / 100, 255 * r17.v / 100]);
      }
      this.lookup = { rendererJSON: e8, colormapLut: s14, hsvMap: a16 };
    } else
      this.lookup = null;
    return this.canRenderInWebGL = true, { success: true };
  }
  _analyzeClassBreaks(e8) {
    const { attributeTable: t11, pixelType: r16 } = this.rasterInfo, s14 = null != t11 ? t11.fields.find((e9) => "value" === e9.name.toLowerCase()) : null, a16 = null != t11 ? t11.fields.find((t12) => t12.name.toLowerCase() === e8.field.toLowerCase()) : null, o10 = null != s14 && null !== a16;
    return { canUseIndexedLUT: ["u8", "u16", "s8", "s16"].includes(r16) || o10, tableValueField: s14, tableBreakField: a16 };
  }
  _updateClassBreaksRenderer(e8) {
    const { attributeTable: t11 } = this.rasterInfo, { canUseIndexedLUT: r16, tableValueField: s14, tableBreakField: a16 } = this._analyzeClassBreaks(e8), o10 = e8.classBreakInfos;
    if (!(o10 == null ? void 0 : o10.length))
      return { success: false, error: "Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos." };
    const n14 = o10.sort((e9, t12) => e9.classMaxValue - t12.classMaxValue), i11 = n14[n14.length - 1];
    let l9 = e8.minValue;
    if (!r16) {
      const t12 = [];
      for (let e9 = 0; e9 < n14.length; e9++)
        t12.push({ value: n14[e9].classMinValue ?? l9, mappedColor: n14[e9].symbol.color }), l9 = n14[e9].classMaxValue;
      return t12.push({ value: i11.classMaxValue, mappedColor: i11.symbol.color }), this.lookup = { rendererJSON: e8, remapLut: t12 }, this.canRenderInWebGL = false, { success: true };
    }
    const u14 = [];
    if (null != t11 && null != s14 && null !== a16 && s14 !== a16) {
      const r17 = s14.name, o11 = a16.name, i12 = n14[n14.length - 1], { classMaxValue: c11 } = i12;
      l9 = e8.minValue;
      for (const e9 of t11.features) {
        const t12 = e9.attributes[r17], s15 = e9.attributes[o11], a17 = s15 === c11 ? i12 : s15 < l9 ? null : n14.find(({ classMaxValue: e10 }) => e10 > s15);
        a17 && u14.push([t12].concat(a17.symbol.color));
      }
    } else {
      l9 = Math.floor(e8.minValue);
      for (let e9 = 0; e9 < n14.length; e9++) {
        const t12 = n14[e9];
        for (let e10 = l9; e10 < t12.classMaxValue; e10++)
          u14.push([e10].concat(t12.symbol.color));
        l9 = Math.ceil(t12.classMaxValue);
      }
      i11.classMaxValue === l9 && u14.push([i11.classMaxValue].concat(i11.symbol.color));
    }
    const p10 = a8({ colormap: u14, fillUnspecified: false });
    return this.lookup = { rendererJSON: e8, colormapLut: p10 }, this.canRenderInWebGL = true, { success: true };
  }
  _isHistogramRequired(e8) {
    return "percentClip" === e8 || "histogramEqualization" === e8;
  }
  _isValidRasterStatistics(e8) {
    return null != e8 && e8.length > 0 && null != e8[0].min && null != e8[0].max;
  }
  _updateStretchRenderer(e8) {
    var _a, _b;
    let { stretchType: t11, dra: r16 } = e8;
    if (!("none" === t11 || ((_a = e8.statistics) == null ? void 0 : _a.length) || this._isValidRasterStatistics(this.rasterInfo.statistics) || r16))
      return { success: false, error: "Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used." };
    const s14 = e8.histograms || this.rasterInfo.histograms;
    !this._isHistogramRequired(e8.stretchType) || (s14 == null ? void 0 : s14.length) || r16 || (t11 = "minMax");
    const { computeGamma: a16, useGamma: o10, colorRamp: n14 } = e8;
    let { gamma: i11 } = e8;
    if (o10 && a16 && !(i11 == null ? void 0 : i11.length)) {
      const t12 = ((_b = e8.statistics) == null ? void 0 : _b.length) ? e8.statistics : this.rasterInfo.statistics;
      i11 = u6(this.rasterInfo.pixelType, t12);
    }
    const l9 = this.rasterInfo.pixelType, u14 = !r16 && ["u8", "u16", "s8", "s16"].includes(l9);
    if ("histogramEqualization" === t11) {
      const t12 = s14.map((e9) => r12(e9));
      this.lookup = { rendererJSON: e8, histogramLut: t12 };
    } else if (u14) {
      const t12 = p5(e8, { rasterInfo: this.rasterInfo }), r17 = a10({ pixelType: l9, ...t12, gamma: o10 ? i11 : null, rounding: "floor" });
      this.lookup = { rendererJSON: e8, stretchLut: r17 };
    }
    if (n14) {
      const t12 = w4(n14, { interpolateAlpha: true });
      this.lookup || (this.lookup = { rendererJSON: e8 }), this.lookup.colormapLut = a8({ colormap: t12 }), this.lookup.rendererJSON = e8;
    }
    return this.lookup.gamma = o10 && (i11 == null ? void 0 : i11.length) ? i11 : null, this.canRenderInWebGL = true, { success: true };
  }
  _generateStretchWebGLParams(e8, t11, r16) {
    let s14 = null, a16 = null;
    const o10 = this.lookup && this.lookup.colormapLut;
    t11.colorRamp && o10 && (s14 = o10.indexedColormap, a16 = o10.offset), "histogramEqualization" === t11.stretchType && (t11 = { ...t11, stretchType: "minMax" });
    const { gamma: n14 } = this.lookup, i11 = !!(t11.useGamma && n14 && n14.some((e9) => 1 !== e9)), { minCutOff: l9, maxCutOff: u14, outMin: c11, outMax: p10 } = p5(t11, { rasterInfo: this.rasterInfo, pixelBlock: e8, bandIds: r16 });
    let d8 = 0;
    null != e8 && (d8 = e8.getPlaneCount(), 2 === d8 && ((e8 = e8.clone()).statistics = [e8.statistics[0]], e8.pixels = [e8.pixels[0]]));
    const { bandCount: m8 } = this.rasterInfo, f11 = Math.min(3, (r16 == null ? void 0 : r16.length) || d8 || m8, m8), y7 = new Float32Array(f11), g7 = s14 || i11 ? 1 : 255;
    let b5;
    for (b5 = 0; b5 < l9.length; b5++)
      y7[b5] = u14[b5] === l9[b5] ? 0 : (p10 - c11) / (u14[b5] - l9[b5]) / g7;
    const S4 = new Float32Array(f11);
    if (i11 && n14)
      for (b5 = 0; b5 < f11; b5++)
        n14[b5] > 1 ? n14[b5] > 2 ? S4[b5] = 6.5 + (n14[b5] - 2) ** 2.5 : S4[b5] = 6.5 + 100 * (2 - n14[b5]) ** 4 : S4[b5] = 1;
    return { bandCount: f11, outMin: c11 / g7, outMax: p10 / g7, minCutOff: l9, maxCutOff: u14, factor: y7, useGamma: i11, gamma: i11 ? n14 : [1, 1, 1], gammaCorrection: i11 ? S4 : [1, 1, 1], colormap: s14, colormapOffset: a16, stretchType: t11.stretchType, type: "stretch" };
  }
  _generateShadedReliefWebGLParams(e8, t11 = false, r16 = { x: 0, y: 0 }) {
    var _a;
    let s14 = null, a16 = null;
    const o10 = this.lookup && this.lookup.colormapLut;
    e8.colorRamp && o10 && (s14 = o10.indexedColormap, a16 = o10.offset);
    const n14 = { ...e8, isGCS: t11, resolution: r16 }, i11 = n11(n14), l9 = (_a = this.rasterInfo.statistics) == null ? void 0 : _a[0];
    return { ...i11, minValue: (l9 == null ? void 0 : l9.min) ?? 0, maxValue: (l9 == null ? void 0 : l9.max) ?? 8e3, hillshadeType: "traditional" === e8.hillshadeType ? 0 : 1, type: "hillshade", colormap: s14, colormapOffset: a16 };
  }
  _generateVectorFieldWebGLParams(e8) {
    var _a, _b, _c;
    const { style: t11, inputUnit: r16, outputUnit: s14, visualVariables: a16, symbolTileSize: o10, flowRepresentation: n14 } = e8;
    let i11;
    const l9 = ((_a = this.rasterInfo.statistics) == null ? void 0 : _a[0].min) ?? 0, u14 = ((_b = this.rasterInfo.statistics) == null ? void 0 : _b[0].max) ?? 50, c11 = (a16 == null ? void 0 : a16.find((e9) => "sizeInfo" === e9.type)) ?? { type: "sizeInfo", field: "Magnitude", maxDataValue: u14, maxSize: 0.8 * o10, minDataValue: l9, minSize: 0.2 * o10 }, p10 = c11.minDataValue ?? l9, d8 = c11.maxDataValue ?? u14, h10 = null != c11.maxSize && null != c11.minSize ? [c11.minSize / o10, c11.maxSize / o10] : [0.2, 0.8];
    if ("wind_speed" === t11) {
      const e9 = (h10[0] + h10[1]) / 2;
      h10[0] = h10[1] = e9;
    }
    const m8 = null != p10 && null != d8 ? [p10, d8] : null;
    if ("classified_arrow" === t11)
      if (null != p10 && null != d8 && null != c11) {
        i11 = [];
        const e9 = (c11.maxDataValue - c11.minDataValue) / 5;
        for (let t12 = 0; t12 < 6; t12++)
          i11.push(c11.minDataValue + e9 * t12);
      } else
        i11 = [0, 1e-6, 3.5, 7, 10.5, 14];
    const f11 = "flow_to" === n14 === ("ocean_current_kn" === t11 || "ocean_current_m" === t11) ? 0 : Math.PI, y7 = a16 == null ? void 0 : a16.find((e9) => "rotationInfo" === e9.type);
    return { breakValues: i11, dataRange: m8, inputUnit: r16, outputUnit: s14, symbolTileSize: o10, symbolPercentRange: h10, style: t11 || "single_arrow", rotation: f11, rotationType: ((_c = this.rasterInfo.storageInfo) == null ? void 0 : _c.tileInfo) && "vector-uv" === this.rasterInfo.dataType ? "geographic" : (y7 == null ? void 0 : y7.rotationType) || e8.rotationType, type: "vectorField" };
  }
};
function C5(e8) {
  return o4(e8) && 0 !== e8.validPixelCount;
}
e([y({ json: { write: true } })], _2.prototype, "rendererJSON", void 0), e([y({ type: m5, json: { write: true } })], _2.prototype, "rasterInfo", void 0), e([y({ json: { write: true } })], _2.prototype, "lookup", void 0), e([y()], _2.prototype, "canRenderInWebGL", void 0), _2 = e([a2("esri.renderers.support.RasterSymbolizer")], _2);
var L2 = _2;

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var i10 = s.getLogger("esri.views.2d.engine.flow.dataUtils");
var a15 = 10;
async function s13(t11, e8, r16, o10) {
  const l9 = performance.now(), s14 = c10(e8, r16), f11 = performance.now(), h10 = u13(e8, s14, r16.width, r16.height), p10 = performance.now(), g7 = m7(h10, true), y7 = performance.now(), x6 = "Streamlines" === t11 ? d7(g7, a15) : w5(g7), M6 = performance.now();
  return has("esri-2d-profiler") && (i10.info("I.1", "_createFlowFieldFromData (ms)", Math.round(f11 - l9)), i10.info("I.2", "_getStreamlines (ms)", Math.round(p10 - f11)), i10.info("I.3", "createAnimatedLinesData (ms)", Math.round(y7 - p10)), i10.info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M6 - y7)), i10.info("I.5", "createFlowMesh (ms)", Math.round(M6 - l9)), i10.info("I.6", "Mesh size (bytes)", x6.vertexData.buffer.byteLength + x6.indexData.buffer.byteLength)), await Promise.resolve(), s3(o10), x6;
}
function c10(t11, e8) {
  const n14 = h9(e8.data, e8.width, e8.height, t11.smoothing);
  if (t11.interpolate) {
    return (t12, r16) => {
      const o10 = Math.floor(t12), l9 = Math.floor(r16);
      if (o10 < 0 || o10 >= e8.width)
        return [0, 0];
      if (l9 < 0 || l9 >= e8.height)
        return [0, 0];
      const i11 = t12 - o10, a16 = r16 - l9, s14 = o10, c11 = l9, f11 = o10 < e8.width - 1 ? o10 + 1 : o10, u14 = l9 < e8.height - 1 ? l9 + 1 : l9, h10 = n14[2 * (c11 * e8.width + s14)], m8 = n14[2 * (c11 * e8.width + f11)], d8 = n14[2 * (u14 * e8.width + s14)], w6 = n14[2 * (u14 * e8.width + f11)], p10 = n14[2 * (c11 * e8.width + s14) + 1], g7 = n14[2 * (c11 * e8.width + f11) + 1];
      return [(h10 * (1 - a16) + d8 * a16) * (1 - i11) + (m8 * (1 - a16) + w6 * a16) * i11, (p10 * (1 - a16) + n14[2 * (u14 * e8.width + s14) + 1] * a16) * (1 - i11) + (g7 * (1 - a16) + n14[2 * (u14 * e8.width + f11) + 1] * a16) * i11];
    };
  }
  return (t12, r16) => {
    const o10 = Math.round(t12), l9 = Math.round(r16);
    return o10 < 0 || o10 >= e8.width || l9 < 0 || l9 >= e8.height ? [0, 0] : [n14[2 * (l9 * e8.width + o10)], n14[2 * (l9 * e8.width + o10) + 1]];
  };
}
function f10(t11, e8, n14, r16, o10, l9, i11, a16, s14) {
  const c11 = [];
  let f11 = n14, u14 = r16, h10 = 0, [m8, d8] = e8(f11, u14);
  m8 *= t11.velocityScale, d8 *= t11.velocityScale;
  const w6 = Math.sqrt(m8 * m8 + d8 * d8);
  let p10, g7;
  c11.push({ x: f11, y: u14, t: h10, speed: w6 });
  for (let y7 = 0; y7 < t11.verticesPerLine; y7++) {
    let [n15, r17] = e8(f11, u14);
    n15 *= t11.velocityScale, r17 *= t11.velocityScale;
    const m9 = Math.sqrt(n15 * n15 + r17 * r17);
    if (m9 < t11.minSpeedThreshold)
      return c11;
    const d9 = n15 / m9, w7 = r17 / m9;
    f11 += d9 * t11.segmentLength, u14 += w7 * t11.segmentLength;
    if (h10 += t11.segmentLength / m9, Math.acos(d9 * p10 + w7 * g7) > t11.maxTurnAngle)
      return c11;
    if (t11.collisions) {
      const t12 = Math.round(f11 * s14), e9 = Math.round(u14 * s14);
      if (t12 < 0 || t12 > i11 - 1 || e9 < 0 || e9 > a16 - 1)
        return c11;
      const n16 = l9[e9 * i11 + t12];
      if (-1 !== n16 && n16 !== o10)
        return c11;
      l9[e9 * i11 + t12] = o10;
    }
    c11.push({ x: f11, y: u14, t: h10, speed: m9 }), p10 = d9, g7 = w7;
  }
  return c11;
}
function u13(t11, e8, n14, o10) {
  const l9 = [], i11 = new t(), a16 = 1 / Math.max(t11.lineCollisionWidth, 1), s14 = Math.round(n14 * a16), c11 = Math.round(o10 * a16), u14 = new Int32Array(s14 * c11);
  for (let r16 = 0; r16 < u14.length; r16++)
    u14[r16] = -1;
  const h10 = [];
  for (let r16 = 0; r16 < o10; r16 += t11.lineSpacing)
    for (let e9 = 0; e9 < n14; e9 += t11.lineSpacing)
      h10.push({ x: e9, y: r16, sort: i11.getFloat() });
  h10.sort((t12, e9) => t12.sort - e9.sort);
  for (const { x: r16, y: m8 } of h10)
    if (i11.getFloat() < t11.density) {
      const n15 = f10(t11, e8, r16, m8, l9.length, u14, s14, c11, a16);
      if (n15.length < 2)
        continue;
      l9.push(n15);
    }
  return l9;
}
function h9(t11, e8, n14, r16) {
  if (0 === r16)
    return t11;
  const o10 = Math.round(3 * r16), l9 = new Array(2 * o10 + 1);
  let i11 = 0;
  for (let c11 = -o10; c11 <= o10; c11++) {
    const t12 = Math.exp(-c11 * c11 / (r16 * r16));
    l9[c11 + o10] = t12, i11 += t12;
  }
  for (let c11 = -o10; c11 <= o10; c11++)
    l9[c11 + o10] /= i11;
  const a16 = new Float32Array(t11.length);
  for (let c11 = 0; c11 < n14; c11++)
    for (let n15 = 0; n15 < e8; n15++) {
      let r17 = 0, i12 = 0;
      for (let a17 = -o10; a17 <= o10; a17++) {
        if (n15 + a17 < 0 || n15 + a17 >= e8)
          continue;
        const s15 = l9[a17 + o10];
        r17 += s15 * t11[2 * (c11 * e8 + (n15 + a17))], i12 += s15 * t11[2 * (c11 * e8 + (n15 + a17)) + 1];
      }
      a16[2 * (c11 * e8 + n15)] = r17, a16[2 * (c11 * e8 + n15) + 1] = i12;
    }
  const s14 = new Float32Array(t11.length);
  for (let c11 = 0; c11 < e8; c11++)
    for (let t12 = 0; t12 < n14; t12++) {
      let r17 = 0, i12 = 0;
      for (let s15 = -o10; s15 <= o10; s15++) {
        if (t12 + s15 < 0 || t12 + s15 >= n14)
          continue;
        const f11 = l9[s15 + o10];
        r17 += f11 * a16[2 * ((t12 + s15) * e8 + c11)], i12 += f11 * a16[2 * ((t12 + s15) * e8 + c11) + 1];
      }
      s14[2 * (t12 * e8 + c11)] = r17, s14[2 * (t12 * e8 + c11) + 1] = i12;
    }
  return s14;
}
function m7(t11, e8) {
  const n14 = new t(), o10 = t11.reduce((t12, e9) => t12 + e9.length, 0), l9 = new Float32Array(4 * o10), i11 = new Array(t11.length);
  let a16 = 0, s14 = 0;
  for (const r16 of t11) {
    const t12 = a16;
    for (const e9 of r16)
      l9[4 * a16] = e9.x, l9[4 * a16 + 1] = e9.y, l9[4 * a16 + 2] = e9.t, l9[4 * a16 + 3] = e9.speed, a16++;
    i11[s14++] = { startVertex: t12, numberOfVertices: r16.length, totalTime: r16[r16.length - 1].t, timeSeed: e8 ? n14.getFloat() : 0 };
  }
  return { lineVertices: l9, lineDescriptors: i11 };
}
function d7(t11, e8) {
  const n14 = 9, { lineVertices: r16, lineDescriptors: o10 } = t11;
  let l9 = 0, i11 = 0;
  for (const m8 of o10) {
    l9 += 2 * m8.numberOfVertices;
    i11 += 6 * (m8.numberOfVertices - 1);
  }
  const a16 = new Float32Array(l9 * n14), s14 = new Uint32Array(i11);
  let c11 = 0, f11 = 0;
  function u14() {
    s14[f11++] = c11 - 2, s14[f11++] = c11, s14[f11++] = c11 - 1, s14[f11++] = c11, s14[f11++] = c11 + 1, s14[f11++] = c11 - 1;
  }
  function h10(t12, e9, r17, o11, l10, i12, s15, f12) {
    const u15 = c11 * n14;
    let h11 = 0;
    a16[u15 + h11++] = t12, a16[u15 + h11++] = e9, a16[u15 + h11++] = 1, a16[u15 + h11++] = r17, a16[u15 + h11++] = i12, a16[u15 + h11++] = s15, a16[u15 + h11++] = o11 / 2, a16[u15 + h11++] = l10 / 2, a16[u15 + h11++] = f12, c11++, a16[u15 + h11++] = t12, a16[u15 + h11++] = e9, a16[u15 + h11++] = -1, a16[u15 + h11++] = r17, a16[u15 + h11++] = i12, a16[u15 + h11++] = s15, a16[u15 + h11++] = -o11 / 2, a16[u15 + h11++] = -l10 / 2, a16[u15 + h11++] = f12, c11++;
  }
  for (const m8 of o10) {
    const { totalTime: t12, timeSeed: n15 } = m8;
    let o11 = null, l10 = null, i12 = null, a17 = null, s15 = null, c12 = null;
    for (let f12 = 0; f12 < m8.numberOfVertices; f12++) {
      const d8 = r16[4 * (m8.startVertex + f12)], w6 = r16[4 * (m8.startVertex + f12) + 1], p10 = r16[4 * (m8.startVertex + f12) + 2], g7 = r16[4 * (m8.startVertex + f12) + 3];
      let y7 = null, x6 = null, M6 = null, A4 = null;
      if (f12 > 0) {
        y7 = d8 - o11, x6 = w6 - l10;
        const r17 = Math.sqrt(y7 * y7 + x6 * x6);
        if (y7 /= r17, x6 /= r17, f12 > 1) {
          let t13 = y7 + s15, n16 = x6 + c12;
          const r18 = Math.sqrt(t13 * t13 + n16 * n16);
          t13 /= r18, n16 /= r18;
          const o12 = Math.min(1 / (t13 * y7 + n16 * x6), e8);
          t13 *= o12, n16 *= o12, M6 = -n16, A4 = t13;
        } else
          M6 = -x6, A4 = y7;
        null !== M6 && null !== A4 && (h10(o11, l10, i12, M6, A4, t12, n15, g7), u14());
      }
      o11 = d8, l10 = w6, i12 = p10, s15 = y7, c12 = x6, a17 = g7;
    }
    h10(o11, l10, i12, -c12, s15, t12, n15, a17);
  }
  return { vertexData: a16, indexData: s14 };
}
function w5(t11) {
  const e8 = 16, n14 = 1, r16 = 2, { lineVertices: o10, lineDescriptors: l9 } = t11;
  let i11 = 0, a16 = 0;
  for (const U4 of l9) {
    const t12 = U4.numberOfVertices - 1;
    i11 += 4 * t12 * 2, a16 += 6 * t12 * 2;
  }
  const s14 = new Float32Array(i11 * e8), c11 = new Uint32Array(a16);
  let f11, u14, h10, m8, d8, w6, p10, g7, y7, x6, M6, A4, I5, V2, F2 = 0, D4 = 0;
  function v6() {
    c11[D4++] = F2 - 8, c11[D4++] = F2 - 7, c11[D4++] = F2 - 6, c11[D4++] = F2 - 7, c11[D4++] = F2 - 5, c11[D4++] = F2 - 6, c11[D4++] = F2 - 4, c11[D4++] = F2 - 3, c11[D4++] = F2 - 2, c11[D4++] = F2 - 3, c11[D4++] = F2 - 1, c11[D4++] = F2 - 2;
  }
  function b5(t12, o11, l10, i12, a17, c12, f12, u15, h11, m9, d9, w7, p11, g8) {
    const y8 = F2 * e8;
    let x7 = 0;
    for (const e9 of [n14, r16])
      for (const n15 of [1, 2, 3, 4])
        s14[y8 + x7++] = t12, s14[y8 + x7++] = o11, s14[y8 + x7++] = l10, s14[y8 + x7++] = i12, s14[y8 + x7++] = f12, s14[y8 + x7++] = u15, s14[y8 + x7++] = h11, s14[y8 + x7++] = m9, s14[y8 + x7++] = e9, s14[y8 + x7++] = n15, s14[y8 + x7++] = p11, s14[y8 + x7++] = g8, s14[y8 + x7++] = a17 / 2, s14[y8 + x7++] = c12 / 2, s14[y8 + x7++] = d9 / 2, s14[y8 + x7++] = w7 / 2, F2++;
  }
  function S4(t12, e9) {
    let n15 = y7 + M6, r17 = x6 + A4;
    const o11 = Math.sqrt(n15 * n15 + r17 * r17);
    n15 /= o11, r17 /= o11;
    const l10 = y7 * n15 + x6 * r17;
    n15 /= l10, r17 /= l10;
    let i12 = M6 + I5, a17 = A4 + V2;
    const s15 = Math.sqrt(i12 * i12 + a17 * a17);
    i12 /= s15, a17 /= s15;
    const c12 = M6 * i12 + A4 * a17;
    i12 /= c12, a17 /= c12, b5(f11, u14, h10, m8, -r17, n15, d8, w6, p10, g7, -a17, i12, t12, e9), v6();
  }
  function k5(t12, e9, n15, r17, o11, l10) {
    if (y7 = M6, x6 = A4, M6 = I5, A4 = V2, null == y7 && null == x6 && (y7 = M6, x6 = A4), null != d8 && null != w6) {
      I5 = t12 - d8, V2 = e9 - w6;
      const n16 = Math.sqrt(I5 * I5 + V2 * V2);
      I5 /= n16, V2 /= n16;
    }
    null != y7 && null != x6 && S4(o11, l10), f11 = d8, u14 = w6, h10 = p10, m8 = g7, d8 = t12, w6 = e9, p10 = n15, g7 = r17;
  }
  function L3(t12, e9) {
    y7 = M6, x6 = A4, M6 = I5, A4 = V2, null == y7 && null == x6 && (y7 = M6, x6 = A4), null != y7 && null != x6 && S4(t12, e9);
  }
  for (const U4 of l9) {
    f11 = null, u14 = null, h10 = null, m8 = null, d8 = null, w6 = null, p10 = null, g7 = null, y7 = null, x6 = null, M6 = null, A4 = null, I5 = null, V2 = null;
    const { totalTime: t12, timeSeed: e9 } = U4;
    for (let n15 = 0; n15 < U4.numberOfVertices; n15++) {
      k5(o10[4 * (U4.startVertex + n15)], o10[4 * (U4.startVertex + n15) + 1], o10[4 * (U4.startVertex + n15) + 2], o10[4 * (U4.startVertex + n15) + 3], t12, e9);
    }
    L3(t12, e9);
  }
  return { vertexData: s14, indexData: c11 };
}

export {
  s6 as s,
  u,
  u2,
  r9 as r,
  n5 as n,
  r10 as r2,
  L,
  R,
  D,
  U,
  N,
  v2 as v,
  B,
  P2 as P,
  j,
  n6 as n2,
  l4 as l,
  i6 as i,
  o4 as o,
  r11 as r3,
  f6 as f,
  c5 as c,
  p4 as p,
  g3 as g,
  y5 as y,
  w3 as w,
  U3 as U2,
  T3 as T,
  W2 as W,
  I3 as I,
  R2,
  n10 as n3,
  m5 as m,
  s11 as s2,
  c8 as c2,
  h7 as h,
  u10 as u3,
  n12 as n4,
  C4 as C,
  a14 as a,
  s12 as s3,
  c9 as c3,
  R3,
  w4 as w2,
  I4 as I2,
  G2 as G,
  n7 as n5,
  a9 as a2,
  a10 as a3,
  m4 as m2,
  h4 as h2,
  g4 as g2,
  p5 as p2,
  d3 as d,
  M3 as M,
  s9 as s4,
  a11 as a4,
  l6 as l2,
  u7 as u4,
  f8 as f2,
  p6 as p3,
  t10 as t,
  e7 as e,
  u12 as u5,
  r15 as r4,
  o9 as o2,
  i9 as i2,
  L2,
  s13 as s5
};
//# sourceMappingURL=chunk-F5EKF66B.js.map
