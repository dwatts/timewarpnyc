/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.5.0
 */
import Sortable from "sortablejs";
import { containsCrossShadowBoundary } from "./dom";
const sortableComponentSet = new Set();
const inactiveSortableComponentSet = new WeakSet();
/**
 * Helper to keep track of a SortableComponent. This should be called in the `connectedCallback` lifecycle method as well as any other method necessary to rebuild the sortable instance.
 *
 * @param {SortableComponent} component - The sortable component.
 */
export function connectSortableComponent(component) {
  disconnectSortableComponent(component);
  sortableComponentSet.add(component);
  if (inactiveSortableComponentSet.has(component)) {
    return;
  }
  const dataIdAttr = "id";
  const { group, handleSelector: handle, dragSelector: draggable } = component;
  component.sortable = Sortable.create(component.el, {
    dataIdAttr,
    ...(!!draggable && { draggable }),
    ...(!!group && {
      group: {
        name: group,
        ...(!!component.canPull && {
          pull: (to, from, dragEl) => component.canPull({ toEl: to.el, fromEl: from.el, dragEl }),
        }),
        ...(!!component.canPut && {
          put: (to, from, dragEl) => component.canPut({ toEl: to.el, fromEl: from.el, dragEl }),
        }),
      },
    }),
    handle,
    onStart: (event) => {
      onSortingStart(component);
      component.onDragStart(event);
    },
    onEnd: (event) => {
      onSortingEnd(component);
      component.onDragEnd(event);
    },
    onSort: (event) => {
      component.onDragSort(event);
    },
  });
}
/**
 * Helper to remove track of a SortableComponent. This should be called in the `disconnectedCallback` lifecycle method.
 *
 * @param {SortableComponent} component - The sortable component.
 */
export function disconnectSortableComponent(component) {
  sortableComponentSet.delete(component);
  if (inactiveSortableComponentSet.has(component)) {
    return;
  }
  component.sortable?.destroy();
  component.sortable = null;
}
function getNestedSortableComponents(activeComponent) {
  return Array.from(sortableComponentSet).filter((component) => component !== activeComponent && containsCrossShadowBoundary(activeComponent.el, component.el));
}
/**
 * Helper to handle nested SortableComponents on `Sortable.onStart`.
 *
 * @param {SortableComponent} activeComponent - The active sortable component.
 */
function onSortingStart(activeComponent) {
  getNestedSortableComponents(activeComponent).forEach((component) => inactiveSortableComponentSet.add(component));
}
/**
 * Helper to handle nested SortableComponents on `Sortable.onEnd`.
 *
 * @param {SortableComponent} activeComponent - The active sortable component.
 */
function onSortingEnd(activeComponent) {
  getNestedSortableComponents(activeComponent).forEach((component) => inactiveSortableComponentSet.delete(component));
}
