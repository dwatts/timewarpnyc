import{ay as f,az as g,aB as J,bB as Q,bx as U,iw as V,ix as X,bz as B,iy as Y,gK as A,iz as N,iA as Z,iB as k,iC as tt,iD as nt,iE as I,f8 as w,f7 as z,iF as et,iG as ot,ae as rt,iH as j,iI as $,fL as O,iJ as it,iK as at,fn as x,iL as st,eb as S,iM as L,aV as lt,iN as P,iO as ct,iP as _,iQ as ut,iu as v,iR as pt,iS as ft,iT as gt,iU as ht,iV as yt,iW as mt,fs as xt,ca as At,iX as $t,iY as wt,iZ as vt}from"./index-c4c50d1e.js";import{m as bt}from"./MeshGeoreferencedRelativeVertexSpace-6aae6b12.js";import{m as Mt,p as Rt}from"./MeshLocalVertexSpace-d0f92601.js";var b;let p=b=class extends Q{constructor(t){super(t),this.translation=U(),this.rotationAxis=V(X),this.rotationAngle=0,this.scale=B(1,1,1)}get rotation(){return Y(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=A(N(t)),this.rotationAngle=Z(t)}get localMatrix(){const t=w();return k(T,N(this.rotation),tt(this.rotation)),nt(t,T,this.translation,this.scale),t}get localMatrixInverse(){return I(w(),this.localMatrix)}applyLocal(t,n){return z(n,t,this.localMatrix)}applyLocalInverse(t,n){return z(n,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&et(this.localMatrix,t.localMatrix)}clone(){const t={translation:A(this.translation),rotationAxis:A(this.rotationAxis),rotationAngle:this.rotationAngle,scale:A(this.scale)};return new b(t)}};f([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),f([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotationAxis",void 0),f([g({type:Number,nonNullable:!0,json:{write:!0}})],p.prototype,"rotationAngle",void 0),f([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),f([g()],p.prototype,"rotation",null),f([g()],p.prototype,"localMatrix",null),f([g()],p.prototype,"localMatrixInverse",null),p=b=f([J("esri.geometry.support.MeshTransform")],p);const T=ot(),Ft=p;function G(t,n){return t.isGeographic||t.isWebMercator&&((n==null?void 0:n.geographic)??!0)}function Et(t,n,e){const o=!t.isGeoreferenced;(e==null?void 0:e.geographic)!=null&&e.geographic!==o&&rt.getLogger(n).warnOnce(`Specifying the 'geographic' parameter (${e.geographic}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}function R(t,n,e){return G(n.spatialReference,e)?Ot(t,n,e):jt(t,n,e)}function C(t,n,e,o){const{position:i,normal:r,tangent:a}=t;if(!n.isRelative)return{position:i,normal:r,tangent:a};const l=(e==null?void 0:e.localMatrix)??$;return R({position:x(new Float64Array(i.length),i,l),normal:r!=null?wt(r,new Float32Array(r.length),l):null,tangent:a!=null?vt(a,new Float32Array(a.length),l):null},n.getOriginPoint(o),{geographic:!n.isGeoreferenced})}function dt(t,n,e){if(e!=null&&e.useTransform){const{position:o,normal:i,tangent:r}=t,{x:a,y:l,z:c}=n,s=B(a,l,c??0);return{vertexAttributes:{position:o,normal:i,tangent:r},vertexSpace:e.geographic??1?new Mt({origin:s}):new bt({origin:s}),transform:new Ft}}return{vertexAttributes:R(t,n,e),vertexSpace:new Rt,transform:null}}function M(t,n,e){return G(n.spatialReference,e)?It(t,n,e):W(t,n,e)}function Nt(t,n,e,o,i){if(!n.isRelative)return M(t,o,i);const{spatialReference:r}=o,a=C(t,n,e,r);return o.equals(n.getOriginPoint(r))?W(a,o,i):M(a,o,i)}function zt({positions:t,transform:n,vertexSpace:e,inSpatialReference:o,outSpatialReference:i,outPositions:r,local:a}){const l=e.isRelative?e.origin:j,c=e.isRelative?(n==null?void 0:n.localMatrix)??$:$;if(e.isGeoreferenced){const u=r??O(t.length);if(it(c,$)?at(u,t):x(u,t,c),!st(l,j)){const[K,D,H]=l;for(let m=0;m<u.length;m+=3)u[m]+=K,u[m+1]+=D,u[m+2]+=H}return S(u,o,0,u,i,0,u.length/3),u}const s=L(o),d=!a&&lt(o,s)?s:o;P(o,l,h,d),ct(h,h,c);const y=r??O(t.length);return x(y,t,h),S(y,d,0,y,i,0,y.length/3),y}function jt(t,n,e){const o=new Float64Array(t.position.length),i=t.position,r=n.x,a=n.y,l=n.z??0,c=F(e?e.unit:null,n.spatialReference);for(let s=0;s<i.length;s+=3)o[s]=i[s]*c+r,o[s+1]=i[s+1]*c+a,o[s+2]=i[s+2]*c+l;return{position:o,normal:t.normal,tangent:t.tangent}}function Ot(t,n,e){const o=n.spatialReference,i=q(n,e,h),r=new Float64Array(t.position.length),a=St(t.position,i,o,r),l=_(E,i);return{position:a,normal:Tt(a,r,t.normal,l,o),tangent:Bt(a,r,t.tangent,l,o)}}function St(t,n,e,o){x(o,t,n);const i=new Float64Array(t.length);return ut(o,i,e)}function Tt(t,n,e,o,i){if(e==null)return null;const r=new Float32Array(e.length);return v(r,e,o),pt(r,t,n,i,r),r}function Bt(t,n,e,o,i){if(e==null)return null;const r=new Float32Array(e.length);v(r,e,o,4);for(let a=3;a<r.length;a+=4)r[a]=e[a];return ft(r,t,n,i,r),r}function W(t,n,e){const o=new Float64Array(t.position.length),i=t.position,r=n.x,a=n.y,l=n.z??0,c=F(e?e.unit:null,n.spatialReference);for(let s=0;s<i.length;s+=3)o[s]=(i[s]-r)/c,o[s+1]=(i[s+1]-a)/c,o[s+2]=(i[s+2]-l)/c;return{position:o,normal:t.normal,tangent:t.tangent}}function It(t,n,e){const o=n.spatialReference;q(n,e,h);const i=I(Gt,h),r=new Float64Array(t.position.length),a=Lt(t.position,o,i,r),l=_(E,i);return{position:a,normal:Pt(t.normal,t.position,r,o,l),tangent:_t(t.tangent,t.position,r,o,l)}}function q(t,n,e){P(t.spatialReference,[t.x,t.y,t.z??0],e,L(t.spatialReference));const o=F(n?n.unit:null,t.spatialReference);return gt(e,e,[o,o,o]),e}function Lt(t,n,e,o){const i=ht(t,n,o),r=new Float64Array(i.length);return x(r,i,e),r}function Pt(t,n,e,o,i){if(t==null)return null;const r=yt(t,n,e,o,new Float32Array(t.length));return v(r,r,i),r}function _t(t,n,e,o,i){if(t==null)return null;const r=mt(t,n,e,o,new Float32Array(t.length));return v(r,r,i,4),r}function F(t,n){if(t==null)return 1;const e=xt(n);return 1/At(e,"meters",t)}const h=w(),Gt=w(),E=$t(),Kt=Object.freeze(Object.defineProperty({__proto__:null,georeference:R,georeferenceApplyTransform:C,georeferenceByTransform:dt,project:zt,ungeoreference:M,ungeoreferenceByTransform:Nt},Symbol.toStringTag,{value:"Module"}));export{M as D,Nt as E,zt as I,Ft as N,R as O,C as T,Kt as g,Et as o,dt as q,G as r};
